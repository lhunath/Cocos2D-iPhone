/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_spidermonkey_bindings.py -c cocos2d_spidermonkey.ini" on 2012-07-23
*/

// needed for callbacks from objective-c to JS
#import <objc/runtime.h>
#import "JRSwizzle.h"

#import "jstypedarray.h"
#import "js_bindings_config.h"
#import "ScriptingCore.h"

#import "js_bindings_cocos2d_classes.h"


/*
 * CCNode
 */
#pragma mark - CCNode

JSClass* JSPROXY_CCNode_class = NULL;
JSObject* JSPROXY_CCNode_object = NULL;
 // Constructor
JSBool JSPROXY_CCNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCNode createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCNode_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCNode)", obj);
}

// Arguments: 
// Ret value: CCActionManager* (o)
JSBool JSPROXY_CCNode_actionManager(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionManager* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real actionManager ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*, NSInteger, NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCNode_addChild_z_tag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc >= 1 && argc <= 3 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; int32_t arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if (argc >= 2) {
		ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	}
	if( ! ok ) return JS_FALSE;

	if( argc == 1 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real addChild:(CCNode*)arg0  ];
	}
	else if( argc == 2 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real addChild:(CCNode*)arg0 z:(NSInteger)arg1  ];
	}
	else if( argc == 3 ) {
		CCNode *real = (CCNode*) [proxy realObj];
	[real addChild:(CCNode*)arg0 z:(NSInteger)arg1 tag:(NSInteger)arg2  ];
	}
	else
		return JS_FALSE;

	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCNode_anchorPoint(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real anchorPoint ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCNode_anchorPointInPoints(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real anchorPointInPoints ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSPROXY_CCNode_boundingBox(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGRect ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real boundingBox ];

	jsval ret_jsval = CGRect_to_jsval( cx, (CGRect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCamera* (o)
JSBool JSPROXY_CCNode_camera(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCCamera* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real camera ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCArray* (array)
JSBool JSPROXY_CCNode_children(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCArray* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real children ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_cleanup(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real cleanup ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCNode_contentSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real contentSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCNode_convertToNodeSpace_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToNodeSpace:(CGPoint)arg0  ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCNode_convertToNodeSpaceAR_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToNodeSpaceAR:(CGPoint)arg0  ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCNode_convertToWorldSpace_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToWorldSpace:(CGPoint)arg0  ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCNode_convertToWorldSpaceAR_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real convertToWorldSpaceAR:(CGPoint)arg0  ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_draw(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real draw ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: CCAction* (o)
JSBool JSPROXY_CCNode_getActionByTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCAction* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real getActionByTag:(NSInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: CCNode* (o)
JSBool JSPROXY_CCNode_getChildByTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCNode* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real getChildByTag:(NSInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccGLServerState (i)
JSBool JSPROXY_CCNode_glServerState(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccGLServerState ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real glServerState ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGridBase* (o)
JSBool JSPROXY_CCNode_grid(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGridBase* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real grid ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCNode_ignoreAnchorPointForPosition(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real ignoreAnchorPointForPosition ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCNode_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = [(CCNode*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCNode_isRunning(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real isRunning ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSPROXY_CCNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCNode* ret_val;

	ret_val = [CCNode node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSPROXY_CCNode_nodeToParentTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real nodeToParentTransform ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 6 );
	CGAffineTransform* buffer = (CGAffineTransform*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSPROXY_CCNode_nodeToWorldTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real nodeToWorldTransform ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 6 );
	CGAffineTransform* buffer = (CGAffineTransform*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCNode_numberOfRunningActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real numberOfRunningActions ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCNode_orderOfArrival(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real orderOfArrival ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSPROXY_CCNode_parent(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCNode* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real parent ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSPROXY_CCNode_parentToNodeTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real parentToNodeTransform ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 6 );
	CGAffineTransform* buffer = (CGAffineTransform*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_pauseSchedulerAndActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real pauseSchedulerAndActions ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCNode_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real position ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCNode_removeAllChildrenWithCleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real removeAllChildrenWithCleanup:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*, BOOL
// Ret value: void (None)
JSBool JSPROXY_CCNode_removeChild_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; JSBool arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real removeChild:(CCNode*)arg0 cleanup:(BOOL)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger, BOOL
// Ret value: void (None)
JSBool JSPROXY_CCNode_removeChildByTag_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real removeChildByTag:(NSInteger)arg0 cleanup:(BOOL)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCNode_removeFromParentAndCleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real removeFromParentAndCleanup:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*, NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCNode_reorderChild_z_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real reorderChild:(CCNode*)arg0 z:(NSInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_resumeSchedulerAndActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real resumeSchedulerAndActions ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_rotation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real rotation ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_rotationX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real rotationX ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_rotationY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real rotationY ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCAction*
// Ret value: CCAction* (o)
JSBool JSPROXY_CCNode_runAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCAction* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real runAction:(CCAction*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_scale(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scale ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_scaleX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scaleX ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_scaleY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scaleY ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_scheduleUpdate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real scheduleUpdate ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCNode_scheduleUpdateWithPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real scheduleUpdateWithPriority:(NSInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScheduler* (o)
JSBool JSPROXY_CCNode_scheduler(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCScheduler* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real scheduler ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionManager*
// Ret value: void (None)
JSBool JSPROXY_CCNode_setActionManager_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setActionManager:(CCActionManager*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCNode_setAnchorPoint_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setAnchorPoint:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCNode_setContentSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setContentSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGLServerState
// Ret value: void (None)
JSBool JSPROXY_CCNode_setGlServerState_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setGlServerState:(ccGLServerState)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCGridBase*
// Ret value: void (None)
JSBool JSPROXY_CCNode_setGrid_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setGrid:(CCGridBase*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCNode_setIgnoreAnchorPointForPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setIgnoreAnchorPointForPosition:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCNode_setOrderOfArrival_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setOrderOfArrival:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCNode_setParent_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setParent:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCNode_setPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setPosition:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setRotation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setRotation:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setRotationX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setRotationX:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setRotationY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setRotationY:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setScale_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScale:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setScaleX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScaleX:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setScaleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScaleY:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCScheduler*
// Ret value: void (None)
JSBool JSPROXY_CCNode_setScheduler_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setScheduler:(CCScheduler*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCGLProgram*
// Ret value: void (None)
JSBool JSPROXY_CCNode_setShaderProgram_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setShaderProgram:(CCGLProgram*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setSkewX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setSkewX:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setSkewY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setSkewY:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCNode_setTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setTag:(NSInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCNode_setUserObject_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setUserObject:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCNode_setVertexZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setVertexZ:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCNode_setVisible_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setVisible:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCNode_setZOrder_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real setZOrder:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGLProgram* (o)
JSBool JSPROXY_CCNode_shaderProgram(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGLProgram* ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real shaderProgram ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_skewX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real skewX ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_skewY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real skewY ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_sortAllChildren(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real sortAllChildren ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCAction*
// Ret value: void (None)
JSBool JSPROXY_CCNode_stopAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real stopAction:(CCAction*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCNode_stopActionByTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCNode *real = (CCNode*) [proxy realObj];
	[real stopActionByTag:(NSInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_stopAllActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real stopAllActions ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSPROXY_CCNode_tag(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real tag ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_transform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real transform ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_transformAncestors(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real transformAncestors ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_unscheduleAllSelectors(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real unscheduleAllSelectors ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_unscheduleUpdate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real unscheduleUpdate ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCNode_vertexZ(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real vertexZ ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCNode_visible(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real visible ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCNode_visit(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCNode *real = (CCNode*) [proxy realObj];
	[real visit ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGAffineTransform ({CGAffineTransform=ffffff})
JSBool JSPROXY_CCNode_worldToNodeTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGAffineTransform ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real worldToNodeTransform ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 6 );
	CGAffineTransform* buffer = (CGAffineTransform*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSPROXY_CCNode_zOrder(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSInteger ret_val;

	CCNode *real = (CCNode*) [proxy realObj];
	ret_val = [real zOrder ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSPROXY_CCNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCNode_class->name = name;
	JSPROXY_CCNode_class->addProperty = JS_PropertyStub;
	JSPROXY_CCNode_class->delProperty = JS_PropertyStub;
	JSPROXY_CCNode_class->getProperty = JS_PropertyStub;
	JSPROXY_CCNode_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCNode_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCNode_class->resolve = JS_ResolveStub;
	JSPROXY_CCNode_class->convert = JS_ConvertStub;
	JSPROXY_CCNode_class->finalize = JSPROXY_CCNode_finalize;
//	JSPROXY_CCNode_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getActionManager", JSPROXY_CCNode_actionManager, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("addChild", JSPROXY_CCNode_addChild_z_tag_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAnchorPoint", JSPROXY_CCNode_anchorPoint, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAnchorPointInPoints", JSPROXY_CCNode_anchorPointInPoints, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("boundingBox", JSPROXY_CCNode_boundingBox, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getCamera", JSPROXY_CCNode_camera, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getChildren", JSPROXY_CCNode_children, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("cleanup", JSPROXY_CCNode_cleanup, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getContentSize", JSPROXY_CCNode_contentSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("convertToNodeSpace", JSPROXY_CCNode_convertToNodeSpace_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("convertToNodeSpaceAR", JSPROXY_CCNode_convertToNodeSpaceAR_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("convertToWorldSpace", JSPROXY_CCNode_convertToWorldSpace_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("convertToWorldSpaceAR", JSPROXY_CCNode_convertToWorldSpaceAR_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("draw", JSPROXY_CCNode_draw, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getActionByTag", JSPROXY_CCNode_getActionByTag_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getChildByTag", JSPROXY_CCNode_getChildByTag_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getGlServerState", JSPROXY_CCNode_glServerState, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getGrid", JSPROXY_CCNode_grid, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getIgnoreAnchorPointForPosition", JSPROXY_CCNode_ignoreAnchorPointForPosition, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("init", JSPROXY_CCNode_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getIsRunning", JSPROXY_CCNode_isRunning, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("nodeToParentTransform", JSPROXY_CCNode_nodeToParentTransform, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("nodeToWorldTransform", JSPROXY_CCNode_nodeToWorldTransform, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("numberOfRunningActions", JSPROXY_CCNode_numberOfRunningActions, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOrderOfArrival", JSPROXY_CCNode_orderOfArrival, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getParent", JSPROXY_CCNode_parent, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("parentToNodeTransform", JSPROXY_CCNode_parentToNodeTransform, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("pauseSchedulerAndActions", JSPROXY_CCNode_pauseSchedulerAndActions, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSPROXY_CCNode_position, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeAllChildrenWithCleanup", JSPROXY_CCNode_removeAllChildrenWithCleanup_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeChild", JSPROXY_CCNode_removeChild_cleanup_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeChildByTag", JSPROXY_CCNode_removeChildByTag_cleanup_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeFromParentAndCleanup", JSPROXY_CCNode_removeFromParentAndCleanup_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reorderChild", JSPROXY_CCNode_reorderChild_z_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("resumeSchedulerAndActions", JSPROXY_CCNode_resumeSchedulerAndActions, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRotation", JSPROXY_CCNode_rotation, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRotationX", JSPROXY_CCNode_rotationX, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRotationY", JSPROXY_CCNode_rotationY, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("runAction", JSPROXY_CCNode_runAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getScale", JSPROXY_CCNode_scale, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getScaleX", JSPROXY_CCNode_scaleX, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getScaleY", JSPROXY_CCNode_scaleY, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("scheduleUpdate", JSPROXY_CCNode_scheduleUpdate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("scheduleUpdateWithPriority", JSPROXY_CCNode_scheduleUpdateWithPriority_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getScheduler", JSPROXY_CCNode_scheduler, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setActionManager", JSPROXY_CCNode_setActionManager_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAnchorPoint", JSPROXY_CCNode_setAnchorPoint_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setContentSize", JSPROXY_CCNode_setContentSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setGlServerState", JSPROXY_CCNode_setGlServerState_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setGrid", JSPROXY_CCNode_setGrid_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setIgnoreAnchorPointForPosition", JSPROXY_CCNode_setIgnoreAnchorPointForPosition_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOrderOfArrival", JSPROXY_CCNode_setOrderOfArrival_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setParent", JSPROXY_CCNode_setParent_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSPROXY_CCNode_setPosition_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRotation", JSPROXY_CCNode_setRotation_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRotationX", JSPROXY_CCNode_setRotationX_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRotationY", JSPROXY_CCNode_setRotationY_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setScale", JSPROXY_CCNode_setScale_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setScaleX", JSPROXY_CCNode_setScaleX_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setScaleY", JSPROXY_CCNode_setScaleY_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setScheduler", JSPROXY_CCNode_setScheduler_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setShaderProgram", JSPROXY_CCNode_setShaderProgram_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSkewX", JSPROXY_CCNode_setSkewX_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSkewY", JSPROXY_CCNode_setSkewY_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTag", JSPROXY_CCNode_setTag_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUserObject", JSPROXY_CCNode_setUserObject_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setVertexZ", JSPROXY_CCNode_setVertexZ_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setVisible", JSPROXY_CCNode_setVisible_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setZOrder", JSPROXY_CCNode_setZOrder_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getShaderProgram", JSPROXY_CCNode_shaderProgram, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSkewX", JSPROXY_CCNode_skewX, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSkewY", JSPROXY_CCNode_skewY, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("sortAllChildren", JSPROXY_CCNode_sortAllChildren, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("stopAction", JSPROXY_CCNode_stopAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("stopActionByTag", JSPROXY_CCNode_stopActionByTag_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("stopAllActions", JSPROXY_CCNode_stopAllActions, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTag", JSPROXY_CCNode_tag, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("transform", JSPROXY_CCNode_transform, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("transformAncestors", JSPROXY_CCNode_transformAncestors, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllSelectors", JSPROXY_CCNode_unscheduleAllSelectors, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("unscheduleUpdate", JSPROXY_CCNode_unscheduleUpdate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getVertexZ", JSPROXY_CCNode_vertexZ, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getVisible", JSPROXY_CCNode_visible, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("visit", JSPROXY_CCNode_visit, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("worldToNodeTransform", JSPROXY_CCNode_worldToNodeTransform, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getZOrder", JSPROXY_CCNode_zOrder, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCNode_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCNode_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCNode_class, JSPROXY_CCNode_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCNode_class, JSPROXY_CCNode_object, NULL);
	JSPROXY_CCNode *proxy = [[JSPROXY_CCNode alloc] initWithJSObject:jsobj class:[CCNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

+(void) swizzleMethods
{
	[super swizzleMethods];

	static BOOL CCNode_already_swizzled = NO;
	if( ! CCNode_already_swizzled ) {
		NSError *error;

		if( ! [CCNode jr_swizzleMethod:@selector(onExit) withMethod:@selector(JSHook_onExit) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(onExitTransitionDidStart) withMethod:@selector(JSHook_onExitTransitionDidStart) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(onEnterTransitionDidFinish) withMethod:@selector(JSHook_onEnterTransitionDidFinish) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(onEnter) withMethod:@selector(JSHook_onEnter) error:&error] )
			NSLog(@"Error swizzling %@", error);

		if( ! [CCNode jr_swizzleMethod:@selector(update:) withMethod:@selector(JSHook_update:) error:&error] )
			NSLog(@"Error swizzling %@", error);

		CCNode_already_swizzled = YES;
	}
}

-(void) onExit
{
	if (_jsObj) {
		JSContext* cx = [[ScriptingCore sharedInstance] globalContext];
		JSBool found;
		JS_HasProperty(cx, _jsObj, "onExit", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onExit", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
}

-(void) onExitTransitionDidStart
{
	if (_jsObj) {
		JSContext* cx = [[ScriptingCore sharedInstance] globalContext];
		JSBool found;
		JS_HasProperty(cx, _jsObj, "onExitTransitionDidStart", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onExitTransitionDidStart", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
}

-(void) onEnterTransitionDidFinish
{
	if (_jsObj) {
		JSContext* cx = [[ScriptingCore sharedInstance] globalContext];
		JSBool found;
		JS_HasProperty(cx, _jsObj, "onEnterTransitionDidFinish", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onEnterTransitionDidFinish", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
}

-(void) onEnter
{
	if (_jsObj) {
		JSContext* cx = [[ScriptingCore sharedInstance] globalContext];
		JSBool found;
		JS_HasProperty(cx, _jsObj, "onEnter", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			jsval *argv = NULL; unsigned argc=0;

			JS_GetProperty(cx, _jsObj, "onEnter", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
}

-(void) update:(ccTime)delta 
{
	if (_jsObj) {
		JSContext* cx = [[ScriptingCore sharedInstance] globalContext];
		JSBool found;
		JS_HasProperty(cx, _jsObj, "update", &found);
		if (found == JS_TRUE) {
			jsval rval, fval;
			unsigned argc=1;
			jsval argv[1];
			argv[0] = DOUBLE_TO_JSVAL(delta);

			JS_GetProperty(cx, _jsObj, "update", &fval);
			JS_CallFunctionValue(cx, _jsObj, fval, argc, argv, &rval);
		}
	}
}

@end
@implementation CCNode (SpiderMonkey)

-(void) JSHook_onExit
{
	//1st call native, then JS. Order is important
	[self JSHook_onExit];
	JSPROXY_CCNode *proxy = objc_getAssociatedObject(self, &JSPROXY_association_proxy_key);
	if( proxy )
		[proxy onExit];
}

-(void) JSHook_onExitTransitionDidStart
{
	//1st call native, then JS. Order is important
	[self JSHook_onExitTransitionDidStart];
	JSPROXY_CCNode *proxy = objc_getAssociatedObject(self, &JSPROXY_association_proxy_key);
	if( proxy )
		[proxy onExitTransitionDidStart];
}

-(void) JSHook_onEnterTransitionDidFinish
{
	//1st call native, then JS. Order is important
	[self JSHook_onEnterTransitionDidFinish];
	JSPROXY_CCNode *proxy = objc_getAssociatedObject(self, &JSPROXY_association_proxy_key);
	if( proxy )
		[proxy onEnterTransitionDidFinish];
}

-(void) JSHook_onEnter
{
	//1st call native, then JS. Order is important
	[self JSHook_onEnter];
	JSPROXY_CCNode *proxy = objc_getAssociatedObject(self, &JSPROXY_association_proxy_key);
	if( proxy )
		[proxy onEnter];
}

-(void) JSHook_update:(ccTime)delta 
{
	//1st call native, then JS. Order is important
	[self JSHook_update:delta ];
	JSPROXY_CCNode *proxy = objc_getAssociatedObject(self, &JSPROXY_association_proxy_key);
	if( proxy )
		[proxy update:delta ];
}
@end

/*
 * CCParticleSystem
 */
#pragma mark - CCParticleSystem

JSClass* JSPROXY_CCParticleSystem_class = NULL;
JSObject* JSPROXY_CCParticleSystem_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleSystem_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleSystem createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleSystem_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleSystem)", obj);
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCParticleSystem_active(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real active ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_angle(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real angle ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_angleVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real angleVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCParticleSystem_atlasIndex(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real atlasIndex ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCParticleSystem_autoRemoveOnFinish(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real autoRemoveOnFinish ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleBatchNode* (o)
JSBool JSPROXY_CCParticleSystem_batchNode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleBatchNode* ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real batchNode ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCParticleSystem_blendAdditive(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real blendAdditive ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccBlendFunc ({_ccBlendFunc=II})
JSBool JSPROXY_CCParticleSystem_blendFunc(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccBlendFunc ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real blendFunc ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT32, 2 );
	ccBlendFunc* buffer = (ccBlendFunc*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCParticleSystem_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_duration(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real duration ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_emissionRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real emissionRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSPROXY_CCParticleSystem_emitterMode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real emitterMode ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F ({ccColor4F=ffff})
JSBool JSPROXY_CCParticleSystem_endColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endColor ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	ccColor4F* buffer = (ccColor4F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F ({ccColor4F=ffff})
JSBool JSPROXY_CCParticleSystem_endColorVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endColorVar ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	ccColor4F* buffer = (ccColor4F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_endRadius(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endRadius ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_endRadiusVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endRadiusVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_endSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSize ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_endSizeVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSizeVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_endSpin(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSpin ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_endSpinVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real endSpinVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCParticleSystem_gravity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real gravity ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCParticleSystem_initWithFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = [(CCParticleSystem*)[proxy.klass alloc] initWithFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCParticleSystem_initWithTotalParticles_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = [(CCParticleSystem*)[proxy.klass alloc] initWithTotalParticles:(NSUInteger)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCParticleSystem_isFull(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real isFull ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_life(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real life ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_lifeVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real lifeVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCParticleSystem_particleCount(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real particleCount ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSystem* (o)
JSBool JSPROXY_CCParticleSystem_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSystem* ret_val;

	ret_val = [CCParticleSystem particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSystem* (o)
JSBool JSPROXY_CCParticleSystem_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSystem* ret_val;

	ret_val = [CCParticleSystem particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCParticleSystem_posVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real posVar ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: tCCPositionType (i)
JSBool JSPROXY_CCParticleSystem_positionType(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	tCCPositionType ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real positionType ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_postStep(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real postStep ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_radialAccel(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real radialAccel ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_radialAccelVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real radialAccelVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_resetSystem(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real resetSystem ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_rotatePerSecond(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real rotatePerSecond ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_rotatePerSecondVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real rotatePerSecondVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setAngle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAngle:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setAngleVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAngleVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setAtlasIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAtlasIndex:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setAutoRemoveOnFinish_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setAutoRemoveOnFinish:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCParticleBatchNode*
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setBatchNode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setBatchNode:(CCParticleBatchNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setBlendAdditive_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setBlendAdditive:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccBlendFunc
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setBlendFunc_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccBlendFunc arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccBlendFunc*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setBlendFunc:(ccBlendFunc)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setDuration:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEmissionRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEmissionRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEmitterMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEmitterMode:(NSInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor4F*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndColor:(ccColor4F)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndColorVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor4F*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndColorVar:(ccColor4F)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndRadius_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndRadius:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndRadiusVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndRadiusVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSize:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndSizeVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSizeVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndSpin_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSpin:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setEndSpinVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setEndSpinVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setGravity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setGravity:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setLife_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setLife:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setLifeVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setLifeVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setPosVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setPosVar:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: tCCPositionType
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setPositionType_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setPositionType:(tCCPositionType)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setRadialAccel_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRadialAccel:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setRadialAccelVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRadialAccelVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setRotatePerSecond_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRotatePerSecond:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setRotatePerSecondVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setRotatePerSecondVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setSourcePosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setSourcePosition:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setSpeed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setSpeed:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setSpeedVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setSpeedVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor4F*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartColor:(ccColor4F)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor4F
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartColorVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor4F arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor4F*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartColorVar:(ccColor4F)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartRadius_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartRadius:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartRadiusVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartRadiusVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSize:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartSizeVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSizeVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartSpin_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSpin:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setStartSpinVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setStartSpinVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setTangentialAccel_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTangentialAccel:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setTangentialAccelVar_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTangentialAccelVar:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_setTotalParticles_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real setTotalParticles:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCParticleSystem_sourcePosition(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real sourcePosition ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_speed(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real speed ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_speedVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real speedVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F ({ccColor4F=ffff})
JSBool JSPROXY_CCParticleSystem_startColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startColor ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	ccColor4F* buffer = (ccColor4F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor4F ({ccColor4F=ffff})
JSBool JSPROXY_CCParticleSystem_startColorVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor4F ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startColorVar ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 4 );
	ccColor4F* buffer = (ccColor4F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_startRadius(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startRadius ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_startRadiusVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startRadiusVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_startSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSize ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_startSizeVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSizeVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_startSpin(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSpin ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_startSpinVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real startSpinVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_stopSystem(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real stopSystem ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_tangentialAccel(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real tangentialAccel ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCParticleSystem_tangentialAccelVar(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real tangentialAccelVar ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCParticleSystem_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCParticleSystem_totalParticles(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	ret_val = [real totalParticles ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystem_updateWithNoTime(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSystem *real = (CCParticleSystem*) [proxy realObj];
	[real updateWithNoTime ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSystem* (o)
JSBool JSPROXY_CCParticleSystem_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleSystem* ret_val;

	ret_val = [CCParticleSystem node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleSystem_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleSystem_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleSystem_class->name = name;
	JSPROXY_CCParticleSystem_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleSystem_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleSystem_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleSystem_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleSystem_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleSystem_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleSystem_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleSystem_class->finalize = JSPROXY_CCParticleSystem_finalize;
//	JSPROXY_CCParticleSystem_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getActive", JSPROXY_CCParticleSystem_active, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAngle", JSPROXY_CCParticleSystem_angle, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAngleVar", JSPROXY_CCParticleSystem_angleVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAtlasIndex", JSPROXY_CCParticleSystem_atlasIndex, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAutoRemoveOnFinish", JSPROXY_CCParticleSystem_autoRemoveOnFinish, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getBatchNode", JSPROXY_CCParticleSystem_batchNode, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getBlendAdditive", JSPROXY_CCParticleSystem_blendAdditive, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getBlendFunc", JSPROXY_CCParticleSystem_blendFunc, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCParticleSystem_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getDuration", JSPROXY_CCParticleSystem_duration, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEmissionRate", JSPROXY_CCParticleSystem_emissionRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEmitterMode", JSPROXY_CCParticleSystem_emitterMode, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndColor", JSPROXY_CCParticleSystem_endColor, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndColorVar", JSPROXY_CCParticleSystem_endColorVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndRadius", JSPROXY_CCParticleSystem_endRadius, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndRadiusVar", JSPROXY_CCParticleSystem_endRadiusVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndSize", JSPROXY_CCParticleSystem_endSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndSizeVar", JSPROXY_CCParticleSystem_endSizeVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndSpin", JSPROXY_CCParticleSystem_endSpin, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getEndSpinVar", JSPROXY_CCParticleSystem_endSpinVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getGravity", JSPROXY_CCParticleSystem_gravity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFile", JSPROXY_CCParticleSystem_initWithFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTotalParticles", JSPROXY_CCParticleSystem_initWithTotalParticles_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("isFull", JSPROXY_CCParticleSystem_isFull, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLife", JSPROXY_CCParticleSystem_life, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLifeVar", JSPROXY_CCParticleSystem_lifeVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getParticleCount", JSPROXY_CCParticleSystem_particleCount, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPosVar", JSPROXY_CCParticleSystem_posVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPositionType", JSPROXY_CCParticleSystem_positionType, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("postStep", JSPROXY_CCParticleSystem_postStep, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRadialAccel", JSPROXY_CCParticleSystem_radialAccel, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRadialAccelVar", JSPROXY_CCParticleSystem_radialAccelVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("resetSystem", JSPROXY_CCParticleSystem_resetSystem, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRotatePerSecond", JSPROXY_CCParticleSystem_rotatePerSecond, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRotatePerSecondVar", JSPROXY_CCParticleSystem_rotatePerSecondVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAngle", JSPROXY_CCParticleSystem_setAngle_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAngleVar", JSPROXY_CCParticleSystem_setAngleVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAtlasIndex", JSPROXY_CCParticleSystem_setAtlasIndex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAutoRemoveOnFinish", JSPROXY_CCParticleSystem_setAutoRemoveOnFinish_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBatchNode", JSPROXY_CCParticleSystem_setBatchNode_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendAdditive", JSPROXY_CCParticleSystem_setBlendAdditive_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSPROXY_CCParticleSystem_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDuration", JSPROXY_CCParticleSystem_setDuration_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEmissionRate", JSPROXY_CCParticleSystem_setEmissionRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEmitterMode", JSPROXY_CCParticleSystem_setEmitterMode_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndColor", JSPROXY_CCParticleSystem_setEndColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndColorVar", JSPROXY_CCParticleSystem_setEndColorVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndRadius", JSPROXY_CCParticleSystem_setEndRadius_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndRadiusVar", JSPROXY_CCParticleSystem_setEndRadiusVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndSize", JSPROXY_CCParticleSystem_setEndSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndSizeVar", JSPROXY_CCParticleSystem_setEndSizeVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndSpin", JSPROXY_CCParticleSystem_setEndSpin_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEndSpinVar", JSPROXY_CCParticleSystem_setEndSpinVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setGravity", JSPROXY_CCParticleSystem_setGravity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLife", JSPROXY_CCParticleSystem_setLife_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLifeVar", JSPROXY_CCParticleSystem_setLifeVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCParticleSystem_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPosVar", JSPROXY_CCParticleSystem_setPosVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPositionType", JSPROXY_CCParticleSystem_setPositionType_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRadialAccel", JSPROXY_CCParticleSystem_setRadialAccel_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRadialAccelVar", JSPROXY_CCParticleSystem_setRadialAccelVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRotatePerSecond", JSPROXY_CCParticleSystem_setRotatePerSecond_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRotatePerSecondVar", JSPROXY_CCParticleSystem_setRotatePerSecondVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSourcePosition", JSPROXY_CCParticleSystem_setSourcePosition_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSpeed", JSPROXY_CCParticleSystem_setSpeed_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSpeedVar", JSPROXY_CCParticleSystem_setSpeedVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartColor", JSPROXY_CCParticleSystem_setStartColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartColorVar", JSPROXY_CCParticleSystem_setStartColorVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartRadius", JSPROXY_CCParticleSystem_setStartRadius_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartRadiusVar", JSPROXY_CCParticleSystem_setStartRadiusVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartSize", JSPROXY_CCParticleSystem_setStartSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartSizeVar", JSPROXY_CCParticleSystem_setStartSizeVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartSpin", JSPROXY_CCParticleSystem_setStartSpin_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStartSpinVar", JSPROXY_CCParticleSystem_setStartSpinVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTangentialAccel", JSPROXY_CCParticleSystem_setTangentialAccel_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTangentialAccelVar", JSPROXY_CCParticleSystem_setTangentialAccelVar_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCParticleSystem_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTotalParticles", JSPROXY_CCParticleSystem_setTotalParticles_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSourcePosition", JSPROXY_CCParticleSystem_sourcePosition, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSpeed", JSPROXY_CCParticleSystem_speed, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSpeedVar", JSPROXY_CCParticleSystem_speedVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartColor", JSPROXY_CCParticleSystem_startColor, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartColorVar", JSPROXY_CCParticleSystem_startColorVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartRadius", JSPROXY_CCParticleSystem_startRadius, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartRadiusVar", JSPROXY_CCParticleSystem_startRadiusVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartSize", JSPROXY_CCParticleSystem_startSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartSizeVar", JSPROXY_CCParticleSystem_startSizeVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartSpin", JSPROXY_CCParticleSystem_startSpin, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStartSpinVar", JSPROXY_CCParticleSystem_startSpinVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("stopSystem", JSPROXY_CCParticleSystem_stopSystem, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTangentialAccel", JSPROXY_CCParticleSystem_tangentialAccel, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTangentialAccelVar", JSPROXY_CCParticleSystem_tangentialAccelVar, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCParticleSystem_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTotalParticles", JSPROXY_CCParticleSystem_totalParticles, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("update", JSPROXY_CCParticleSystem_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("updateWithNoTime", JSPROXY_CCParticleSystem_updateWithNoTime, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleSystem_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleSystem_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleSystem_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleSystem_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCParticleSystem_class, JSPROXY_CCParticleSystem_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleSystem

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleSystem_class, JSPROXY_CCParticleSystem_object, NULL);
	JSPROXY_CCParticleSystem *proxy = [[JSPROXY_CCParticleSystem alloc] initWithJSObject:jsobj class:[CCParticleSystem class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSystemQuad
 */
#pragma mark - CCParticleSystemQuad

JSClass* JSPROXY_CCParticleSystemQuad_class = NULL;
JSObject* JSPROXY_CCParticleSystemQuad_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleSystemQuad_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleSystemQuad createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleSystemQuad_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleSystemQuad)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystemQuad_initIndices(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real initIndices ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystemQuad_initTexCoordsWithRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real initTexCoordsWithRect:(CGRect)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystemQuad_setDisplayFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real setDisplayFrame:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: void (None)
JSBool JSPROXY_CCParticleSystemQuad_setTexture_withRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCParticleSystemQuad *real = (CCParticleSystemQuad*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0 withRect:(CGRect)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSystemQuad* (o)
JSBool JSPROXY_CCParticleSystemQuad_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSystemQuad* ret_val;

	ret_val = [CCParticleSystemQuad particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSystemQuad* (o)
JSBool JSPROXY_CCParticleSystemQuad_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSystemQuad* ret_val;

	ret_val = [CCParticleSystemQuad particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSystemQuad* (o)
JSBool JSPROXY_CCParticleSystemQuad_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleSystemQuad* ret_val;

	ret_val = [CCParticleSystemQuad node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleSystemQuad_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleSystemQuad_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleSystemQuad_class->name = name;
	JSPROXY_CCParticleSystemQuad_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleSystemQuad_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleSystemQuad_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleSystemQuad_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleSystemQuad_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleSystemQuad_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleSystemQuad_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleSystemQuad_class->finalize = JSPROXY_CCParticleSystemQuad_finalize;
//	JSPROXY_CCParticleSystemQuad_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initIndices", JSPROXY_CCParticleSystemQuad_initIndices, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initTexCoordsWithRect", JSPROXY_CCParticleSystemQuad_initTexCoordsWithRect_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDisplayFrame", JSPROXY_CCParticleSystemQuad_setDisplayFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTextureWithRect", JSPROXY_CCParticleSystemQuad_setTexture_withRect_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCParticleSystemQuad_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("createWithTotalParticles", JSPROXY_CCParticleSystemQuad_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCParticleSystemQuad_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleSystemQuad_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystem_object, JSPROXY_CCParticleSystemQuad_class, JSPROXY_CCParticleSystemQuad_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleSystemQuad

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleSystemQuad_class, JSPROXY_CCParticleSystemQuad_object, NULL);
	JSPROXY_CCParticleSystemQuad *proxy = [[JSPROXY_CCParticleSystemQuad alloc] initWithJSObject:jsobj class:[CCParticleSystemQuad class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleMeteor
 */
#pragma mark - CCParticleMeteor

JSClass* JSPROXY_CCParticleMeteor_class = NULL;
JSObject* JSPROXY_CCParticleMeteor_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleMeteor_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleMeteor createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleMeteor_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleMeteor)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleMeteor_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleMeteor *real = [(CCParticleMeteor*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleMeteor* (o)
JSBool JSPROXY_CCParticleMeteor_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleMeteor* ret_val;

	ret_val = [CCParticleMeteor particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleMeteor* (o)
JSBool JSPROXY_CCParticleMeteor_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleMeteor* ret_val;

	ret_val = [CCParticleMeteor particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleMeteor* (o)
JSBool JSPROXY_CCParticleMeteor_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleMeteor* ret_val;

	ret_val = [CCParticleMeteor node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleMeteor_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleMeteor_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleMeteor_class->name = name;
	JSPROXY_CCParticleMeteor_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleMeteor_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleMeteor_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleMeteor_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleMeteor_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleMeteor_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleMeteor_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleMeteor_class->finalize = JSPROXY_CCParticleMeteor_finalize;
//	JSPROXY_CCParticleMeteor_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleMeteor_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleMeteor_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleMeteor_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleMeteor_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleMeteor_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleMeteor_class, JSPROXY_CCParticleMeteor_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleMeteor

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleMeteor_class, JSPROXY_CCParticleMeteor_object, NULL);
	JSPROXY_CCParticleMeteor *proxy = [[JSPROXY_CCParticleMeteor alloc] initWithJSObject:jsobj class:[CCParticleMeteor class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItem
 */
#pragma mark - CCMenuItem

JSClass* JSPROXY_CCMenuItem_class = NULL;
JSObject* JSPROXY_CCMenuItem_object = NULL;
 // Constructor
JSBool JSPROXY_CCMenuItem_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMenuItem createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMenuItem_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMenuItem)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCMenuItem_activate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real activate ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCMenuItem_cleanup(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real cleanup ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: None (None)
JSBool JSPROXY_CCMenuItem_initWithBlock_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItem *real = [(CCMenuItem*)[proxy.klass alloc] initWithBlock:(void (^)(id))arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCMenuItem_isEnabled(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	ret_val = [real isEnabled ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCMenuItem_isSelected(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	ret_val = [real isSelected ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItem* (o)
JSBool JSPROXY_CCMenuItem_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItem* ret_val;

	ret_val = [CCMenuItem itemWithBlock:(void (^)(id))arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSPROXY_CCMenuItem_rect(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGRect ret_val;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	ret_val = [real rect ];

	jsval ret_jsval = CGRect_to_jsval( cx, (CGRect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCMenuItem_selected(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real selected ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCMenuItem_setIsEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real setIsEnabled:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCMenuItem_unselected(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCMenuItem *real = (CCMenuItem*) [proxy realObj];
	[real unselected ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItem* (o)
JSBool JSPROXY_CCMenuItem_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItem* ret_val;

	ret_val = [CCMenuItem node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMenuItem_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMenuItem_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMenuItem_class->name = name;
	JSPROXY_CCMenuItem_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMenuItem_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMenuItem_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMenuItem_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMenuItem_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMenuItem_class->resolve = JS_ResolveStub;
	JSPROXY_CCMenuItem_class->convert = JS_ConvertStub;
	JSPROXY_CCMenuItem_class->finalize = JSPROXY_CCMenuItem_finalize;
//	JSPROXY_CCMenuItem_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("activate", JSPROXY_CCMenuItem_activate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("cleanup", JSPROXY_CCMenuItem_cleanup, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithBlock", JSPROXY_CCMenuItem_initWithBlock_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("isEnabled", JSPROXY_CCMenuItem_isEnabled, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getIsSelected", JSPROXY_CCMenuItem_isSelected, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("rect", JSPROXY_CCMenuItem_rect, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("selected", JSPROXY_CCMenuItem_selected, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setCallback", JSPROXY_CCMenuItem_setBlock_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setIsEnabled", JSPROXY_CCMenuItem_setIsEnabled_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("unselected", JSPROXY_CCMenuItem_unselected, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("itemWithBlock", JSPROXY_CCMenuItem_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCMenuItem_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMenuItem_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCMenuItem_class, JSPROXY_CCMenuItem_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMenuItem

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMenuItem_class, JSPROXY_CCMenuItem_object, NULL);
	JSPROXY_CCMenuItem *proxy = [[JSPROXY_CCMenuItem alloc] initWithJSObject:jsobj class:[CCMenuItem class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemLabel
 */
#pragma mark - CCMenuItemLabel

JSClass* JSPROXY_CCMenuItemLabel_class = NULL;
JSObject* JSPROXY_CCMenuItemLabel_object = NULL;
 // Constructor
JSBool JSPROXY_CCMenuItemLabel_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMenuItemLabel createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMenuItemLabel_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMenuItemLabel)", obj);
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCMenuItemLabel_disabledColor(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	ret_val = [real disabledColor ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: CCNode*, void (^)(id)
// Ret value: None (None)
JSBool JSPROXY_CCMenuItemLabel_initWithLabel_block_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; js_block arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = [(CCMenuItemLabel*)[proxy.klass alloc] initWithLabel:(CCNode*)arg0 block:(void (^)(id))arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSPROXY_CCMenuItemLabel_label(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	ret_val = [real label ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemLabel_setDisabledColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setDisabledColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemLabel_setIsEnabled_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setIsEnabled:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemLabel_setLabel_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setLabel:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemLabel_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setString:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCMenuItemLabel_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCMenuItemLabel_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCMenuItemLabel_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemLabel_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemLabel_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemLabel_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemLabel *real = (CCMenuItemLabel*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItemLabel* (o)
JSBool JSPROXY_CCMenuItemLabel_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemLabel* ret_val;

	ret_val = [CCMenuItemLabel itemWithBlock:(void (^)(id))arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItemLabel* (o)
JSBool JSPROXY_CCMenuItemLabel_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItemLabel* ret_val;

	ret_val = [CCMenuItemLabel node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMenuItemLabel_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMenuItemLabel_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMenuItemLabel_class->name = name;
	JSPROXY_CCMenuItemLabel_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemLabel_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemLabel_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemLabel_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMenuItemLabel_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMenuItemLabel_class->resolve = JS_ResolveStub;
	JSPROXY_CCMenuItemLabel_class->convert = JS_ConvertStub;
	JSPROXY_CCMenuItemLabel_class->finalize = JSPROXY_CCMenuItemLabel_finalize;
//	JSPROXY_CCMenuItemLabel_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDisabledColor", JSPROXY_CCMenuItemLabel_disabledColor, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithLabelBlock", JSPROXY_CCMenuItemLabel_initWithLabel_block_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLabel", JSPROXY_CCMenuItemLabel_label, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDisabledColor", JSPROXY_CCMenuItemLabel_setDisabledColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setIsEnabled", JSPROXY_CCMenuItemLabel_setIsEnabled_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLabel", JSPROXY_CCMenuItemLabel_setLabel_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setString", JSPROXY_CCMenuItemLabel_setString_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("color", JSPROXY_CCMenuItemLabel_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCMenuItemLabel_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("opacity", JSPROXY_CCMenuItemLabel_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCMenuItemLabel_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCMenuItemLabel_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCMenuItemLabel_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCMenuItemLabel_itemWithLabel_block__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithBlock", JSPROXY_CCMenuItemLabel_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCMenuItemLabel_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMenuItemLabel_object = JS_InitClass(cx, globalObj, JSPROXY_CCMenuItem_object, JSPROXY_CCMenuItemLabel_class, JSPROXY_CCMenuItemLabel_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMenuItemLabel

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMenuItemLabel_class, JSPROXY_CCMenuItemLabel_object, NULL);
	JSPROXY_CCMenuItemLabel *proxy = [[JSPROXY_CCMenuItemLabel alloc] initWithJSObject:jsobj class:[CCMenuItemLabel class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemAtlasFont
 */
#pragma mark - CCMenuItemAtlasFont

JSClass* JSPROXY_CCMenuItemAtlasFont_class = NULL;
JSObject* JSPROXY_CCMenuItemAtlasFont_object = NULL;
 // Constructor
JSBool JSPROXY_CCMenuItemAtlasFont_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMenuItemAtlasFont createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMenuItemAtlasFont_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMenuItemAtlasFont)", obj);
}

// Arguments: NSString*, NSString*, int, int, char, void (^)(id)
// Ret value: None (None)
JSBool JSPROXY_CCMenuItemAtlasFont_initWithString_charMapFile_itemWidth_itemHeight_startCharMap_block_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; int32_t arg2; int32_t arg3; uint16_t arg4; js_block arg5; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg4 );
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg5 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemAtlasFont *real = [(CCMenuItemAtlasFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 charMapFile:(NSString*)arg1 itemWidth:(int)arg2 itemHeight:(int)arg3 startCharMap:(char)arg4 block:(void (^)(id))arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, int, int, char
// Ret value: CCMenuItemAtlasFont* (o)
JSBool JSPROXY_CCMenuItemAtlasFont_itemWithString_charMapFile_itemWidth_itemHeight_startCharMap__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; int32_t arg2; int32_t arg3; uint16_t arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemAtlasFont* ret_val;

	ret_val = [CCMenuItemAtlasFont itemWithString:(NSString*)arg0 charMapFile:(NSString*)arg1 itemWidth:(int)arg2 itemHeight:(int)arg3 startCharMap:(char)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, int, int, char, void (^)(id)
// Ret value: CCMenuItemAtlasFont* (o)
JSBool JSPROXY_CCMenuItemAtlasFont_itemWithString_charMapFile_itemWidth_itemHeight_startCharMap_block__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; int32_t arg2; int32_t arg3; uint16_t arg4; js_block arg5; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg4 );
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg5 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemAtlasFont* ret_val;

	ret_val = [CCMenuItemAtlasFont itemWithString:(NSString*)arg0 charMapFile:(NSString*)arg1 itemWidth:(int)arg2 itemHeight:(int)arg3 startCharMap:(char)arg4 block:(void (^)(id))arg5  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: CCMenuItemAtlasFont* (o)
JSBool JSPROXY_CCMenuItemAtlasFont_itemWithLabel__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCMenuItemAtlasFont* ret_val;

	ret_val = [CCMenuItemAtlasFont itemWithLabel:(CCNode*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*, void (^)(id)
// Ret value: CCMenuItemAtlasFont* (o)
JSBool JSPROXY_CCMenuItemAtlasFont_itemWithLabel_block__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; js_block arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemAtlasFont* ret_val;

	ret_val = [CCMenuItemAtlasFont itemWithLabel:(CCNode*)arg0 block:(void (^)(id))arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItemAtlasFont* (o)
JSBool JSPROXY_CCMenuItemAtlasFont_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemAtlasFont* ret_val;

	ret_val = [CCMenuItemAtlasFont itemWithBlock:(void (^)(id))arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItemAtlasFont* (o)
JSBool JSPROXY_CCMenuItemAtlasFont_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItemAtlasFont* ret_val;

	ret_val = [CCMenuItemAtlasFont node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMenuItemAtlasFont_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMenuItemAtlasFont_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMenuItemAtlasFont_class->name = name;
	JSPROXY_CCMenuItemAtlasFont_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemAtlasFont_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemAtlasFont_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemAtlasFont_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMenuItemAtlasFont_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMenuItemAtlasFont_class->resolve = JS_ResolveStub;
	JSPROXY_CCMenuItemAtlasFont_class->convert = JS_ConvertStub;
	JSPROXY_CCMenuItemAtlasFont_class->finalize = JSPROXY_CCMenuItemAtlasFont_finalize;
//	JSPROXY_CCMenuItemAtlasFont_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithStringCharMapFileItemWidthItemHeightStartCharMapBlock", JSPROXY_CCMenuItemAtlasFont_initWithString_charMapFile_itemWidth_itemHeight_startCharMap_block_, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("itemWithStringCharMapFileItemWidthItemHeightStartCharMap", JSPROXY_CCMenuItemAtlasFont_itemWithString_charMapFile_itemWidth_itemHeight_startCharMap__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithStringCharMapFileItemWidthItemHeightStartCharMapBlock", JSPROXY_CCMenuItemAtlasFont_itemWithString_charMapFile_itemWidth_itemHeight_startCharMap_block__static, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithLabel", JSPROXY_CCMenuItemAtlasFont_itemWithLabel__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithLabelBlock", JSPROXY_CCMenuItemAtlasFont_itemWithLabel_block__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithBlock", JSPROXY_CCMenuItemAtlasFont_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCMenuItemAtlasFont_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMenuItemAtlasFont_object = JS_InitClass(cx, globalObj, JSPROXY_CCMenuItemLabel_object, JSPROXY_CCMenuItemAtlasFont_class, JSPROXY_CCMenuItemAtlasFont_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMenuItemAtlasFont

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMenuItemAtlasFont_class, JSPROXY_CCMenuItemAtlasFont_object, NULL);
	JSPROXY_CCMenuItemAtlasFont *proxy = [[JSPROXY_CCMenuItemAtlasFont alloc] initWithJSObject:jsobj class:[CCMenuItemAtlasFont class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAction
 */
#pragma mark - CCAction

JSClass* JSPROXY_CCAction_class = NULL;
JSObject* JSPROXY_CCAction_object = NULL;
 // Constructor
JSBool JSPROXY_CCAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAction createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAction_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAction)", obj);
}

// Arguments: 
// Ret value: CCAction* (o)
JSBool JSPROXY_CCAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCAction* ret_val;

	ret_val = [CCAction action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCAction_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCAction *real = [(CCAction*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCAction_isDone(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCAction *real = (CCAction*) [proxy realObj];
	ret_val = [real isDone ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCAction_setTag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAction *real = (CCAction*) [proxy realObj];
	[real setTag:(NSInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCAction_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCAction *real = (CCAction*) [proxy realObj];
	[real startWithTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCAction_step_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAction *real = (CCAction*) [proxy realObj];
	[real step:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCAction_stop(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCAction *real = (CCAction*) [proxy realObj];
	[real stop ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSInteger (i)
JSBool JSPROXY_CCAction_tag(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSInteger ret_val;

	CCAction *real = (CCAction*) [proxy realObj];
	ret_val = [real tag ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCAction_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAction *real = (CCAction*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAction_class->name = name;
	JSPROXY_CCAction_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAction_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAction_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAction_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAction_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAction_class->resolve = JS_ResolveStub;
	JSPROXY_CCAction_class->convert = JS_ConvertStub;
	JSPROXY_CCAction_class->finalize = JSPROXY_CCAction_finalize;
//	JSPROXY_CCAction_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCAction_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("isDone", JSPROXY_CCAction_isDone, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTag", JSPROXY_CCAction_setTag_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("startWithTarget", JSPROXY_CCAction_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("step", JSPROXY_CCAction_step_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("stop", JSPROXY_CCAction_stop, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTag", JSPROXY_CCAction_tag, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("update", JSPROXY_CCAction_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSPROXY_CCAction_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCAction_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCAction_class, JSPROXY_CCAction_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAction_class, JSPROXY_CCAction_object, NULL);
	JSPROXY_CCAction *proxy = [[JSPROXY_CCAction alloc] initWithJSObject:jsobj class:[CCAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFiniteTimeAction
 */
#pragma mark - CCFiniteTimeAction

JSClass* JSPROXY_CCFiniteTimeAction_class = NULL;
JSObject* JSPROXY_CCFiniteTimeAction_object = NULL;
 // Constructor
JSBool JSPROXY_CCFiniteTimeAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFiniteTimeAction createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFiniteTimeAction_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFiniteTimeAction)", obj);
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSPROXY_CCFiniteTimeAction_duration(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccTime ret_val;

	CCFiniteTimeAction *real = (CCFiniteTimeAction*) [proxy realObj];
	ret_val = [real duration ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFiniteTimeAction* (o)
JSBool JSPROXY_CCFiniteTimeAction_reverse(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFiniteTimeAction* ret_val;

	CCFiniteTimeAction *real = (CCFiniteTimeAction*) [proxy realObj];
	ret_val = [real reverse ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCFiniteTimeAction_setDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFiniteTimeAction *real = (CCFiniteTimeAction*) [proxy realObj];
	[real setDuration:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFiniteTimeAction* (o)
JSBool JSPROXY_CCFiniteTimeAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFiniteTimeAction* ret_val;

	ret_val = [CCFiniteTimeAction action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFiniteTimeAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFiniteTimeAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFiniteTimeAction_class->name = name;
	JSPROXY_CCFiniteTimeAction_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFiniteTimeAction_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFiniteTimeAction_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFiniteTimeAction_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFiniteTimeAction_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFiniteTimeAction_class->resolve = JS_ResolveStub;
	JSPROXY_CCFiniteTimeAction_class->convert = JS_ConvertStub;
	JSPROXY_CCFiniteTimeAction_class->finalize = JSPROXY_CCFiniteTimeAction_finalize;
//	JSPROXY_CCFiniteTimeAction_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDuration", JSPROXY_CCFiniteTimeAction_duration, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reverse", JSPROXY_CCFiniteTimeAction_reverse, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDuration", JSPROXY_CCFiniteTimeAction_setDuration_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSPROXY_CCFiniteTimeAction_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFiniteTimeAction_object = JS_InitClass(cx, globalObj, JSPROXY_CCAction_object, JSPROXY_CCFiniteTimeAction_class, JSPROXY_CCFiniteTimeAction_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFiniteTimeAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFiniteTimeAction_class, JSPROXY_CCFiniteTimeAction_object, NULL);
	JSPROXY_CCFiniteTimeAction *proxy = [[JSPROXY_CCFiniteTimeAction alloc] initWithJSObject:jsobj class:[CCFiniteTimeAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionInterval
 */
#pragma mark - CCActionInterval

JSClass* JSPROXY_CCActionInterval_class = NULL;
JSObject* JSPROXY_CCActionInterval_object = NULL;
 // Constructor
JSBool JSPROXY_CCActionInterval_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCActionInterval createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCActionInterval_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCActionInterval)", obj);
}

// Arguments: ccTime
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCActionInterval_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	ret_val = [CCActionInterval actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSPROXY_CCActionInterval_elapsed(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccTime ret_val;

	CCActionInterval *real = (CCActionInterval*) [proxy realObj];
	ret_val = [real elapsed ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: None (None)
JSBool JSPROXY_CCActionInterval_initWithDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCActionInterval *real = [(CCActionInterval*)[proxy.klass alloc] initWithDuration:(ccTime)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCActionInterval_isDone(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCActionInterval *real = (CCActionInterval*) [proxy realObj];
	ret_val = [real isDone ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCActionInterval_reverse(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCActionInterval *real = (CCActionInterval*) [proxy realObj];
	ret_val = [real reverse ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCActionInterval_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	ret_val = [CCActionInterval action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCActionInterval_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCActionInterval_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCActionInterval_class->name = name;
	JSPROXY_CCActionInterval_class->addProperty = JS_PropertyStub;
	JSPROXY_CCActionInterval_class->delProperty = JS_PropertyStub;
	JSPROXY_CCActionInterval_class->getProperty = JS_PropertyStub;
	JSPROXY_CCActionInterval_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCActionInterval_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCActionInterval_class->resolve = JS_ResolveStub;
	JSPROXY_CCActionInterval_class->convert = JS_ConvertStub;
	JSPROXY_CCActionInterval_class->finalize = JSPROXY_CCActionInterval_finalize;
//	JSPROXY_CCActionInterval_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getElapsed", JSPROXY_CCActionInterval_elapsed, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithDuration", JSPROXY_CCActionInterval_initWithDuration_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("isDone", JSPROXY_CCActionInterval_isDone, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reverse", JSPROXY_CCActionInterval_reverse, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDuration", JSPROXY_CCActionInterval_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCActionInterval_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCActionInterval_object = JS_InitClass(cx, globalObj, JSPROXY_CCFiniteTimeAction_object, JSPROXY_CCActionInterval_class, JSPROXY_CCActionInterval_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCActionInterval

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCActionInterval_class, JSPROXY_CCActionInterval_object, NULL);
	JSPROXY_CCActionInterval *proxy = [[JSPROXY_CCActionInterval alloc] initWithJSObject:jsobj class:[CCActionInterval class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProgressFromTo
 */
#pragma mark - CCProgressFromTo

JSClass* JSPROXY_CCProgressFromTo_class = NULL;
JSObject* JSPROXY_CCProgressFromTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCProgressFromTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCProgressFromTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCProgressFromTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCProgressFromTo)", obj);
}

// Arguments: ccTime, float, float
// Ret value: CCProgressFromTo* (o)
JSBool JSPROXY_CCProgressFromTo_actionWithDuration_from_to__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCProgressFromTo* ret_val;

	ret_val = [CCProgressFromTo actionWithDuration:(ccTime)arg0 from:(float)arg1 to:(float)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSPROXY_CCProgressFromTo_initWithDuration_from_to_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCProgressFromTo *real = [(CCProgressFromTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 from:(float)arg1 to:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCProgressFromTo* (o)
JSBool JSPROXY_CCProgressFromTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCProgressFromTo* ret_val;

	ret_val = [CCProgressFromTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCProgressFromTo* (o)
JSBool JSPROXY_CCProgressFromTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCProgressFromTo* ret_val;

	ret_val = [CCProgressFromTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCProgressFromTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCProgressFromTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCProgressFromTo_class->name = name;
	JSPROXY_CCProgressFromTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCProgressFromTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCProgressFromTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCProgressFromTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCProgressFromTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCProgressFromTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCProgressFromTo_class->convert = JS_ConvertStub;
	JSPROXY_CCProgressFromTo_class->finalize = JSPROXY_CCProgressFromTo_finalize;
//	JSPROXY_CCProgressFromTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationFromTo", JSPROXY_CCProgressFromTo_initWithDuration_from_to_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCProgressFromTo_actionWithDuration_from_to__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCProgressFromTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCProgressFromTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCProgressFromTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCProgressFromTo_class, JSPROXY_CCProgressFromTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCProgressFromTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCProgressFromTo_class, JSPROXY_CCProgressFromTo_object, NULL);
	JSPROXY_CCProgressFromTo *proxy = [[JSPROXY_CCProgressFromTo alloc] initWithJSObject:jsobj class:[CCProgressFromTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXObjectGroup
 */
#pragma mark - CCTMXObjectGroup

JSClass* JSPROXY_CCTMXObjectGroup_class = NULL;
JSObject* JSPROXY_CCTMXObjectGroup_object = NULL;
 // Constructor
JSBool JSPROXY_CCTMXObjectGroup_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTMXObjectGroup createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTMXObjectGroup_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTMXObjectGroup)", obj);
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTMXObjectGroup_groupName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real groupName ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCTMXObjectGroup_objects(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real objects ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCTMXObjectGroup_positionOffset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	ret_val = [real positionOffset ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTMXObjectGroup_setGroupName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	[real setGroupName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCTMXObjectGroup_setObjects_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	[real setObjects:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCTMXObjectGroup_setPositionOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXObjectGroup *real = (CCTMXObjectGroup*) [proxy realObj];
	[real setPositionOffset:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCTMXObjectGroup_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTMXObjectGroup_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTMXObjectGroup_class->name = name;
	JSPROXY_CCTMXObjectGroup_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTMXObjectGroup_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTMXObjectGroup_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTMXObjectGroup_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTMXObjectGroup_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTMXObjectGroup_class->resolve = JS_ResolveStub;
	JSPROXY_CCTMXObjectGroup_class->convert = JS_ConvertStub;
	JSPROXY_CCTMXObjectGroup_class->finalize = JSPROXY_CCTMXObjectGroup_finalize;
//	JSPROXY_CCTMXObjectGroup_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getGroupName", JSPROXY_CCTMXObjectGroup_groupName, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getObjects", JSPROXY_CCTMXObjectGroup_objects, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPositionOffset", JSPROXY_CCTMXObjectGroup_positionOffset, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setGroupName", JSPROXY_CCTMXObjectGroup_setGroupName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setObjects", JSPROXY_CCTMXObjectGroup_setObjects_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPositionOffset", JSPROXY_CCTMXObjectGroup_setPositionOffset_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCTMXObjectGroup_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTMXObjectGroup_class, JSPROXY_CCTMXObjectGroup_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTMXObjectGroup

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTMXObjectGroup_class, JSPROXY_CCTMXObjectGroup_object, NULL);
	JSPROXY_CCTMXObjectGroup *proxy = [[JSPROXY_CCTMXObjectGroup alloc] initWithJSObject:jsobj class:[CCTMXObjectGroup class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMoveTo
 */
#pragma mark - CCMoveTo

JSClass* JSPROXY_CCMoveTo_class = NULL;
JSObject* JSPROXY_CCMoveTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCMoveTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMoveTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMoveTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMoveTo)", obj);
}

// Arguments: ccTime, CGPoint
// Ret value: CCMoveTo* (o)
JSBool JSPROXY_CCMoveTo_actionWithDuration_position__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	if( ! ok ) return JS_FALSE;
	CCMoveTo* ret_val;

	ret_val = [CCMoveTo actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint
// Ret value: None (None)
JSBool JSPROXY_CCMoveTo_initWithDuration_position_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCMoveTo *real = [(CCMoveTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCMoveTo* (o)
JSBool JSPROXY_CCMoveTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMoveTo* ret_val;

	ret_val = [CCMoveTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMoveTo* (o)
JSBool JSPROXY_CCMoveTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMoveTo* ret_val;

	ret_val = [CCMoveTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMoveTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMoveTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMoveTo_class->name = name;
	JSPROXY_CCMoveTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMoveTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMoveTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMoveTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMoveTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMoveTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCMoveTo_class->convert = JS_ConvertStub;
	JSPROXY_CCMoveTo_class->finalize = JSPROXY_CCMoveTo_finalize;
//	JSPROXY_CCMoveTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPosition", JSPROXY_CCMoveTo_initWithDuration_position_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCMoveTo_actionWithDuration_position__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCMoveTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCMoveTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMoveTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCMoveTo_class, JSPROXY_CCMoveTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMoveTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMoveTo_class, JSPROXY_CCMoveTo_object, NULL);
	JSPROXY_CCMoveTo *proxy = [[JSPROXY_CCMoveTo alloc] initWithJSObject:jsobj class:[CCMoveTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMoveBy
 */
#pragma mark - CCMoveBy

JSClass* JSPROXY_CCMoveBy_class = NULL;
JSObject* JSPROXY_CCMoveBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCMoveBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMoveBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMoveBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMoveBy)", obj);
}

// Arguments: ccTime, CGPoint
// Ret value: CCMoveBy* (o)
JSBool JSPROXY_CCMoveBy_actionWithDuration_position__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	if( ! ok ) return JS_FALSE;
	CCMoveBy* ret_val;

	ret_val = [CCMoveBy actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint
// Ret value: None (None)
JSBool JSPROXY_CCMoveBy_initWithDuration_position_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCMoveBy *real = [(CCMoveBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 position:(CGPoint)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCMoveBy* (o)
JSBool JSPROXY_CCMoveBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMoveBy* ret_val;

	ret_val = [CCMoveBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMoveBy* (o)
JSBool JSPROXY_CCMoveBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMoveBy* ret_val;

	ret_val = [CCMoveBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMoveBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMoveBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMoveBy_class->name = name;
	JSPROXY_CCMoveBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMoveBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMoveBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMoveBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMoveBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMoveBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCMoveBy_class->convert = JS_ConvertStub;
	JSPROXY_CCMoveBy_class->finalize = JSPROXY_CCMoveBy_finalize;
//	JSPROXY_CCMoveBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPosition", JSPROXY_CCMoveBy_initWithDuration_position_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCMoveBy_actionWithDuration_position__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCMoveBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCMoveBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMoveBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCMoveTo_object, JSPROXY_CCMoveBy_class, JSPROXY_CCMoveBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMoveBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMoveBy_class, JSPROXY_CCMoveBy_object, NULL);
	JSPROXY_CCMoveBy *proxy = [[JSPROXY_CCMoveBy alloc] initWithJSObject:jsobj class:[CCMoveBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCamera
 */
#pragma mark - CCCamera

JSClass* JSPROXY_CCCamera_class = NULL;
JSObject* JSPROXY_CCCamera_object = NULL;
 // Constructor
JSBool JSPROXY_CCCamera_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCCamera createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCCamera_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCCamera)", obj);
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCCamera_dirty(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCCamera *real = (CCCamera*) [proxy realObj];
	ret_val = [real dirty ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCCamera_getZEye_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	ret_val = [CCCamera getZEye ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCCamera_locate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real locate ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCCamera_restore(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real restore ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float
// Ret value: void (None)
JSBool JSPROXY_CCCamera_setCenterX_centerY_centerZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setCenterX:(float)arg0 centerY:(float)arg1 centerZ:(float)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCCamera_setDirty_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setDirty:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float
// Ret value: void (None)
JSBool JSPROXY_CCCamera_setEyeX_eyeY_eyeZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setEyeX:(float)arg0 eyeY:(float)arg1 eyeZ:(float)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float
// Ret value: void (None)
JSBool JSPROXY_CCCamera_setUpX_upY_upZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCCamera *real = (CCCamera*) [proxy realObj];
	[real setUpX:(float)arg0 upY:(float)arg1 upZ:(float)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCCamera_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCCamera_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCCamera_class->name = name;
	JSPROXY_CCCamera_class->addProperty = JS_PropertyStub;
	JSPROXY_CCCamera_class->delProperty = JS_PropertyStub;
	JSPROXY_CCCamera_class->getProperty = JS_PropertyStub;
	JSPROXY_CCCamera_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCCamera_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCCamera_class->resolve = JS_ResolveStub;
	JSPROXY_CCCamera_class->convert = JS_ConvertStub;
	JSPROXY_CCCamera_class->finalize = JSPROXY_CCCamera_finalize;
//	JSPROXY_CCCamera_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDirty", JSPROXY_CCCamera_dirty, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("locate", JSPROXY_CCCamera_locate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("restore", JSPROXY_CCCamera_restore, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setCenterXCenterYCenterZ", JSPROXY_CCCamera_setCenterX_centerY_centerZ_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDirty", JSPROXY_CCCamera_setDirty_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEyeXEyeYEyeZ", JSPROXY_CCCamera_setEyeX_eyeY_eyeZ_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUpXUpYUpZ", JSPROXY_CCCamera_setUpX_upY_upZ_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("getZEye", JSPROXY_CCCamera_getZEye_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCCamera_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCCamera_class, JSPROXY_CCCamera_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCCamera

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCCamera_class, JSPROXY_CCCamera_object, NULL);
	JSPROXY_CCCamera *proxy = [[JSPROXY_CCCamera alloc] initWithJSObject:jsobj class:[CCCamera class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCReverseTime
 */
#pragma mark - CCReverseTime

JSClass* JSPROXY_CCReverseTime_class = NULL;
JSObject* JSPROXY_CCReverseTime_object = NULL;
 // Constructor
JSBool JSPROXY_CCReverseTime_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCReverseTime createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCReverseTime_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCReverseTime)", obj);
}

// Arguments: CCFiniteTimeAction*
// Ret value: CCReverseTime* (o)
JSBool JSPROXY_CCReverseTime_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCReverseTime* ret_val;

	ret_val = [CCReverseTime actionWithAction:(CCFiniteTimeAction*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSPROXY_CCReverseTime_initWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCReverseTime *real = [(CCReverseTime*)[proxy.klass alloc] initWithAction:(CCFiniteTimeAction*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCReverseTime* (o)
JSBool JSPROXY_CCReverseTime_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCReverseTime* ret_val;

	ret_val = [CCReverseTime actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCReverseTime* (o)
JSBool JSPROXY_CCReverseTime_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCReverseTime* ret_val;

	ret_val = [CCReverseTime action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCReverseTime_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCReverseTime_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCReverseTime_class->name = name;
	JSPROXY_CCReverseTime_class->addProperty = JS_PropertyStub;
	JSPROXY_CCReverseTime_class->delProperty = JS_PropertyStub;
	JSPROXY_CCReverseTime_class->getProperty = JS_PropertyStub;
	JSPROXY_CCReverseTime_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCReverseTime_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCReverseTime_class->resolve = JS_ResolveStub;
	JSPROXY_CCReverseTime_class->convert = JS_ConvertStub;
	JSPROXY_CCReverseTime_class->finalize = JSPROXY_CCReverseTime_finalize;
//	JSPROXY_CCReverseTime_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithAction", JSPROXY_CCReverseTime_initWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithAction", JSPROXY_CCReverseTime_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCReverseTime_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCReverseTime_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCReverseTime_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCReverseTime_class, JSPROXY_CCReverseTime_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCReverseTime

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCReverseTime_class, JSPROXY_CCReverseTime_object, NULL);
	JSPROXY_CCReverseTime *proxy = [[JSPROXY_CCReverseTime alloc] initWithJSObject:jsobj class:[CCReverseTime class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSprite
 */
#pragma mark - CCSprite

JSClass* JSPROXY_CCSprite_class = NULL;
JSObject* JSPROXY_CCSprite_object = NULL;
 // Constructor
JSBool JSPROXY_CCSprite_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSprite createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSprite_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSprite)", obj);
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCSprite_atlasIndex(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real atlasIndex ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteBatchNode* (o)
JSBool JSPROXY_CCSprite_batchNode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSpriteBatchNode* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real batchNode ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccBlendFunc ({_ccBlendFunc=II})
JSBool JSPROXY_CCSprite_blendFunc(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccBlendFunc ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real blendFunc ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT32, 2 );
	ccBlendFunc* buffer = (ccBlendFunc*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCSprite_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCSprite_dirty(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real dirty ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteFrame* (o)
JSBool JSPROXY_CCSprite_displayFrame(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSpriteFrame* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real displayFrame ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCSprite_flipX(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real flipX ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCSprite_flipY(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real flipY ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCSprite_initWithFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: None (None)
JSBool JSPROXY_CCSprite_initWithFile_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithFile:(NSString*)arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: None (None)
JSBool JSPROXY_CCSprite_initWithSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithSpriteFrame:(CCSpriteFrame*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCSprite_initWithSpriteFrameName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithSpriteFrameName:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: None (None)
JSBool JSPROXY_CCSprite_initWithTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: None (None)
JSBool JSPROXY_CCSprite_initWithTexture_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect, BOOL
// Ret value: None (None)
JSBool JSPROXY_CCSprite_initWithTexture_rect_rotated_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; JSBool arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = [(CCSprite*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0 rect:(CGRect)arg1 rotated:(BOOL)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: BOOL (b)
JSBool JSPROXY_CCSprite_isFrameDisplayed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real isFrameDisplayed:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCSprite_offsetPosition(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real offsetPosition ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCSprite_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setAtlasIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setAtlasIndex:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteBatchNode*
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setBatchNode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setBatchNode:(CCSpriteBatchNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccBlendFunc
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setBlendFunc_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccBlendFunc arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccBlendFunc*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setBlendFunc:(ccBlendFunc)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setDirty_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setDirty:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setDisplayFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setDisplayFrame:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, int
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setDisplayFrameWithAnimationName_index_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; int32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setDisplayFrameWithAnimationName:(NSString*)arg0 index:(int)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setFlipX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setFlipX:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setFlipY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setFlipY:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTextureAtlas:(CCTextureAtlas*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setTextureRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTextureRect:(CGRect)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGRect, BOOL, CGSize
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setTextureRect_rotated_untrimmedSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; JSBool arg1; CGSize arg2; 

	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg2 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTextureRect:(CGRect)arg0 rotated:(BOOL)arg1 untrimmedSize:(CGSize)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setVertexRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setVertexRect:(CGRect)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: CCSprite* (o)
JSBool JSPROXY_CCSprite_spriteWithFile_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCSprite* ret_val;

	if( argc == 1 ) {
		ret_val = [CCSprite spriteWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCSprite spriteWithFile:(NSString*)arg0 rect:(CGRect)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: CCSprite* (o)
JSBool JSPROXY_CCSprite_spriteWithSpriteFrame__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCSprite* ret_val;

	ret_val = [CCSprite spriteWithSpriteFrame:(CCSpriteFrame*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCSprite* (o)
JSBool JSPROXY_CCSprite_spriteWithSpriteFrameName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSprite* ret_val;

	ret_val = [CCSprite spriteWithSpriteFrameName:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSPROXY_CCSprite_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSPROXY_CCSprite_textureRect(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGRect ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real textureRect ];

	jsval ret_jsval = CGRect_to_jsval( cx, (CGRect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCSprite_textureRectRotated(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real textureRectRotated ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCSprite_updateTransform(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real updateTransform ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCSprite_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCSprite_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSprite *real = (CCSprite*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCSprite_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCSprite *real = (CCSprite*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSprite* (o)
JSBool JSPROXY_CCSprite_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSprite* ret_val;

	ret_val = [CCSprite node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSprite_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSprite_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSprite_class->name = name;
	JSPROXY_CCSprite_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSprite_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSprite_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSprite_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSprite_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSprite_class->resolve = JS_ResolveStub;
	JSPROXY_CCSprite_class->convert = JS_ConvertStub;
	JSPROXY_CCSprite_class->finalize = JSPROXY_CCSprite_finalize;
//	JSPROXY_CCSprite_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAtlasIndex", JSPROXY_CCSprite_atlasIndex, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getBatchNode", JSPROXY_CCSprite_batchNode, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getBlendFunc", JSPROXY_CCSprite_blendFunc, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getColor", JSPROXY_CCSprite_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getDirty", JSPROXY_CCSprite_dirty, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("displayFrame", JSPROXY_CCSprite_displayFrame, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getFlipX", JSPROXY_CCSprite_flipX, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getFlipY", JSPROXY_CCSprite_flipY, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFile", JSPROXY_CCSprite_initWithFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFileRect", JSPROXY_CCSprite_initWithFile_rect_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFrame", JSPROXY_CCSprite_initWithSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFrameName", JSPROXY_CCSprite_initWithSpriteFrameName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTexture", JSPROXY_CCSprite_initWithTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureRect", JSPROXY_CCSprite_initWithTexture_rect_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureRectRotated", JSPROXY_CCSprite_initWithTexture_rect_rotated_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("isFrameDisplayed", JSPROXY_CCSprite_isFrameDisplayed_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOffsetPosition", JSPROXY_CCSprite_offsetPosition, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSPROXY_CCSprite_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAtlasIndex", JSPROXY_CCSprite_setAtlasIndex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBatchNode", JSPROXY_CCSprite_setBatchNode_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSPROXY_CCSprite_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCSprite_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDirty", JSPROXY_CCSprite_setDirty_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDisplayFrame", JSPROXY_CCSprite_setDisplayFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDisplayFrameWithAnimationNameIndex", JSPROXY_CCSprite_setDisplayFrameWithAnimationName_index_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFlipX", JSPROXY_CCSprite_setFlipX_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFlipY", JSPROXY_CCSprite_setFlipY_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCSprite_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSPROXY_CCSprite_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTextureRect", JSPROXY_CCSprite_setTextureRect_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTextureRectRotatedUntrimmedSize", JSPROXY_CCSprite_setTextureRect_rotated_untrimmedSize_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setVertexRect", JSPROXY_CCSprite_setVertexRect_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSPROXY_CCSprite_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTextureRect", JSPROXY_CCSprite_textureRect, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTextureRectRotated", JSPROXY_CCSprite_textureRectRotated, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("updateTransform", JSPROXY_CCSprite_updateTransform, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCSprite_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCSprite_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCSprite_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCSprite_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCSprite_spriteWithFile_rect__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrame", JSPROXY_CCSprite_spriteWithSpriteFrame__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrameName", JSPROXY_CCSprite_spriteWithSpriteFrameName__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCSprite_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSprite_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCSprite_class, JSPROXY_CCSprite_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSprite

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSprite_class, JSPROXY_CCSprite_object, NULL);
	JSPROXY_CCSprite *proxy = [[JSPROXY_CCSprite alloc] initWithJSObject:jsobj class:[CCSprite class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * ChipmunkSprite
 */
#pragma mark - ChipmunkSprite

JSClass* JSPROXY_ChipmunkSprite_class = NULL;
JSObject* JSPROXY_ChipmunkSprite_object = NULL;
 // Constructor
JSBool JSPROXY_ChipmunkSprite_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_ChipmunkSprite createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_ChipmunkSprite_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (ChipmunkSprite)", obj);
}

// Arguments: 
// Ret value: cpBody* (N/A)
JSBool JSPROXY_ChipmunkSprite_body(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	cpBody* ret_val;

	ChipmunkSprite *real = (ChipmunkSprite*) [proxy realObj];
	ret_val = [real body ];

	jsval ret_jsval = opaque_to_jsval( cx, ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_ChipmunkSprite_ignoreBodyRotation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	ChipmunkSprite *real = (ChipmunkSprite*) [proxy realObj];
	ret_val = [real ignoreBodyRotation ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: void (None)
JSBool JSPROXY_ChipmunkSprite_setBody_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, *argvp++, (void**)&arg0 );
	if( ! ok ) return JS_FALSE;

	ChipmunkSprite *real = (ChipmunkSprite*) [proxy realObj];
	[real setBody:(cpBody*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_ChipmunkSprite_setIgnoreBodyRotation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	ChipmunkSprite *real = (ChipmunkSprite*) [proxy realObj];
	[real setIgnoreBodyRotation:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: ChipmunkSprite* (o)
JSBool JSPROXY_ChipmunkSprite_spriteWithFile_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	ChipmunkSprite* ret_val;

	if( argc == 1 ) {
		ret_val = [ChipmunkSprite spriteWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [ChipmunkSprite spriteWithFile:(NSString*)arg0 rect:(CGRect)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: ChipmunkSprite* (o)
JSBool JSPROXY_ChipmunkSprite_spriteWithSpriteFrame__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	ChipmunkSprite* ret_val;

	ret_val = [ChipmunkSprite spriteWithSpriteFrame:(CCSpriteFrame*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: ChipmunkSprite* (o)
JSBool JSPROXY_ChipmunkSprite_spriteWithSpriteFrameName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	ChipmunkSprite* ret_val;

	ret_val = [ChipmunkSprite spriteWithSpriteFrameName:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ChipmunkSprite* (o)
JSBool JSPROXY_ChipmunkSprite_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ChipmunkSprite* ret_val;

	ret_val = [ChipmunkSprite node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_ChipmunkSprite_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_ChipmunkSprite_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_ChipmunkSprite_class->name = name;
	JSPROXY_ChipmunkSprite_class->addProperty = JS_PropertyStub;
	JSPROXY_ChipmunkSprite_class->delProperty = JS_PropertyStub;
	JSPROXY_ChipmunkSprite_class->getProperty = JS_PropertyStub;
	JSPROXY_ChipmunkSprite_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_ChipmunkSprite_class->enumerate = JS_EnumerateStub;
	JSPROXY_ChipmunkSprite_class->resolve = JS_ResolveStub;
	JSPROXY_ChipmunkSprite_class->convert = JS_ConvertStub;
	JSPROXY_ChipmunkSprite_class->finalize = JSPROXY_ChipmunkSprite_finalize;
//	JSPROXY_ChipmunkSprite_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBody", JSPROXY_ChipmunkSprite_body, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getIgnoreBodyRotation", JSPROXY_ChipmunkSprite_ignoreBodyRotation, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBody", JSPROXY_ChipmunkSprite_setBody_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setIgnoreBodyRotation", JSPROXY_ChipmunkSprite_setIgnoreBodyRotation_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_ChipmunkSprite_spriteWithFile_rect__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrame", JSPROXY_ChipmunkSprite_spriteWithSpriteFrame__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("createWithSpriteFrameName", JSPROXY_ChipmunkSprite_spriteWithSpriteFrameName__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_ChipmunkSprite_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_ChipmunkSprite_object = JS_InitClass(cx, globalObj, JSPROXY_CCSprite_object, JSPROXY_ChipmunkSprite_class, JSPROXY_ChipmunkSprite_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_ChipmunkSprite

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_ChipmunkSprite_class, JSPROXY_ChipmunkSprite_object, NULL);
	JSPROXY_ChipmunkSprite *proxy = [[JSPROXY_ChipmunkSprite alloc] initWithJSObject:jsobj class:[ChipmunkSprite class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionEase
 */
#pragma mark - CCActionEase

JSClass* JSPROXY_CCActionEase_class = NULL;
JSObject* JSPROXY_CCActionEase_object = NULL;
 // Constructor
JSBool JSPROXY_CCActionEase_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCActionEase createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCActionEase_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCActionEase)", obj);
}

// Arguments: CCActionInterval*
// Ret value: CCActionEase* (o)
JSBool JSPROXY_CCActionEase_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCActionEase* ret_val;

	ret_val = [CCActionEase actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: None (None)
JSBool JSPROXY_CCActionEase_initWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCActionEase *real = [(CCActionEase*)[proxy.klass alloc] initWithAction:(CCActionInterval*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCActionEase* (o)
JSBool JSPROXY_CCActionEase_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionEase* ret_val;

	ret_val = [CCActionEase actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionEase* (o)
JSBool JSPROXY_CCActionEase_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionEase* ret_val;

	ret_val = [CCActionEase action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCActionEase_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCActionEase_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCActionEase_class->name = name;
	JSPROXY_CCActionEase_class->addProperty = JS_PropertyStub;
	JSPROXY_CCActionEase_class->delProperty = JS_PropertyStub;
	JSPROXY_CCActionEase_class->getProperty = JS_PropertyStub;
	JSPROXY_CCActionEase_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCActionEase_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCActionEase_class->resolve = JS_ResolveStub;
	JSPROXY_CCActionEase_class->convert = JS_ConvertStub;
	JSPROXY_CCActionEase_class->finalize = JSPROXY_CCActionEase_finalize;
//	JSPROXY_CCActionEase_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithAction", JSPROXY_CCActionEase_initWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithAction", JSPROXY_CCActionEase_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCActionEase_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCActionEase_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCActionEase_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCActionEase_class, JSPROXY_CCActionEase_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCActionEase

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCActionEase_class, JSPROXY_CCActionEase_object, NULL);
	JSPROXY_CCActionEase *proxy = [[JSPROXY_CCActionEase alloc] initWithJSObject:jsobj class:[CCActionEase class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElastic
 */
#pragma mark - CCEaseElastic

JSClass* JSPROXY_CCEaseElastic_class = NULL;
JSObject* JSPROXY_CCEaseElastic_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseElastic_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseElastic createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseElastic_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseElastic)", obj);
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElastic* (o)
JSBool JSPROXY_CCEaseElastic_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCEaseElastic* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElastic actionWithAction:(CCActionInterval*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElastic actionWithAction:(CCActionInterval*)arg0 period:(float)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: None (None)
JSBool JSPROXY_CCEaseElastic_initWithAction_period_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCEaseElastic *real = [(CCEaseElastic*)[proxy.klass alloc] initWithAction:(CCActionInterval*)arg0 period:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCEaseElastic_period(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCEaseElastic *real = (CCEaseElastic*) [proxy realObj];
	ret_val = [real period ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCEaseElastic_setPeriod_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseElastic *real = (CCEaseElastic*) [proxy realObj];
	[real setPeriod:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseElastic* (o)
JSBool JSPROXY_CCEaseElastic_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseElastic* ret_val;

	ret_val = [CCEaseElastic actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseElastic* (o)
JSBool JSPROXY_CCEaseElastic_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseElastic* ret_val;

	ret_val = [CCEaseElastic action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseElastic_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseElastic_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseElastic_class->name = name;
	JSPROXY_CCEaseElastic_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseElastic_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseElastic_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseElastic_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseElastic_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseElastic_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseElastic_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseElastic_class->finalize = JSPROXY_CCEaseElastic_finalize;
//	JSPROXY_CCEaseElastic_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionPeriod", JSPROXY_CCEaseElastic_initWithAction_period_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPeriod", JSPROXY_CCEaseElastic_period, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPeriod", JSPROXY_CCEaseElastic_setPeriod_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseElastic_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseElastic_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseElastic_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseElastic_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseElastic_class, JSPROXY_CCEaseElastic_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseElastic

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseElastic_class, JSPROXY_CCEaseElastic_object, NULL);
	JSPROXY_CCEaseElastic *proxy = [[JSPROXY_CCEaseElastic alloc] initWithJSObject:jsobj class:[CCEaseElastic class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElasticOut
 */
#pragma mark - CCEaseElasticOut

JSClass* JSPROXY_CCEaseElasticOut_class = NULL;
JSObject* JSPROXY_CCEaseElasticOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseElasticOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseElasticOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseElasticOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseElasticOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseElasticOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseElasticOut *real = (CCEaseElasticOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElasticOut* (o)
JSBool JSPROXY_CCEaseElasticOut_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCEaseElasticOut* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElasticOut actionWithAction:(CCActionInterval*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElasticOut actionWithAction:(CCActionInterval*)arg0 period:(float)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseElasticOut* (o)
JSBool JSPROXY_CCEaseElasticOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseElasticOut* ret_val;

	ret_val = [CCEaseElasticOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseElasticOut* (o)
JSBool JSPROXY_CCEaseElasticOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseElasticOut* ret_val;

	ret_val = [CCEaseElasticOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseElasticOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseElasticOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseElasticOut_class->name = name;
	JSPROXY_CCEaseElasticOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseElasticOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseElasticOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseElasticOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseElasticOut_class->finalize = JSPROXY_CCEaseElasticOut_finalize;
//	JSPROXY_CCEaseElasticOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseElasticOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseElasticOut_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseElasticOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseElasticOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseElasticOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseElastic_object, JSPROXY_CCEaseElasticOut_class, JSPROXY_CCEaseElasticOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseElasticOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseElasticOut_class, JSPROXY_CCEaseElasticOut_object, NULL);
	JSPROXY_CCEaseElasticOut *proxy = [[JSPROXY_CCEaseElasticOut alloc] initWithJSObject:jsobj class:[CCEaseElasticOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProgressTo
 */
#pragma mark - CCProgressTo

JSClass* JSPROXY_CCProgressTo_class = NULL;
JSObject* JSPROXY_CCProgressTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCProgressTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCProgressTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCProgressTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCProgressTo)", obj);
}

// Arguments: ccTime, float
// Ret value: CCProgressTo* (o)
JSBool JSPROXY_CCProgressTo_actionWithDuration_percent__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCProgressTo* ret_val;

	ret_val = [CCProgressTo actionWithDuration:(ccTime)arg0 percent:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSPROXY_CCProgressTo_initWithDuration_percent_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCProgressTo *real = [(CCProgressTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 percent:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCProgressTo* (o)
JSBool JSPROXY_CCProgressTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCProgressTo* ret_val;

	ret_val = [CCProgressTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCProgressTo* (o)
JSBool JSPROXY_CCProgressTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCProgressTo* ret_val;

	ret_val = [CCProgressTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCProgressTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCProgressTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCProgressTo_class->name = name;
	JSPROXY_CCProgressTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCProgressTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCProgressTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCProgressTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCProgressTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCProgressTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCProgressTo_class->convert = JS_ConvertStub;
	JSPROXY_CCProgressTo_class->finalize = JSPROXY_CCProgressTo_finalize;
//	JSPROXY_CCProgressTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPercent", JSPROXY_CCProgressTo_initWithDuration_percent_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCProgressTo_actionWithDuration_percent__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCProgressTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCProgressTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCProgressTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCProgressTo_class, JSPROXY_CCProgressTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCProgressTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCProgressTo_class, JSPROXY_CCProgressTo_object, NULL);
	JSPROXY_CCProgressTo *proxy = [[JSPROXY_CCProgressTo alloc] initWithJSObject:jsobj class:[CCProgressTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScene
 */
#pragma mark - CCScene

JSClass* JSPROXY_CCScene_class = NULL;
JSObject* JSPROXY_CCScene_object = NULL;
 // Constructor
JSBool JSPROXY_CCScene_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCScene createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCScene_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCScene)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCScene_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCScene *real = [(CCScene*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScene* (o)
JSBool JSPROXY_CCScene_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCScene* ret_val;

	ret_val = [CCScene node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCScene_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCScene_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCScene_class->name = name;
	JSPROXY_CCScene_class->addProperty = JS_PropertyStub;
	JSPROXY_CCScene_class->delProperty = JS_PropertyStub;
	JSPROXY_CCScene_class->getProperty = JS_PropertyStub;
	JSPROXY_CCScene_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCScene_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCScene_class->resolve = JS_ResolveStub;
	JSPROXY_CCScene_class->convert = JS_ConvertStub;
	JSPROXY_CCScene_class->finalize = JSPROXY_CCScene_finalize;
//	JSPROXY_CCScene_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCScene_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCScene_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCScene_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCScene_class, JSPROXY_CCScene_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCScene

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCScene_class, JSPROXY_CCScene_object, NULL);
	JSPROXY_CCScene *proxy = [[JSPROXY_CCScene alloc] initWithJSObject:jsobj class:[CCScene class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionInstant
 */
#pragma mark - CCActionInstant

JSClass* JSPROXY_CCActionInstant_class = NULL;
JSObject* JSPROXY_CCActionInstant_object = NULL;
 // Constructor
JSBool JSPROXY_CCActionInstant_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCActionInstant createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCActionInstant_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCActionInstant)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCActionInstant_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCActionInstant *real = [(CCActionInstant*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInstant* (o)
JSBool JSPROXY_CCActionInstant_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInstant* ret_val;

	ret_val = [CCActionInstant action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCActionInstant_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCActionInstant_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCActionInstant_class->name = name;
	JSPROXY_CCActionInstant_class->addProperty = JS_PropertyStub;
	JSPROXY_CCActionInstant_class->delProperty = JS_PropertyStub;
	JSPROXY_CCActionInstant_class->getProperty = JS_PropertyStub;
	JSPROXY_CCActionInstant_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCActionInstant_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCActionInstant_class->resolve = JS_ResolveStub;
	JSPROXY_CCActionInstant_class->convert = JS_ConvertStub;
	JSPROXY_CCActionInstant_class->finalize = JSPROXY_CCActionInstant_finalize;
//	JSPROXY_CCActionInstant_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCActionInstant_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSPROXY_CCActionInstant_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCActionInstant_object = JS_InitClass(cx, globalObj, JSPROXY_CCFiniteTimeAction_object, JSPROXY_CCActionInstant_class, JSPROXY_CCActionInstant_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCActionInstant

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCActionInstant_class, JSPROXY_CCActionInstant_object, NULL);
	JSPROXY_CCActionInstant *proxy = [[JSPROXY_CCActionInstant alloc] initWithJSObject:jsobj class:[CCActionInstant class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipX
 */
#pragma mark - CCFlipX

JSClass* JSPROXY_CCFlipX_class = NULL;
JSObject* JSPROXY_CCFlipX_object = NULL;
 // Constructor
JSBool JSPROXY_CCFlipX_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFlipX createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFlipX_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFlipX)", obj);
}

// Arguments: BOOL
// Ret value: CCFlipX* (o)
JSBool JSPROXY_CCFlipX_actionWithFlipX__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCFlipX* ret_val;

	ret_val = [CCFlipX actionWithFlipX:(BOOL)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: None (None)
JSBool JSPROXY_CCFlipX_initWithFlipX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFlipX *real = [(CCFlipX*)[proxy.klass alloc] initWithFlipX:(BOOL)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFlipX* (o)
JSBool JSPROXY_CCFlipX_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFlipX* ret_val;

	ret_val = [CCFlipX action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFlipX_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFlipX_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFlipX_class->name = name;
	JSPROXY_CCFlipX_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFlipX_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFlipX_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFlipX_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFlipX_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFlipX_class->resolve = JS_ResolveStub;
	JSPROXY_CCFlipX_class->convert = JS_ConvertStub;
	JSPROXY_CCFlipX_class->finalize = JSPROXY_CCFlipX_finalize;
//	JSPROXY_CCFlipX_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithFlipX", JSPROXY_CCFlipX_initWithFlipX_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFlipX_actionWithFlipX__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFlipX_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFlipX_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCFlipX_class, JSPROXY_CCFlipX_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFlipX

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFlipX_class, JSPROXY_CCFlipX_object, NULL);
	JSPROXY_CCFlipX *proxy = [[JSPROXY_CCFlipX alloc] initWithJSObject:jsobj class:[CCFlipX class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipY
 */
#pragma mark - CCFlipY

JSClass* JSPROXY_CCFlipY_class = NULL;
JSObject* JSPROXY_CCFlipY_object = NULL;
 // Constructor
JSBool JSPROXY_CCFlipY_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFlipY createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFlipY_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFlipY)", obj);
}

// Arguments: BOOL
// Ret value: CCFlipY* (o)
JSBool JSPROXY_CCFlipY_actionWithFlipY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCFlipY* ret_val;

	ret_val = [CCFlipY actionWithFlipY:(BOOL)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: None (None)
JSBool JSPROXY_CCFlipY_initWithFlipY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFlipY *real = [(CCFlipY*)[proxy.klass alloc] initWithFlipY:(BOOL)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFlipY* (o)
JSBool JSPROXY_CCFlipY_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFlipY* ret_val;

	ret_val = [CCFlipY action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFlipY_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFlipY_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFlipY_class->name = name;
	JSPROXY_CCFlipY_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFlipY_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFlipY_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFlipY_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFlipY_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFlipY_class->resolve = JS_ResolveStub;
	JSPROXY_CCFlipY_class->convert = JS_ConvertStub;
	JSPROXY_CCFlipY_class->finalize = JSPROXY_CCFlipY_finalize;
//	JSPROXY_CCFlipY_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithFlipY", JSPROXY_CCFlipY_initWithFlipY_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFlipY_actionWithFlipY__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFlipY_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFlipY_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCFlipY_class, JSPROXY_CCFlipY_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFlipY

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFlipY_class, JSPROXY_CCFlipY_object, NULL);
	JSPROXY_CCFlipY *proxy = [[JSPROXY_CCFlipY alloc] initWithJSObject:jsobj class:[CCFlipY class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGridAction
 */
#pragma mark - CCGridAction

JSClass* JSPROXY_CCGridAction_class = NULL;
JSObject* JSPROXY_CCGridAction_object = NULL;
 // Constructor
JSBool JSPROXY_CCGridAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCGridAction createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCGridAction_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCGridAction)", obj);
}

// Arguments: ccGridSize, ccTime
// Ret value: CCGridAction* (o)
JSBool JSPROXY_CCGridAction_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCGridAction* ret_val;

	ret_val = [CCGridAction actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGridBase* (o)
JSBool JSPROXY_CCGridAction_grid(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGridBase* ret_val;

	CCGridAction *real = (CCGridAction*) [proxy realObj];
	ret_val = [real grid ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccGridSize ({_ccGridSize=ii})
JSBool JSPROXY_CCGridAction_gridSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccGridSize ret_val;

	CCGridAction *real = (CCGridAction*) [proxy realObj];
	ret_val = [real gridSize ];

	jsval ret_jsval = ccGridSize_to_jsval( cx, (ccGridSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCGridAction_initWithSize_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCGridAction *real = [(CCGridAction*)[proxy.klass alloc] initWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize
// Ret value: void (None)
JSBool JSPROXY_CCGridAction_setGridSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCGridAction *real = (CCGridAction*) [proxy realObj];
	[real setGridSize:(ccGridSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCGridAction* (o)
JSBool JSPROXY_CCGridAction_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCGridAction* ret_val;

	ret_val = [CCGridAction actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGridAction* (o)
JSBool JSPROXY_CCGridAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGridAction* ret_val;

	ret_val = [CCGridAction action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCGridAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCGridAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCGridAction_class->name = name;
	JSPROXY_CCGridAction_class->addProperty = JS_PropertyStub;
	JSPROXY_CCGridAction_class->delProperty = JS_PropertyStub;
	JSPROXY_CCGridAction_class->getProperty = JS_PropertyStub;
	JSPROXY_CCGridAction_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCGridAction_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCGridAction_class->resolve = JS_ResolveStub;
	JSPROXY_CCGridAction_class->convert = JS_ConvertStub;
	JSPROXY_CCGridAction_class->finalize = JSPROXY_CCGridAction_finalize;
//	JSPROXY_CCGridAction_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("grid", JSPROXY_CCGridAction_grid, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getGridSize", JSPROXY_CCGridAction_gridSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSizeDuration", JSPROXY_CCGridAction_initWithSize_duration_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setGridSize", JSPROXY_CCGridAction_setGridSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithSizeDuration", JSPROXY_CCGridAction_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCGridAction_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCGridAction_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCGridAction_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCGridAction_class, JSPROXY_CCGridAction_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCGridAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCGridAction_class, JSPROXY_CCGridAction_object, NULL);
	JSPROXY_CCGridAction *proxy = [[JSPROXY_CCGridAction alloc] initWithJSObject:jsobj class:[CCGridAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTiledGrid3DAction
 */
#pragma mark - CCTiledGrid3DAction

JSClass* JSPROXY_CCTiledGrid3DAction_class = NULL;
JSObject* JSPROXY_CCTiledGrid3DAction_object = NULL;
 // Constructor
JSBool JSPROXY_CCTiledGrid3DAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTiledGrid3DAction createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTiledGrid3DAction_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTiledGrid3DAction)", obj);
}

// Arguments: ccGridSize, ccTime
// Ret value: CCTiledGrid3DAction* (o)
JSBool JSPROXY_CCTiledGrid3DAction_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTiledGrid3DAction* ret_val;

	ret_val = [CCTiledGrid3DAction actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCTiledGrid3DAction* (o)
JSBool JSPROXY_CCTiledGrid3DAction_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTiledGrid3DAction* ret_val;

	ret_val = [CCTiledGrid3DAction actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTiledGrid3DAction* (o)
JSBool JSPROXY_CCTiledGrid3DAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTiledGrid3DAction* ret_val;

	ret_val = [CCTiledGrid3DAction action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTiledGrid3DAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTiledGrid3DAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTiledGrid3DAction_class->name = name;
	JSPROXY_CCTiledGrid3DAction_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTiledGrid3DAction_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTiledGrid3DAction_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTiledGrid3DAction_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTiledGrid3DAction_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTiledGrid3DAction_class->resolve = JS_ResolveStub;
	JSPROXY_CCTiledGrid3DAction_class->convert = JS_ConvertStub;
	JSPROXY_CCTiledGrid3DAction_class->finalize = JSPROXY_CCTiledGrid3DAction_finalize;
//	JSPROXY_CCTiledGrid3DAction_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithSizeDuration", JSPROXY_CCTiledGrid3DAction_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCTiledGrid3DAction_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCTiledGrid3DAction_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTiledGrid3DAction_object = JS_InitClass(cx, globalObj, JSPROXY_CCGridAction_object, JSPROXY_CCTiledGrid3DAction_class, JSPROXY_CCTiledGrid3DAction_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTiledGrid3DAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTiledGrid3DAction_class, JSPROXY_CCTiledGrid3DAction_object, NULL);
	JSPROXY_CCTiledGrid3DAction *proxy = [[JSPROXY_CCTiledGrid3DAction alloc] initWithJSObject:jsobj class:[CCTiledGrid3DAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShakyTiles3D
 */
#pragma mark - CCShakyTiles3D

JSClass* JSPROXY_CCShakyTiles3D_class = NULL;
JSObject* JSPROXY_CCShakyTiles3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCShakyTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCShakyTiles3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCShakyTiles3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCShakyTiles3D)", obj);
}

// Arguments: int, BOOL, ccGridSize, ccTime
// Ret value: CCShakyTiles3D* (o)
JSBool JSPROXY_CCShakyTiles3D_actionWithRange_shakeZ_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCShakyTiles3D* ret_val;

	ret_val = [CCShakyTiles3D actionWithRange:(int)arg0 shakeZ:(BOOL)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int, BOOL, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCShakyTiles3D_initWithRange_shakeZ_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCShakyTiles3D *real = [(CCShakyTiles3D*)[proxy.klass alloc] initWithRange:(int)arg0 shakeZ:(BOOL)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCShakyTiles3D* (o)
JSBool JSPROXY_CCShakyTiles3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCShakyTiles3D* ret_val;

	ret_val = [CCShakyTiles3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCShakyTiles3D* (o)
JSBool JSPROXY_CCShakyTiles3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCShakyTiles3D* ret_val;

	ret_val = [CCShakyTiles3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShakyTiles3D* (o)
JSBool JSPROXY_CCShakyTiles3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCShakyTiles3D* ret_val;

	ret_val = [CCShakyTiles3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCShakyTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCShakyTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCShakyTiles3D_class->name = name;
	JSPROXY_CCShakyTiles3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCShakyTiles3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCShakyTiles3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCShakyTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCShakyTiles3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCShakyTiles3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCShakyTiles3D_class->convert = JS_ConvertStub;
	JSPROXY_CCShakyTiles3D_class->finalize = JSPROXY_CCShakyTiles3D_finalize;
//	JSPROXY_CCShakyTiles3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithRangeShakeZGridDuration", JSPROXY_CCShakyTiles3D_initWithRange_shakeZ_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithRangeShakeZGridDuration", JSPROXY_CCShakyTiles3D_actionWithRange_shakeZ_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCShakyTiles3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCShakyTiles3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCShakyTiles3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCShakyTiles3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCShakyTiles3D_class, JSPROXY_CCShakyTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCShakyTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCShakyTiles3D_class, JSPROXY_CCShakyTiles3D_object, NULL);
	JSPROXY_CCShakyTiles3D *proxy = [[JSPROXY_CCShakyTiles3D alloc] initWithJSObject:jsobj class:[CCShakyTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCJumpBy
 */
#pragma mark - CCJumpBy

JSClass* JSPROXY_CCJumpBy_class = NULL;
JSObject* JSPROXY_CCJumpBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCJumpBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCJumpBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCJumpBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCJumpBy)", obj);
}

// Arguments: ccTime, CGPoint, ccTime, NSUInteger
// Ret value: CCJumpBy* (o)
JSBool JSPROXY_CCJumpBy_actionWithDuration_position_height_jumps__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; double arg2; uint32_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCJumpBy* ret_val;

	ret_val = [CCJumpBy actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1 height:(ccTime)arg2 jumps:(NSUInteger)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CGPoint, ccTime, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCJumpBy_initWithDuration_position_height_jumps_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; double arg2; uint32_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCJumpBy *real = [(CCJumpBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 position:(CGPoint)arg1 height:(ccTime)arg2 jumps:(NSUInteger)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCJumpBy* (o)
JSBool JSPROXY_CCJumpBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCJumpBy* ret_val;

	ret_val = [CCJumpBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCJumpBy* (o)
JSBool JSPROXY_CCJumpBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCJumpBy* ret_val;

	ret_val = [CCJumpBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCJumpBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCJumpBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCJumpBy_class->name = name;
	JSPROXY_CCJumpBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCJumpBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCJumpBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCJumpBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCJumpBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCJumpBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCJumpBy_class->convert = JS_ConvertStub;
	JSPROXY_CCJumpBy_class->finalize = JSPROXY_CCJumpBy_finalize;
//	JSPROXY_CCJumpBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPositionHeightJumps", JSPROXY_CCJumpBy_initWithDuration_position_height_jumps_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCJumpBy_actionWithDuration_position_height_jumps__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCJumpBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCJumpBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCJumpBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCJumpBy_class, JSPROXY_CCJumpBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCJumpBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCJumpBy_class, JSPROXY_CCJumpBy_object, NULL);
	JSPROXY_CCJumpBy *proxy = [[JSPROXY_CCJumpBy alloc] initWithJSObject:jsobj class:[CCJumpBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLabelTTF
 */
#pragma mark - CCLabelTTF

JSClass* JSPROXY_CCLabelTTF_class = NULL;
JSObject* JSPROXY_CCLabelTTF_object = NULL;
 // Constructor
JSBool JSPROXY_CCLabelTTF_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCLabelTTF createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCLabelTTF_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCLabelTTF)", obj);
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCLabelTTF_dimensions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real dimensions ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCLabelTTF_fontName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real fontName ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCLabelTTF_fontSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real fontSize ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextAlignment (i)
JSBool JSPROXY_CCLabelTTF_horizontalAlignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTextAlignment ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real horizontalAlignment ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; NSString* arg3; double arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 fontName:(NSString*)arg3 fontSize:(CGFloat)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCLineBreakMode, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_lineBreakMode_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; NSString* arg4; double arg5; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 lineBreakMode:(CCLineBreakMode)arg3 fontName:(NSString*)arg4 fontSize:(CGFloat)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCVerticalTextAlignment, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_vAlignment_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; NSString* arg4; double arg5; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 vAlignment:(CCVerticalTextAlignment)arg3 fontName:(NSString*)arg4 fontSize:(CGFloat)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCVerticalTextAlignment, CCLineBreakMode, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_vAlignment_lineBreakMode_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 7, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; int32_t arg4; NSString* arg5; double arg6; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg4 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 vAlignment:(CCVerticalTextAlignment)arg3 lineBreakMode:(CCLineBreakMode)arg4 fontName:(NSString*)arg5 fontSize:(CGFloat)arg6  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCLabelTTF_initWithString_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = [(CCLabelTTF*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, NSString*, CGFloat
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_fontName_fontSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; NSString* arg3; double arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 fontName:(NSString*)arg3 fontSize:(CGFloat)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCLineBreakMode, NSString*, CGFloat
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_lineBreakMode_fontName_fontSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; NSString* arg4; double arg5; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 lineBreakMode:(CCLineBreakMode)arg3 fontName:(NSString*)arg4 fontSize:(CGFloat)arg5  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCVerticalTextAlignment, NSString*, CGFloat
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_vAlignment_fontName_fontSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; NSString* arg4; double arg5; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 vAlignment:(CCVerticalTextAlignment)arg3 fontName:(NSString*)arg4 fontSize:(CGFloat)arg5  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCVerticalTextAlignment, CCLineBreakMode, NSString*, CGFloat
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_vAlignment_lineBreakMode_fontName_fontSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 7, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; int32_t arg4; NSString* arg5; double arg6; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg4 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 vAlignment:(CCVerticalTextAlignment)arg3 lineBreakMode:(CCLineBreakMode)arg4 fontName:(NSString*)arg5 fontSize:(CGFloat)arg6  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_labelWithString_fontName_fontSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF labelWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCLabelTTF_setDimensions_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setDimensions:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCLabelTTF_setFontName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setFontName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCLabelTTF_setFontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setFontSize:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTextAlignment
// Ret value: void (None)
JSBool JSPROXY_CCLabelTTF_setHorizontalAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setHorizontalAlignment:(CCTextAlignment)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCLabelTTF_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setString:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCVerticalTextAlignment
// Ret value: void (None)
JSBool JSPROXY_CCLabelTTF_setVerticalAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	[real setVerticalAlignment:(CCVerticalTextAlignment)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCVerticalTextAlignment (i)
JSBool JSPROXY_CCLabelTTF_verticalAlignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCVerticalTextAlignment ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real verticalAlignment ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCLabelTTF_string(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelTTF *real = (CCLabelTTF*) [proxy realObj];
	ret_val = [real string ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_spriteWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF spriteWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_spriteWithFile_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF spriteWithFile:(NSString*)arg0 rect:(CGRect)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_spriteWithSpriteFrame__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF spriteWithSpriteFrame:(CCSpriteFrame*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_spriteWithSpriteFrameName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF spriteWithSpriteFrameName:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_spriteWithTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF spriteWithTexture:(CCTexture2D*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_spriteWithTexture_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF spriteWithTexture:(CCTexture2D*)arg0 rect:(CGRect)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLabelTTF* (o)
JSBool JSPROXY_CCLabelTTF_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCLabelTTF* ret_val;

	ret_val = [CCLabelTTF node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCLabelTTF_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCLabelTTF_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCLabelTTF_class->name = name;
	JSPROXY_CCLabelTTF_class->addProperty = JS_PropertyStub;
	JSPROXY_CCLabelTTF_class->delProperty = JS_PropertyStub;
	JSPROXY_CCLabelTTF_class->getProperty = JS_PropertyStub;
	JSPROXY_CCLabelTTF_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCLabelTTF_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCLabelTTF_class->resolve = JS_ResolveStub;
	JSPROXY_CCLabelTTF_class->convert = JS_ConvertStub;
	JSPROXY_CCLabelTTF_class->finalize = JSPROXY_CCLabelTTF_finalize;
//	JSPROXY_CCLabelTTF_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDimensions", JSPROXY_CCLabelTTF_dimensions, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getFontName", JSPROXY_CCLabelTTF_fontName, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getFontSize", JSPROXY_CCLabelTTF_fontSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getHorizontalAlignment", JSPROXY_CCLabelTTF_horizontalAlignment, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringDimensionsHAlignmentFontNameFontSize", JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_fontName_fontSize_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringDimensionsHAlignmentLineBreakModeFontNameFontSize", JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_lineBreakMode_fontName_fontSize_, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringDimensionsHAlignmentVAlignmentFontNameFontSize", JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_vAlignment_fontName_fontSize_, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringDimensionsHAlignmentVAlignmentLineBreakModeFontNameFontSize", JSPROXY_CCLabelTTF_initWithString_dimensions_hAlignment_vAlignment_lineBreakMode_fontName_fontSize_, 7, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSize", JSPROXY_CCLabelTTF_initWithString_fontName_fontSize_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDimensions", JSPROXY_CCLabelTTF_setDimensions_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFontName", JSPROXY_CCLabelTTF_setFontName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFontSize", JSPROXY_CCLabelTTF_setFontSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setHorizontalAlignment", JSPROXY_CCLabelTTF_setHorizontalAlignment_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setString", JSPROXY_CCLabelTTF_setString_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setVerticalAlignment", JSPROXY_CCLabelTTF_setVerticalAlignment_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getVerticalAlignment", JSPROXY_CCLabelTTF_verticalAlignment, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("string", JSPROXY_CCLabelTTF_string, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("labelWithStringDimensionsHAlignmentFontNameFontSize", JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_fontName_fontSize__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("labelWithStringDimensionsHAlignmentLineBreakModeFontNameFontSize", JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_lineBreakMode_fontName_fontSize__static, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("labelWithStringDimensionsHAlignmentVAlignmentFontNameFontSize", JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_vAlignment_fontName_fontSize__static, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("labelWithStringDimensionsHAlignmentVAlignmentLineBreakModeFontNameFontSize", JSPROXY_CCLabelTTF_labelWithString_dimensions_hAlignment_vAlignment_lineBreakMode_fontName_fontSize__static, 7, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCLabelTTF_labelWithString_fontName_fontSize__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("spriteWithFile", JSPROXY_CCLabelTTF_spriteWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("spriteWithFileRect", JSPROXY_CCLabelTTF_spriteWithFile_rect__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("spriteWithSpriteFrame", JSPROXY_CCLabelTTF_spriteWithSpriteFrame__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("spriteWithSpriteFrameName", JSPROXY_CCLabelTTF_spriteWithSpriteFrameName__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("spriteWithTexture", JSPROXY_CCLabelTTF_spriteWithTexture__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("spriteWithTextureRect", JSPROXY_CCLabelTTF_spriteWithTexture_rect__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCLabelTTF_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCLabelTTF_object = JS_InitClass(cx, globalObj, JSPROXY_CCSprite_object, JSPROXY_CCLabelTTF_class, JSPROXY_CCLabelTTF_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCLabelTTF

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCLabelTTF_class, JSPROXY_CCLabelTTF_object, NULL);
	JSPROXY_CCLabelTTF *proxy = [[JSPROXY_CCLabelTTF alloc] initWithJSObject:jsobj class:[CCLabelTTF class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionScene
 */
#pragma mark - CCTransitionScene

JSClass* JSPROXY_CCTransitionScene_class = NULL;
JSObject* JSPROXY_CCTransitionScene_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionScene_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionScene createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionScene_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionScene)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionScene_finish(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionScene *real = (CCTransitionScene*) [proxy realObj];
	[real finish ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionScene_hideOutShowIn(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionScene *real = (CCTransitionScene*) [proxy realObj];
	[real hideOutShowIn ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: None (None)
JSBool JSPROXY_CCTransitionScene_initWithDuration_scene_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCTransitionScene *real = [(CCTransitionScene*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionScene* (o)
JSBool JSPROXY_CCTransitionScene_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionScene* ret_val;

	ret_val = [CCTransitionScene transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionScene* (o)
JSBool JSPROXY_CCTransitionScene_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionScene* ret_val;

	ret_val = [CCTransitionScene node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionScene_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionScene_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionScene_class->name = name;
	JSPROXY_CCTransitionScene_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionScene_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionScene_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionScene_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionScene_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionScene_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionScene_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionScene_class->finalize = JSPROXY_CCTransitionScene_finalize;
//	JSPROXY_CCTransitionScene_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("finish", JSPROXY_CCTransitionScene_finish, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("hideOutShowIn", JSPROXY_CCTransitionScene_hideOutShowIn, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithDurationScene", JSPROXY_CCTransitionScene_initWithDuration_scene_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionScene_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionScene_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionScene_object = JS_InitClass(cx, globalObj, JSPROXY_CCScene_object, JSPROXY_CCTransitionScene_class, JSPROXY_CCTransitionScene_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionScene

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionScene_class, JSPROXY_CCTransitionScene_object, NULL);
	JSPROXY_CCTransitionScene *proxy = [[JSPROXY_CCTransitionScene alloc] initWithJSObject:jsobj class:[CCTransitionScene class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgress
 */
#pragma mark - CCTransitionProgress

JSClass* JSPROXY_CCTransitionProgress_class = NULL;
JSObject* JSPROXY_CCTransitionProgress_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionProgress_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionProgress createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionProgress_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionProgress)", obj);
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCTransitionProgress_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	CCTransitionProgress *real = (CCTransitionProgress*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:(CCRenderTexture*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgress* (o)
JSBool JSPROXY_CCTransitionProgress_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionProgress* ret_val;

	ret_val = [CCTransitionProgress transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgress* (o)
JSBool JSPROXY_CCTransitionProgress_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionProgress* ret_val;

	ret_val = [CCTransitionProgress node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionProgress_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionProgress_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionProgress_class->name = name;
	JSPROXY_CCTransitionProgress_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgress_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgress_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgress_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionProgress_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionProgress_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionProgress_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionProgress_class->finalize = JSPROXY_CCTransitionProgress_finalize;
//	JSPROXY_CCTransitionProgress_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSPROXY_CCTransitionProgress_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionProgress_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionProgress_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionProgress_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionProgress_class, JSPROXY_CCTransitionProgress_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionProgress

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionProgress_class, JSPROXY_CCTransitionProgress_object, NULL);
	JSPROXY_CCTransitionProgress *proxy = [[JSPROXY_CCTransitionProgress alloc] initWithJSObject:jsobj class:[CCTransitionProgress class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressRadialCCW
 */
#pragma mark - CCTransitionProgressRadialCCW

JSClass* JSPROXY_CCTransitionProgressRadialCCW_class = NULL;
JSObject* JSPROXY_CCTransitionProgressRadialCCW_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionProgressRadialCCW_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionProgressRadialCCW createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionProgressRadialCCW_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionProgressRadialCCW)", obj);
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCTransitionProgressRadialCCW_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	CCTransitionProgressRadialCCW *real = (CCTransitionProgressRadialCCW*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:(CCRenderTexture*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressRadialCCW* (o)
JSBool JSPROXY_CCTransitionProgressRadialCCW_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionProgressRadialCCW* ret_val;

	ret_val = [CCTransitionProgressRadialCCW transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressRadialCCW* (o)
JSBool JSPROXY_CCTransitionProgressRadialCCW_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionProgressRadialCCW* ret_val;

	ret_val = [CCTransitionProgressRadialCCW node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionProgressRadialCCW_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionProgressRadialCCW_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionProgressRadialCCW_class->name = name;
	JSPROXY_CCTransitionProgressRadialCCW_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressRadialCCW_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressRadialCCW_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressRadialCCW_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionProgressRadialCCW_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionProgressRadialCCW_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionProgressRadialCCW_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionProgressRadialCCW_class->finalize = JSPROXY_CCTransitionProgressRadialCCW_finalize;
//	JSPROXY_CCTransitionProgressRadialCCW_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSPROXY_CCTransitionProgressRadialCCW_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionProgressRadialCCW_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionProgressRadialCCW_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionProgressRadialCCW_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionProgress_object, JSPROXY_CCTransitionProgressRadialCCW_class, JSPROXY_CCTransitionProgressRadialCCW_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionProgressRadialCCW

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionProgressRadialCCW_class, JSPROXY_CCTransitionProgressRadialCCW_object, NULL);
	JSPROXY_CCTransitionProgressRadialCCW *proxy = [[JSPROXY_CCTransitionProgressRadialCCW alloc] initWithJSObject:jsobj class:[CCTransitionProgressRadialCCW class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShaderCache
 */
#pragma mark - CCShaderCache

JSClass* JSPROXY_CCShaderCache_class = NULL;
JSObject* JSPROXY_CCShaderCache_object = NULL;
 // Constructor
JSBool JSPROXY_CCShaderCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCShaderCache createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCShaderCache_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCShaderCache)", obj);
}

// Arguments: CCGLProgram*, NSString*
// Ret value: void (None)
JSBool JSPROXY_CCShaderCache_addProgram_forKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; NSString* arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCShaderCache *real = (CCShaderCache*) [proxy realObj];
	[real addProgram:(CCGLProgram*)arg0 forKey:(NSString*)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCShaderCache_loadDefaultShaders(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCShaderCache *real = (CCShaderCache*) [proxy realObj];
	[real loadDefaultShaders ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCGLProgram* (o)
JSBool JSPROXY_CCShaderCache_programForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCGLProgram* ret_val;

	CCShaderCache *real = (CCShaderCache*) [proxy realObj];
	ret_val = [real programForKey:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCShaderCache_purgeSharedShaderCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	[CCShaderCache purgeSharedShaderCache ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShaderCache* (o)
JSBool JSPROXY_CCShaderCache_sharedShaderCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCShaderCache* ret_val;

	ret_val = [CCShaderCache sharedShaderCache ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCShaderCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCShaderCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCShaderCache_class->name = name;
	JSPROXY_CCShaderCache_class->addProperty = JS_PropertyStub;
	JSPROXY_CCShaderCache_class->delProperty = JS_PropertyStub;
	JSPROXY_CCShaderCache_class->getProperty = JS_PropertyStub;
	JSPROXY_CCShaderCache_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCShaderCache_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCShaderCache_class->resolve = JS_ResolveStub;
	JSPROXY_CCShaderCache_class->convert = JS_ConvertStub;
	JSPROXY_CCShaderCache_class->finalize = JSPROXY_CCShaderCache_finalize;
//	JSPROXY_CCShaderCache_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addProgramForKey", JSPROXY_CCShaderCache_addProgram_forKey_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("loadDefaultShaders", JSPROXY_CCShaderCache_loadDefaultShaders, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("programForKey", JSPROXY_CCShaderCache_programForKey_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedShaderCache", JSPROXY_CCShaderCache_purgeSharedShaderCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("sharedShaderCache", JSPROXY_CCShaderCache_sharedShaderCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCShaderCache_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCShaderCache_class, JSPROXY_CCShaderCache_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCShaderCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCShaderCache_class, JSPROXY_CCShaderCache_object, NULL);
	JSPROXY_CCShaderCache *proxy = [[JSPROXY_CCShaderCache alloc] initWithJSObject:jsobj class:[CCShaderCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeTR
 */
#pragma mark - CCTransitionFadeTR

JSClass* JSPROXY_CCTransitionFadeTR_class = NULL;
JSObject* JSPROXY_CCTransitionFadeTR_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFadeTR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFadeTR createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFadeTR_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFadeTR)", obj);
}

// Arguments: ccGridSize
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionFadeTR_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionFadeTR *real = (CCTransitionFadeTR*) [proxy realObj];
	ret_val = [real actionWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionFadeTR_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionFadeTR *real = (CCTransitionFadeTR*) [proxy realObj];
	ret_val = [real easeActionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeTR* (o)
JSBool JSPROXY_CCTransitionFadeTR_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionFadeTR* ret_val;

	ret_val = [CCTransitionFadeTR transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeTR* (o)
JSBool JSPROXY_CCTransitionFadeTR_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFadeTR* ret_val;

	ret_val = [CCTransitionFadeTR node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFadeTR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFadeTR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFadeTR_class->name = name;
	JSPROXY_CCTransitionFadeTR_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeTR_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeTR_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeTR_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFadeTR_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFadeTR_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFadeTR_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFadeTR_class->finalize = JSPROXY_CCTransitionFadeTR_finalize;
//	JSPROXY_CCTransitionFadeTR_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSPROXY_CCTransitionFadeTR_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSPROXY_CCTransitionFadeTR_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionFadeTR_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFadeTR_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFadeTR_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionFadeTR_class, JSPROXY_CCTransitionFadeTR_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFadeTR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFadeTR_class, JSPROXY_CCTransitionFadeTR_object, NULL);
	JSPROXY_CCTransitionFadeTR *proxy = [[JSPROXY_CCTransitionFadeTR alloc] initWithJSObject:jsobj class:[CCTransitionFadeTR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBackOut
 */
#pragma mark - CCEaseBackOut

JSClass* JSPROXY_CCEaseBackOut_class = NULL;
JSObject* JSPROXY_CCEaseBackOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseBackOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseBackOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseBackOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseBackOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseBackOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseBackOut *real = (CCEaseBackOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBackOut* (o)
JSBool JSPROXY_CCEaseBackOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseBackOut* ret_val;

	ret_val = [CCEaseBackOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseBackOut* (o)
JSBool JSPROXY_CCEaseBackOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseBackOut* ret_val;

	ret_val = [CCEaseBackOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseBackOut* (o)
JSBool JSPROXY_CCEaseBackOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseBackOut* ret_val;

	ret_val = [CCEaseBackOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseBackOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseBackOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseBackOut_class->name = name;
	JSPROXY_CCEaseBackOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseBackOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseBackOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseBackOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseBackOut_class->finalize = JSPROXY_CCEaseBackOut_finalize;
//	JSPROXY_CCEaseBackOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseBackOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseBackOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseBackOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseBackOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseBackOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseBackOut_class, JSPROXY_CCEaseBackOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseBackOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseBackOut_class, JSPROXY_CCEaseBackOut_object, NULL);
	JSPROXY_CCEaseBackOut *proxy = [[JSPROXY_CCEaseBackOut alloc] initWithJSObject:jsobj class:[CCEaseBackOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSceneOriented
 */
#pragma mark - CCTransitionSceneOriented

JSClass* JSPROXY_CCTransitionSceneOriented_class = NULL;
JSObject* JSPROXY_CCTransitionSceneOriented_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionSceneOriented_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionSceneOriented createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionSceneOriented_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionSceneOriented)", obj);
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: None (None)
JSBool JSPROXY_CCTransitionSceneOriented_initWithDuration_scene_orientation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCTransitionSceneOriented *real = [(CCTransitionSceneOriented*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionSceneOriented* (o)
JSBool JSPROXY_CCTransitionSceneOriented_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTransitionSceneOriented* ret_val;

	ret_val = [CCTransitionSceneOriented transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSceneOriented* (o)
JSBool JSPROXY_CCTransitionSceneOriented_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionSceneOriented* ret_val;

	ret_val = [CCTransitionSceneOriented transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSceneOriented* (o)
JSBool JSPROXY_CCTransitionSceneOriented_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionSceneOriented* ret_val;

	ret_val = [CCTransitionSceneOriented node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionSceneOriented_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionSceneOriented_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionSceneOriented_class->name = name;
	JSPROXY_CCTransitionSceneOriented_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSceneOriented_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSceneOriented_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSceneOriented_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionSceneOriented_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionSceneOriented_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionSceneOriented_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionSceneOriented_class->finalize = JSPROXY_CCTransitionSceneOriented_finalize;
//	JSPROXY_CCTransitionSceneOriented_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSceneOrientation", JSPROXY_CCTransitionSceneOriented_initWithDuration_scene_orientation_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSPROXY_CCTransitionSceneOriented_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTransitionSceneOriented_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionSceneOriented_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionSceneOriented_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionSceneOriented_class, JSPROXY_CCTransitionSceneOriented_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionSceneOriented

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionSceneOriented_class, JSPROXY_CCTransitionSceneOriented_object, NULL);
	JSPROXY_CCTransitionSceneOriented *proxy = [[JSPROXY_CCTransitionSceneOriented alloc] initWithJSObject:jsobj class:[CCTransitionSceneOriented class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScaleTo
 */
#pragma mark - CCScaleTo

JSClass* JSPROXY_CCScaleTo_class = NULL;
JSObject* JSPROXY_CCScaleTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCScaleTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCScaleTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCScaleTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCScaleTo)", obj);
}

// Arguments: ccTime, float, float
// Ret value: CCScaleTo* (o)
JSBool JSPROXY_CCScaleTo_actionWithDuration_scaleX_scaleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 2 && argc <= 3 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	if( ! ok ) return JS_FALSE;
	CCScaleTo* ret_val;

	if( argc == 2 ) {
		ret_val = [CCScaleTo actionWithDuration:(ccTime)arg0 scale:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCScaleTo actionWithDuration:(ccTime)arg0 scaleX:(float)arg1 scaleY:(float)arg2  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSPROXY_CCScaleTo_initWithDuration_scale_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCScaleTo *real = [(CCScaleTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scale:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSPROXY_CCScaleTo_initWithDuration_scaleX_scaleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCScaleTo *real = [(CCScaleTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scaleX:(float)arg1 scaleY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCScaleTo* (o)
JSBool JSPROXY_CCScaleTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCScaleTo* ret_val;

	ret_val = [CCScaleTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScaleTo* (o)
JSBool JSPROXY_CCScaleTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCScaleTo* ret_val;

	ret_val = [CCScaleTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCScaleTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCScaleTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCScaleTo_class->name = name;
	JSPROXY_CCScaleTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCScaleTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCScaleTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCScaleTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCScaleTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCScaleTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCScaleTo_class->convert = JS_ConvertStub;
	JSPROXY_CCScaleTo_class->finalize = JSPROXY_CCScaleTo_finalize;
//	JSPROXY_CCScaleTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationScale", JSPROXY_CCScaleTo_initWithDuration_scale_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithDurationScaleXScaleY", JSPROXY_CCScaleTo_initWithDuration_scaleX_scaleY_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCScaleTo_actionWithDuration_scaleX_scaleY__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCScaleTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCScaleTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCScaleTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCScaleTo_class, JSPROXY_CCScaleTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCScaleTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCScaleTo_class, JSPROXY_CCScaleTo_object, NULL);
	JSPROXY_CCScaleTo *proxy = [[JSPROXY_CCScaleTo alloc] initWithJSObject:jsobj class:[CCScaleTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScaleBy
 */
#pragma mark - CCScaleBy

JSClass* JSPROXY_CCScaleBy_class = NULL;
JSObject* JSPROXY_CCScaleBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCScaleBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCScaleBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCScaleBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCScaleBy)", obj);
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCScaleBy_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCScaleBy *real = (CCScaleBy*) [proxy realObj];
	[real startWithTarget:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCScaleBy* (o)
JSBool JSPROXY_CCScaleBy_actionWithDuration_scaleX_scaleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 2 && argc <= 3 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	}
	if( ! ok ) return JS_FALSE;
	CCScaleBy* ret_val;

	if( argc == 2 ) {
		ret_val = [CCScaleBy actionWithDuration:(ccTime)arg0 scale:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCScaleBy actionWithDuration:(ccTime)arg0 scaleX:(float)arg1 scaleY:(float)arg2  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCScaleBy* (o)
JSBool JSPROXY_CCScaleBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCScaleBy* ret_val;

	ret_val = [CCScaleBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCScaleBy* (o)
JSBool JSPROXY_CCScaleBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCScaleBy* ret_val;

	ret_val = [CCScaleBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCScaleBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCScaleBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCScaleBy_class->name = name;
	JSPROXY_CCScaleBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCScaleBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCScaleBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCScaleBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCScaleBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCScaleBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCScaleBy_class->convert = JS_ConvertStub;
	JSPROXY_CCScaleBy_class->finalize = JSPROXY_CCScaleBy_finalize;
//	JSPROXY_CCScaleBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSPROXY_CCScaleBy_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCScaleBy_actionWithDuration_scaleX_scaleY__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCScaleBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCScaleBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCScaleBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCScaleTo_object, JSPROXY_CCScaleBy_class, JSPROXY_CCScaleBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCScaleBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCScaleBy_class, JSPROXY_CCScaleBy_object, NULL);
	JSPROXY_CCScaleBy *proxy = [[JSPROXY_CCScaleBy alloc] initWithJSObject:jsobj class:[CCScaleBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionPageTurn
 */
#pragma mark - CCTransitionPageTurn

JSClass* JSPROXY_CCTransitionPageTurn_class = NULL;
JSObject* JSPROXY_CCTransitionPageTurn_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionPageTurn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionPageTurn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionPageTurn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionPageTurn)", obj);
}

// Arguments: ccGridSize
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionPageTurn_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionPageTurn *real = (CCTransitionPageTurn*) [proxy realObj];
	ret_val = [real actionWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, BOOL
// Ret value: None (None)
JSBool JSPROXY_CCTransitionPageTurn_initWithDuration_scene_backwards_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; JSBool arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCTransitionPageTurn *real = [(CCTransitionPageTurn*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 backwards:(BOOL)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, BOOL
// Ret value: CCTransitionPageTurn* (o)
JSBool JSPROXY_CCTransitionPageTurn_transitionWithDuration_scene_backwards__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 2 && argc <= 3 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; JSBool arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if (argc >= 3) {
		ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	}
	if( ! ok ) return JS_FALSE;
	CCTransitionPageTurn* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionPageTurn transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionPageTurn transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 backwards:(BOOL)arg2  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionPageTurn* (o)
JSBool JSPROXY_CCTransitionPageTurn_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionPageTurn* ret_val;

	ret_val = [CCTransitionPageTurn node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionPageTurn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionPageTurn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionPageTurn_class->name = name;
	JSPROXY_CCTransitionPageTurn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionPageTurn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionPageTurn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionPageTurn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionPageTurn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionPageTurn_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionPageTurn_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionPageTurn_class->finalize = JSPROXY_CCTransitionPageTurn_finalize;
//	JSPROXY_CCTransitionPageTurn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSPROXY_CCTransitionPageTurn_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithDurationSceneBackwards", JSPROXY_CCTransitionPageTurn_initWithDuration_scene_backwards_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionPageTurn_transitionWithDuration_scene_backwards__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionPageTurn_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionPageTurn_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionPageTurn_class, JSPROXY_CCTransitionPageTurn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionPageTurn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionPageTurn_class, JSPROXY_CCTransitionPageTurn_object, NULL);
	JSPROXY_CCTransitionPageTurn *proxy = [[JSPROXY_CCTransitionPageTurn alloc] initWithJSObject:jsobj class:[CCTransitionPageTurn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionRotoZoom
 */
#pragma mark - CCTransitionRotoZoom

JSClass* JSPROXY_CCTransitionRotoZoom_class = NULL;
JSObject* JSPROXY_CCTransitionRotoZoom_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionRotoZoom_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionRotoZoom createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionRotoZoom_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionRotoZoom)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionRotoZoom_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionRotoZoom *real = [(CCTransitionRotoZoom*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionRotoZoom* (o)
JSBool JSPROXY_CCTransitionRotoZoom_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionRotoZoom* ret_val;

	ret_val = [CCTransitionRotoZoom transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionRotoZoom* (o)
JSBool JSPROXY_CCTransitionRotoZoom_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionRotoZoom* ret_val;

	ret_val = [CCTransitionRotoZoom node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionRotoZoom_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionRotoZoom_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionRotoZoom_class->name = name;
	JSPROXY_CCTransitionRotoZoom_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionRotoZoom_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionRotoZoom_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionRotoZoom_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionRotoZoom_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionRotoZoom_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionRotoZoom_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionRotoZoom_class->finalize = JSPROXY_CCTransitionRotoZoom_finalize;
//	JSPROXY_CCTransitionRotoZoom_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionRotoZoom_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionRotoZoom_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionRotoZoom_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionRotoZoom_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionRotoZoom_class, JSPROXY_CCTransitionRotoZoom_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionRotoZoom

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionRotoZoom_class, JSPROXY_CCTransitionRotoZoom_object, NULL);
	JSPROXY_CCTransitionRotoZoom *proxy = [[JSPROXY_CCTransitionRotoZoom alloc] initWithJSObject:jsobj class:[CCTransitionRotoZoom class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeDown
 */
#pragma mark - CCTransitionFadeDown

JSClass* JSPROXY_CCTransitionFadeDown_class = NULL;
JSObject* JSPROXY_CCTransitionFadeDown_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFadeDown_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFadeDown createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFadeDown_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFadeDown)", obj);
}

// Arguments: ccGridSize
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionFadeDown_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionFadeDown *real = (CCTransitionFadeDown*) [proxy realObj];
	ret_val = [real actionWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeDown* (o)
JSBool JSPROXY_CCTransitionFadeDown_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionFadeDown* ret_val;

	ret_val = [CCTransitionFadeDown transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeDown* (o)
JSBool JSPROXY_CCTransitionFadeDown_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFadeDown* ret_val;

	ret_val = [CCTransitionFadeDown node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFadeDown_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFadeDown_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFadeDown_class->name = name;
	JSPROXY_CCTransitionFadeDown_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeDown_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeDown_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeDown_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFadeDown_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFadeDown_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFadeDown_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFadeDown_class->finalize = JSPROXY_CCTransitionFadeDown_finalize;
//	JSPROXY_CCTransitionFadeDown_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSPROXY_CCTransitionFadeDown_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionFadeDown_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFadeDown_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFadeDown_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionFadeTR_object, JSPROXY_CCTransitionFadeDown_class, JSPROXY_CCTransitionFadeDown_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFadeDown

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFadeDown_class, JSPROXY_CCTransitionFadeDown_object, NULL);
	JSPROXY_CCTransitionFadeDown *proxy = [[JSPROXY_CCTransitionFadeDown alloc] initWithJSObject:jsobj class:[CCTransitionFadeDown class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDelayTime
 */
#pragma mark - CCDelayTime

JSClass* JSPROXY_CCDelayTime_class = NULL;
JSObject* JSPROXY_CCDelayTime_object = NULL;
 // Constructor
JSBool JSPROXY_CCDelayTime_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCDelayTime createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCDelayTime_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCDelayTime)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCDelayTime_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCDelayTime *real = (CCDelayTime*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCDelayTime* (o)
JSBool JSPROXY_CCDelayTime_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCDelayTime* ret_val;

	ret_val = [CCDelayTime actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCDelayTime* (o)
JSBool JSPROXY_CCDelayTime_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCDelayTime* ret_val;

	ret_val = [CCDelayTime action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCDelayTime_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCDelayTime_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCDelayTime_class->name = name;
	JSPROXY_CCDelayTime_class->addProperty = JS_PropertyStub;
	JSPROXY_CCDelayTime_class->delProperty = JS_PropertyStub;
	JSPROXY_CCDelayTime_class->getProperty = JS_PropertyStub;
	JSPROXY_CCDelayTime_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCDelayTime_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCDelayTime_class->resolve = JS_ResolveStub;
	JSPROXY_CCDelayTime_class->convert = JS_ConvertStub;
	JSPROXY_CCDelayTime_class->finalize = JSPROXY_CCDelayTime_finalize;
//	JSPROXY_CCDelayTime_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCDelayTime_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCDelayTime_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCDelayTime_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCDelayTime_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCDelayTime_class, JSPROXY_CCDelayTime_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCDelayTime

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCDelayTime_class, JSPROXY_CCDelayTime_object, NULL);
	JSPROXY_CCDelayTime *proxy = [[JSPROXY_CCDelayTime alloc] initWithJSObject:jsobj class:[CCDelayTime class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseRateAction
 */
#pragma mark - CCEaseRateAction

JSClass* JSPROXY_CCEaseRateAction_class = NULL;
JSObject* JSPROXY_CCEaseRateAction_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseRateAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseRateAction createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseRateAction_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseRateAction)", obj);
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseRateAction* (o)
JSBool JSPROXY_CCEaseRateAction_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCEaseRateAction* ret_val;

	ret_val = [CCEaseRateAction actionWithAction:(CCActionInterval*)arg0 rate:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: None (None)
JSBool JSPROXY_CCEaseRateAction_initWithAction_rate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCEaseRateAction *real = [(CCEaseRateAction*)[proxy.klass alloc] initWithAction:(CCActionInterval*)arg0 rate:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCEaseRateAction_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCEaseRateAction *real = (CCEaseRateAction*) [proxy realObj];
	ret_val = [real rate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCEaseRateAction_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseRateAction *real = (CCEaseRateAction*) [proxy realObj];
	[real setRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseRateAction* (o)
JSBool JSPROXY_CCEaseRateAction_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseRateAction* ret_val;

	ret_val = [CCEaseRateAction actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseRateAction* (o)
JSBool JSPROXY_CCEaseRateAction_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseRateAction* ret_val;

	ret_val = [CCEaseRateAction actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseRateAction* (o)
JSBool JSPROXY_CCEaseRateAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseRateAction* ret_val;

	ret_val = [CCEaseRateAction action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseRateAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseRateAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseRateAction_class->name = name;
	JSPROXY_CCEaseRateAction_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseRateAction_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseRateAction_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseRateAction_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseRateAction_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseRateAction_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseRateAction_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseRateAction_class->finalize = JSPROXY_CCEaseRateAction_finalize;
//	JSPROXY_CCEaseRateAction_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionRate", JSPROXY_CCEaseRateAction_initWithAction_rate_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRate", JSPROXY_CCEaseRateAction_rate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRate", JSPROXY_CCEaseRateAction_setRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionRate", JSPROXY_CCEaseRateAction_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCEaseRateAction_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseRateAction_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseRateAction_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseRateAction_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseRateAction_class, JSPROXY_CCEaseRateAction_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseRateAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseRateAction_class, JSPROXY_CCEaseRateAction_object, NULL);
	JSPROXY_CCEaseRateAction *proxy = [[JSPROXY_CCEaseRateAction alloc] initWithJSObject:jsobj class:[CCEaseRateAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseInOut
 */
#pragma mark - CCEaseInOut

JSClass* JSPROXY_CCEaseInOut_class = NULL;
JSObject* JSPROXY_CCEaseInOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseInOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseInOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseInOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseInOut *real = (CCEaseInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseInOut* (o)
JSBool JSPROXY_CCEaseInOut_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCEaseInOut* ret_val;

	ret_val = [CCEaseInOut actionWithAction:(CCActionInterval*)arg0 rate:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseInOut* (o)
JSBool JSPROXY_CCEaseInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseInOut* ret_val;

	ret_val = [CCEaseInOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseInOut* (o)
JSBool JSPROXY_CCEaseInOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseInOut* ret_val;

	ret_val = [CCEaseInOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseInOut* (o)
JSBool JSPROXY_CCEaseInOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseInOut* ret_val;

	ret_val = [CCEaseInOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseInOut_class->name = name;
	JSPROXY_CCEaseInOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseInOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseInOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseInOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseInOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseInOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseInOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseInOut_class->finalize = JSPROXY_CCEaseInOut_finalize;
//	JSPROXY_CCEaseInOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseInOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseInOut_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithAction", JSPROXY_CCEaseInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseInOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseInOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseInOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseRateAction_object, JSPROXY_CCEaseInOut_class, JSPROXY_CCEaseInOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseInOut_class, JSPROXY_CCEaseInOut_object, NULL);
	JSPROXY_CCEaseInOut *proxy = [[JSPROXY_CCEaseInOut alloc] initWithJSObject:jsobj class:[CCEaseInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSplitCols
 */
#pragma mark - CCTransitionSplitCols

JSClass* JSPROXY_CCTransitionSplitCols_class = NULL;
JSObject* JSPROXY_CCTransitionSplitCols_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionSplitCols_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionSplitCols createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionSplitCols_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionSplitCols)", obj);
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionSplitCols_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionSplitCols *real = (CCTransitionSplitCols*) [proxy realObj];
	ret_val = [real action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionSplitCols_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionSplitCols *real = (CCTransitionSplitCols*) [proxy realObj];
	ret_val = [real easeActionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSplitCols* (o)
JSBool JSPROXY_CCTransitionSplitCols_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionSplitCols* ret_val;

	ret_val = [CCTransitionSplitCols transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSplitCols* (o)
JSBool JSPROXY_CCTransitionSplitCols_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionSplitCols* ret_val;

	ret_val = [CCTransitionSplitCols node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionSplitCols_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionSplitCols_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionSplitCols_class->name = name;
	JSPROXY_CCTransitionSplitCols_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSplitCols_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSplitCols_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSplitCols_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionSplitCols_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionSplitCols_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionSplitCols_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionSplitCols_class->finalize = JSPROXY_CCTransitionSplitCols_finalize;
//	JSPROXY_CCTransitionSplitCols_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSPROXY_CCTransitionSplitCols_action, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSPROXY_CCTransitionSplitCols_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionSplitCols_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionSplitCols_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionSplitCols_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionSplitCols_class, JSPROXY_CCTransitionSplitCols_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionSplitCols

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionSplitCols_class, JSPROXY_CCTransitionSplitCols_object, NULL);
	JSPROXY_CCTransitionSplitCols *proxy = [[JSPROXY_CCTransitionSplitCols alloc] initWithJSObject:jsobj class:[CCTransitionSplitCols class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCardinalSplineTo
 */
#pragma mark - CCCardinalSplineTo

JSClass* JSPROXY_CCCardinalSplineTo_class = NULL;
JSObject* JSPROXY_CCCardinalSplineTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCCardinalSplineTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCCardinalSplineTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCCardinalSplineTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCCardinalSplineTo)", obj);
}

// Arguments: ccTime, CCPointArray*, CGFloat
// Ret value: CCCardinalSplineTo* (o)
JSBool JSPROXY_CCCardinalSplineTo_actionWithDuration_points_tension__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCCardinalSplineTo* ret_val;

	ret_val = [CCCardinalSplineTo actionWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1 tension:(CGFloat)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCCardinalSplineTo_initWithDuration_points_tension_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCCardinalSplineTo *real = [(CCCardinalSplineTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1 tension:(CGFloat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCPointArray* (o)
JSBool JSPROXY_CCCardinalSplineTo_points(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCPointArray* ret_val;

	CCCardinalSplineTo *real = (CCCardinalSplineTo*) [proxy realObj];
	ret_val = [real points ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCPointArray*
// Ret value: void (None)
JSBool JSPROXY_CCCardinalSplineTo_setPoints_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCCardinalSplineTo *real = (CCCardinalSplineTo*) [proxy realObj];
	[real setPoints:(CCPointArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCCardinalSplineTo* (o)
JSBool JSPROXY_CCCardinalSplineTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCCardinalSplineTo* ret_val;

	ret_val = [CCCardinalSplineTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCardinalSplineTo* (o)
JSBool JSPROXY_CCCardinalSplineTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCCardinalSplineTo* ret_val;

	ret_val = [CCCardinalSplineTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCCardinalSplineTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCCardinalSplineTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCCardinalSplineTo_class->name = name;
	JSPROXY_CCCardinalSplineTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCCardinalSplineTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCCardinalSplineTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCCardinalSplineTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCCardinalSplineTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCCardinalSplineTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCCardinalSplineTo_class->convert = JS_ConvertStub;
	JSPROXY_CCCardinalSplineTo_class->finalize = JSPROXY_CCCardinalSplineTo_finalize;
//	JSPROXY_CCCardinalSplineTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPointsTension", JSPROXY_CCCardinalSplineTo_initWithDuration_points_tension_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("points", JSPROXY_CCCardinalSplineTo_points, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPoints", JSPROXY_CCCardinalSplineTo_setPoints_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCCardinalSplineTo_actionWithDuration_points_tension__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCCardinalSplineTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCCardinalSplineTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCCardinalSplineTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCCardinalSplineTo_class, JSPROXY_CCCardinalSplineTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCCardinalSplineTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCCardinalSplineTo_class, JSPROXY_CCCardinalSplineTo_object, NULL);
	JSPROXY_CCCardinalSplineTo *proxy = [[JSPROXY_CCCardinalSplineTo alloc] initWithJSObject:jsobj class:[CCCardinalSplineTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCardinalSplineBy
 */
#pragma mark - CCCardinalSplineBy

JSClass* JSPROXY_CCCardinalSplineBy_class = NULL;
JSObject* JSPROXY_CCCardinalSplineBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCCardinalSplineBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCCardinalSplineBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCCardinalSplineBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCCardinalSplineBy)", obj);
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCCardinalSplineBy_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCCardinalSplineBy *real = (CCCardinalSplineBy*) [proxy realObj];
	[real startWithTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*, CGFloat
// Ret value: CCCardinalSplineBy* (o)
JSBool JSPROXY_CCCardinalSplineBy_actionWithDuration_points_tension__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCCardinalSplineBy* ret_val;

	ret_val = [CCCardinalSplineBy actionWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1 tension:(CGFloat)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCCardinalSplineBy* (o)
JSBool JSPROXY_CCCardinalSplineBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCCardinalSplineBy* ret_val;

	ret_val = [CCCardinalSplineBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCardinalSplineBy* (o)
JSBool JSPROXY_CCCardinalSplineBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCCardinalSplineBy* ret_val;

	ret_val = [CCCardinalSplineBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCCardinalSplineBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCCardinalSplineBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCCardinalSplineBy_class->name = name;
	JSPROXY_CCCardinalSplineBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCCardinalSplineBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCCardinalSplineBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCCardinalSplineBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCCardinalSplineBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCCardinalSplineBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCCardinalSplineBy_class->convert = JS_ConvertStub;
	JSPROXY_CCCardinalSplineBy_class->finalize = JSPROXY_CCCardinalSplineBy_finalize;
//	JSPROXY_CCCardinalSplineBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSPROXY_CCCardinalSplineBy_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCCardinalSplineBy_actionWithDuration_points_tension__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCCardinalSplineBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCCardinalSplineBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCCardinalSplineBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCCardinalSplineTo_object, JSPROXY_CCCardinalSplineBy_class, JSPROXY_CCCardinalSplineBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCCardinalSplineBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCCardinalSplineBy_class, JSPROXY_CCCardinalSplineBy_object, NULL);
	JSPROXY_CCCardinalSplineBy *proxy = [[JSPROXY_CCCardinalSplineBy alloc] initWithJSObject:jsobj class:[CCCardinalSplineBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCatmullRomBy
 */
#pragma mark - CCCatmullRomBy

JSClass* JSPROXY_CCCatmullRomBy_class = NULL;
JSObject* JSPROXY_CCCatmullRomBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCCatmullRomBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCCatmullRomBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCCatmullRomBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCCatmullRomBy)", obj);
}

// Arguments: ccTime, CCPointArray*
// Ret value: CCCatmullRomBy* (o)
JSBool JSPROXY_CCCatmullRomBy_actionWithDuration_points__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCCatmullRomBy* ret_val;

	ret_val = [CCCatmullRomBy actionWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*
// Ret value: None (None)
JSBool JSPROXY_CCCatmullRomBy_initWithDuration_points_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCCatmullRomBy *real = [(CCCatmullRomBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*, CGFloat
// Ret value: CCCatmullRomBy* (o)
JSBool JSPROXY_CCCatmullRomBy_actionWithDuration_points_tension__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCCatmullRomBy* ret_val;

	ret_val = [CCCatmullRomBy actionWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1 tension:(CGFloat)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCCatmullRomBy* (o)
JSBool JSPROXY_CCCatmullRomBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCCatmullRomBy* ret_val;

	ret_val = [CCCatmullRomBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCatmullRomBy* (o)
JSBool JSPROXY_CCCatmullRomBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCCatmullRomBy* ret_val;

	ret_val = [CCCatmullRomBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCCatmullRomBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCCatmullRomBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCCatmullRomBy_class->name = name;
	JSPROXY_CCCatmullRomBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCCatmullRomBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCCatmullRomBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCCatmullRomBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCCatmullRomBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCCatmullRomBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCCatmullRomBy_class->convert = JS_ConvertStub;
	JSPROXY_CCCatmullRomBy_class->finalize = JSPROXY_CCCatmullRomBy_finalize;
//	JSPROXY_CCCatmullRomBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPoints", JSPROXY_CCCatmullRomBy_initWithDuration_points_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCCatmullRomBy_actionWithDuration_points__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDurationPointsTension", JSPROXY_CCCatmullRomBy_actionWithDuration_points_tension__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCCatmullRomBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCCatmullRomBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCCatmullRomBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCCardinalSplineBy_object, JSPROXY_CCCatmullRomBy_class, JSPROXY_CCCatmullRomBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCCatmullRomBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCCatmullRomBy_class, JSPROXY_CCCatmullRomBy_object, NULL);
	JSPROXY_CCCatmullRomBy *proxy = [[JSPROXY_CCCatmullRomBy alloc] initWithJSObject:jsobj class:[CCCatmullRomBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFlipAngular
 */
#pragma mark - CCTransitionFlipAngular

JSClass* JSPROXY_CCTransitionFlipAngular_class = NULL;
JSObject* JSPROXY_CCTransitionFlipAngular_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFlipAngular_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFlipAngular createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFlipAngular_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFlipAngular)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionFlipAngular_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionFlipAngular *real = [(CCTransitionFlipAngular*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionFlipAngular* (o)
JSBool JSPROXY_CCTransitionFlipAngular_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTransitionFlipAngular* ret_val;

	ret_val = [CCTransitionFlipAngular transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFlipAngular* (o)
JSBool JSPROXY_CCTransitionFlipAngular_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionFlipAngular* ret_val;

	ret_val = [CCTransitionFlipAngular transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFlipAngular* (o)
JSBool JSPROXY_CCTransitionFlipAngular_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFlipAngular* ret_val;

	ret_val = [CCTransitionFlipAngular node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFlipAngular_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFlipAngular_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFlipAngular_class->name = name;
	JSPROXY_CCTransitionFlipAngular_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipAngular_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipAngular_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipAngular_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFlipAngular_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFlipAngular_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFlipAngular_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFlipAngular_class->finalize = JSPROXY_CCTransitionFlipAngular_finalize;
//	JSPROXY_CCTransitionFlipAngular_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionFlipAngular_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSPROXY_CCTransitionFlipAngular_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTransitionFlipAngular_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFlipAngular_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFlipAngular_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSceneOriented_object, JSPROXY_CCTransitionFlipAngular_class, JSPROXY_CCTransitionFlipAngular_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFlipAngular

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFlipAngular_class, JSPROXY_CCTransitionFlipAngular_object, NULL);
	JSPROXY_CCTransitionFlipAngular *proxy = [[JSPROXY_CCTransitionFlipAngular alloc] initWithJSObject:jsobj class:[CCTransitionFlipAngular class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCHide
 */
#pragma mark - CCHide

JSClass* JSPROXY_CCHide_class = NULL;
JSObject* JSPROXY_CCHide_object = NULL;
 // Constructor
JSBool JSPROXY_CCHide_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCHide createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCHide_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCHide)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCHide_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCHide *real = (CCHide*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCHide* (o)
JSBool JSPROXY_CCHide_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCHide* ret_val;

	ret_val = [CCHide action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCHide_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCHide_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCHide_class->name = name;
	JSPROXY_CCHide_class->addProperty = JS_PropertyStub;
	JSPROXY_CCHide_class->delProperty = JS_PropertyStub;
	JSPROXY_CCHide_class->getProperty = JS_PropertyStub;
	JSPROXY_CCHide_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCHide_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCHide_class->resolve = JS_ResolveStub;
	JSPROXY_CCHide_class->convert = JS_ConvertStub;
	JSPROXY_CCHide_class->finalize = JSPROXY_CCHide_finalize;
//	JSPROXY_CCHide_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCHide_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCHide_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCHide_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCHide_class, JSPROXY_CCHide_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCHide

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCHide_class, JSPROXY_CCHide_object, NULL);
	JSPROXY_CCHide *proxy = [[JSPROXY_CCHide alloc] initWithJSObject:jsobj class:[CCHide class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBackIn
 */
#pragma mark - CCEaseBackIn

JSClass* JSPROXY_CCEaseBackIn_class = NULL;
JSObject* JSPROXY_CCEaseBackIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseBackIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseBackIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseBackIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseBackIn)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseBackIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseBackIn *real = (CCEaseBackIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBackIn* (o)
JSBool JSPROXY_CCEaseBackIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseBackIn* ret_val;

	ret_val = [CCEaseBackIn actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseBackIn* (o)
JSBool JSPROXY_CCEaseBackIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseBackIn* ret_val;

	ret_val = [CCEaseBackIn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseBackIn* (o)
JSBool JSPROXY_CCEaseBackIn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseBackIn* ret_val;

	ret_val = [CCEaseBackIn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseBackIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseBackIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseBackIn_class->name = name;
	JSPROXY_CCEaseBackIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseBackIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseBackIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseBackIn_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseBackIn_class->finalize = JSPROXY_CCEaseBackIn_finalize;
//	JSPROXY_CCEaseBackIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseBackIn_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseBackIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseBackIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseBackIn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseBackIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseBackIn_class, JSPROXY_CCEaseBackIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseBackIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseBackIn_class, JSPROXY_CCEaseBackIn_object, NULL);
	JSPROXY_CCEaseBackIn *proxy = [[JSPROXY_CCEaseBackIn alloc] initWithJSObject:jsobj class:[CCEaseBackIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpriteBatchNode
 */
#pragma mark - CCSpriteBatchNode

JSClass* JSPROXY_CCSpriteBatchNode_class = NULL;
JSObject* JSPROXY_CCSpriteBatchNode_object = NULL;
 // Constructor
JSBool JSPROXY_CCSpriteBatchNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSpriteBatchNode createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSpriteBatchNode_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSpriteBatchNode)", obj);
}

// Arguments: CCSprite*, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_addQuadFromSprite_quadIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real addQuadFromSprite:(CCSprite*)arg0 quadIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_appendChild_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real appendChild:(CCSprite*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSprite*, NSInteger
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCSpriteBatchNode_atlasIndexForChild_atZ_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	NSUInteger ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real atlasIndexForChild:(CCSprite*)arg0 atZ:(NSInteger)arg1  ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCSpriteBatchNode* (o)
JSBool JSPROXY_CCSpriteBatchNode_batchNodeWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCSpriteBatchNode* ret_val;

	if( argc == 1 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCSpriteBatchNode* (o)
JSBool JSPROXY_CCSpriteBatchNode_batchNodeWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if (argc >= 2) {
		ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCSpriteBatchNode* ret_val;

	if( argc == 1 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithTexture:(CCTexture2D*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCSpriteBatchNode batchNodeWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccBlendFunc ({_ccBlendFunc=II})
JSBool JSPROXY_CCSpriteBatchNode_blendFunc(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccBlendFunc ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real blendFunc ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT32, 2 );
	ccBlendFunc* buffer = (ccBlendFunc*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCArray* (array)
JSBool JSPROXY_CCSpriteBatchNode_descendants(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCArray* ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real descendants ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_increaseAtlasCapacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real increaseAtlasCapacity ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCSpriteBatchNode_initWithFile_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = [(CCSpriteBatchNode*)[proxy.klass alloc] initWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCSpriteBatchNode_initWithTexture_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = [(CCSpriteBatchNode*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSprite*, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_insertChild_inAtlasAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real insertChild:(CCSprite*)arg0 inAtlasAtIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSprite*, NSUInteger
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCSpriteBatchNode_rebuildIndexInOrder_atlasIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	NSUInteger ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real rebuildIndexInOrder:(CCSprite*)arg0 atlasIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCSprite*, BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_removeChild_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; JSBool arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real removeChild:(CCSprite*)arg0 cleanup:(BOOL)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger, BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_removeChildAtIndex_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; JSBool arg1; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real removeChildAtIndex:(NSUInteger)arg0 cleanup:(BOOL)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_removeSpriteFromAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real removeSpriteFromAtlas:(CCSprite*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_reorderBatch_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real reorderBatch:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccBlendFunc
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_setBlendFunc_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccBlendFunc arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccBlendFunc*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real setBlendFunc:(ccBlendFunc)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real setTextureAtlas:(CCTextureAtlas*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSPROXY_CCSpriteBatchNode_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteBatchNode_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCSpriteBatchNode_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCSpriteBatchNode *real = (CCSpriteBatchNode*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteBatchNode* (o)
JSBool JSPROXY_CCSpriteBatchNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSpriteBatchNode* ret_val;

	ret_val = [CCSpriteBatchNode node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSpriteBatchNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSpriteBatchNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSpriteBatchNode_class->name = name;
	JSPROXY_CCSpriteBatchNode_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSpriteBatchNode_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSpriteBatchNode_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSpriteBatchNode_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSpriteBatchNode_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSpriteBatchNode_class->resolve = JS_ResolveStub;
	JSPROXY_CCSpriteBatchNode_class->convert = JS_ConvertStub;
	JSPROXY_CCSpriteBatchNode_class->finalize = JSPROXY_CCSpriteBatchNode_finalize;
//	JSPROXY_CCSpriteBatchNode_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addQuadFromSpriteQuadIndex", JSPROXY_CCSpriteBatchNode_addQuadFromSprite_quadIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("appendChild", JSPROXY_CCSpriteBatchNode_appendChild_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("atlasIndexForChildAtZ", JSPROXY_CCSpriteBatchNode_atlasIndexForChild_atZ_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getBlendFunc", JSPROXY_CCSpriteBatchNode_blendFunc, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getDescendants", JSPROXY_CCSpriteBatchNode_descendants, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("increaseAtlasCapacity", JSPROXY_CCSpriteBatchNode_increaseAtlasCapacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFileCapacity", JSPROXY_CCSpriteBatchNode_initWithFile_capacity_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureCapacity", JSPROXY_CCSpriteBatchNode_initWithTexture_capacity_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("insertChildInAtlasAtIndex", JSPROXY_CCSpriteBatchNode_insertChild_inAtlasAtIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("rebuildIndexInOrderAtlasIndex", JSPROXY_CCSpriteBatchNode_rebuildIndexInOrder_atlasIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeChildCleanup", JSPROXY_CCSpriteBatchNode_removeChild_cleanup_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeChildAtIndexCleanup", JSPROXY_CCSpriteBatchNode_removeChildAtIndex_cleanup_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFromAtlas", JSPROXY_CCSpriteBatchNode_removeSpriteFromAtlas_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reorderBatch", JSPROXY_CCSpriteBatchNode_reorderBatch_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSPROXY_CCSpriteBatchNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSPROXY_CCSpriteBatchNode_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSPROXY_CCSpriteBatchNode_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCSpriteBatchNode_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCSpriteBatchNode_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCSpriteBatchNode_batchNodeWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("createWithTexture", JSPROXY_CCSpriteBatchNode_batchNodeWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCSpriteBatchNode_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSpriteBatchNode_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCSpriteBatchNode_class, JSPROXY_CCSpriteBatchNode_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSpriteBatchNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSpriteBatchNode_class, JSPROXY_CCSpriteBatchNode_object, NULL);
	JSPROXY_CCSpriteBatchNode *proxy = [[JSPROXY_CCSpriteBatchNode alloc] initWithJSObject:jsobj class:[CCSpriteBatchNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXLayer
 */
#pragma mark - CCTMXLayer

JSClass* JSPROXY_CCTMXLayer_class = NULL;
JSObject* JSPROXY_CCTMXLayer_object = NULL;
 // Constructor
JSBool JSPROXY_CCTMXLayer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTMXLayer createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTMXLayer_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTMXLayer)", obj);
}

// Arguments: CCNode*, NSInteger, NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_addChild_z_tag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; int32_t arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real addChild:(CCNode*)arg0 z:(NSInteger)arg1 tag:(NSInteger)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTMXTilesetInfo*, CCTMXLayerInfo*, CCTMXMapInfo*
// Ret value: None (None)
JSBool JSPROXY_CCTMXLayer_initWithTilesetInfo_layerInfo_mapInfo_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; id arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg2);
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = [(CCTMXLayer*)[proxy.klass alloc] initWithTilesetInfo:(CCTMXTilesetInfo*)arg0 layerInfo:(CCTMXLayerInfo*)arg1 mapInfo:(CCTMXMapInfo*)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTMXLayer_layerName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real layerName ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTMXLayer_layerOrientation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real layerOrientation ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXLayer_layerSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real layerSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: CCTMXTilesetInfo*, CCTMXLayerInfo*, CCTMXMapInfo*
// Ret value: CCTMXLayer* (o)
JSBool JSPROXY_CCTMXLayer_layerWithTilesetInfo_layerInfo_mapInfo__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; id arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg2);
	if( ! ok ) return JS_FALSE;
	CCTMXLayer* ret_val;

	ret_val = [CCTMXLayer layerWithTilesetInfo:(CCTMXTilesetInfo*)arg0 layerInfo:(CCTMXLayerInfo*)arg1 mapInfo:(CCTMXMapInfo*)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXLayer_mapTileSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real mapTileSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCTMXLayer_positionAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CGPoint ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real positionAt:(CGPoint)arg0  ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCTMXLayer_properties(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real properties ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_releaseMap(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real releaseMap ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_removeTileAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real removeTileAt:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setLayerName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setLayerName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setLayerOrientation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setLayerOrientation:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setLayerSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setLayerSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setMapTileSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setMapTileSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setProperties_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setProperties:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: uint32_t, CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setTileGID_at_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; CGPoint arg1; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setTileGID:(uint32_t)arg0 at:(CGPoint)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: uint32_t, CGPoint, ccTMXTileFlags
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setTileGID_at_withFlags_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; CGPoint arg1; int32_t arg2; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setTileGID:(uint32_t)arg0 at:(CGPoint)arg1 withFlags:(ccTMXTileFlags)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTMXTilesetInfo*
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setTileset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setTileset:(CCTMXTilesetInfo*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayer_setupTiles(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	[real setupTiles ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: CCSprite* (o)
JSBool JSPROXY_CCTMXLayer_tileAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSprite* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real tileAt:(CGPoint)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: uint32_t (u)
JSBool JSPROXY_CCTMXLayer_tileGIDAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	uint32_t ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real tileGIDAt:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTMXTilesetInfo* (o)
JSBool JSPROXY_CCTMXLayer_tileset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTMXTilesetInfo* ret_val;

	CCTMXLayer *real = (CCTMXLayer*) [proxy realObj];
	ret_val = [real tileset ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXLayer* (o)
JSBool JSPROXY_CCTMXLayer_batchNodeWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTMXLayer* ret_val;

	ret_val = [CCTMXLayer batchNodeWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCTMXLayer* (o)
JSBool JSPROXY_CCTMXLayer_batchNodeWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTMXLayer* ret_val;

	ret_val = [CCTMXLayer batchNodeWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: CCTMXLayer* (o)
JSBool JSPROXY_CCTMXLayer_batchNodeWithTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCTMXLayer* ret_val;

	ret_val = [CCTMXLayer batchNodeWithTexture:(CCTexture2D*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCTMXLayer* (o)
JSBool JSPROXY_CCTMXLayer_batchNodeWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTMXLayer* ret_val;

	ret_val = [CCTMXLayer batchNodeWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTMXLayer* (o)
JSBool JSPROXY_CCTMXLayer_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTMXLayer* ret_val;

	ret_val = [CCTMXLayer node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTMXLayer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTMXLayer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTMXLayer_class->name = name;
	JSPROXY_CCTMXLayer_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTMXLayer_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTMXLayer_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTMXLayer_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTMXLayer_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTMXLayer_class->resolve = JS_ResolveStub;
	JSPROXY_CCTMXLayer_class->convert = JS_ConvertStub;
	JSPROXY_CCTMXLayer_class->finalize = JSPROXY_CCTMXLayer_finalize;
//	JSPROXY_CCTMXLayer_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addChildZTag", JSPROXY_CCTMXLayer_addChild_z_tag_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTilesetInfoLayerInfoMapInfo", JSPROXY_CCTMXLayer_initWithTilesetInfo_layerInfo_mapInfo_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLayerName", JSPROXY_CCTMXLayer_layerName, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLayerOrientation", JSPROXY_CCTMXLayer_layerOrientation, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLayerSize", JSPROXY_CCTMXLayer_layerSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMapTileSize", JSPROXY_CCTMXLayer_mapTileSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("positionAt", JSPROXY_CCTMXLayer_positionAt_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getProperties", JSPROXY_CCTMXLayer_properties, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("releaseMap", JSPROXY_CCTMXLayer_releaseMap, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeTileAt", JSPROXY_CCTMXLayer_removeTileAt_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLayerName", JSPROXY_CCTMXLayer_setLayerName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLayerOrientation", JSPROXY_CCTMXLayer_setLayerOrientation_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLayerSize", JSPROXY_CCTMXLayer_setLayerSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMapTileSize", JSPROXY_CCTMXLayer_setMapTileSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setProperties", JSPROXY_CCTMXLayer_setProperties_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTileGID", JSPROXY_CCTMXLayer_setTileGID_at_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTileGIDAtWithFlags", JSPROXY_CCTMXLayer_setTileGID_at_withFlags_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTileset", JSPROXY_CCTMXLayer_setTileset_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setupTiles", JSPROXY_CCTMXLayer_setupTiles, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("tileAt", JSPROXY_CCTMXLayer_tileAt_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("tileGIDAt", JSPROXY_CCTMXLayer_tileGIDAt_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTileset", JSPROXY_CCTMXLayer_tileset, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("layerWithTilesetInfoLayerInfoMapInfo", JSPROXY_CCTMXLayer_layerWithTilesetInfo_layerInfo_mapInfo__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithFile", JSPROXY_CCTMXLayer_batchNodeWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithFileCapacity", JSPROXY_CCTMXLayer_batchNodeWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithTexture", JSPROXY_CCTMXLayer_batchNodeWithTexture__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithTextureCapacity", JSPROXY_CCTMXLayer_batchNodeWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTMXLayer_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTMXLayer_object = JS_InitClass(cx, globalObj, JSPROXY_CCSpriteBatchNode_object, JSPROXY_CCTMXLayer_class, JSPROXY_CCTMXLayer_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTMXLayer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTMXLayer_class, JSPROXY_CCTMXLayer_object, NULL);
	JSPROXY_CCTMXLayer *proxy = [[JSPROXY_CCTMXLayer alloc] initWithJSObject:jsobj class:[CCTMXLayer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTexture2D
 */
#pragma mark - CCTexture2D

JSClass* JSPROXY_CCTexture2D_class = NULL;
JSObject* JSPROXY_CCTexture2D_object = NULL;
 // Constructor
JSBool JSPROXY_CCTexture2D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTexture2D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTexture2D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTexture2D)", obj);
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_PVRImagesHavePremultipliedAlpha__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	[CCTexture2D PVRImagesHavePremultipliedAlpha:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTexture2D_bitsPerPixelForFormat(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real bitsPerPixelForFormat ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCTexture2DPixelFormat
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTexture2D_bitsPerPixelForFormat__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	NSUInteger ret_val;

	ret_val = [CCTexture2D bitsPerPixelForFormat:(CCTexture2DPixelFormat)arg0  ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTexture2D_contentSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real contentSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTexture2D_contentSizeInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real contentSizeInPixels ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2DPixelFormat (i)
JSBool JSPROXY_CCTexture2D_defaultAlphaPixelFormat_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2DPixelFormat ret_val;

	ret_val = [CCTexture2D defaultAlphaPixelFormat ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_drawAtPoint_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real drawAtPoint:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_drawInRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real drawInRect:(CGRect)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_generateMipmap(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real generateMipmap ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCTexture2D_hasPremultipliedAlpha(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real hasPremultipliedAlpha ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCTexture2D_initWithPVRFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithPVRFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCVerticalTextAlignment, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCTexture2D_initWithString_dimensions_hAlignment_vAlignment_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; NSString* arg4; double arg5; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 vAlignment:(CCVerticalTextAlignment)arg3 fontName:(NSString*)arg4 fontSize:(CGFloat)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGSize, CCTextAlignment, CCVerticalTextAlignment, CCLineBreakMode, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCTexture2D_initWithString_dimensions_hAlignment_vAlignment_lineBreakMode_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 7, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGSize arg1; int32_t arg2; int32_t arg3; int32_t arg4; NSString* arg5; double arg6; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg4 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithString:(NSString*)arg0 dimensions:(CGSize)arg1 hAlignment:(CCTextAlignment)arg2 vAlignment:(CCVerticalTextAlignment)arg3 lineBreakMode:(CCLineBreakMode)arg4 fontName:(NSString*)arg5 fontSize:(CGFloat)arg6  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, CGFloat
// Ret value: None (None)
JSBool JSPROXY_CCTexture2D_initWithString_fontName_fontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = [(CCTexture2D*)[proxy.klass alloc] initWithString:(NSString*)arg0 fontName:(NSString*)arg1 fontSize:(CGFloat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLfloat (d)
JSBool JSPROXY_CCTexture2D_maxS(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLfloat ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real maxS ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLfloat (d)
JSBool JSPROXY_CCTexture2D_maxT(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLfloat ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real maxT ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLuint (u)
JSBool JSPROXY_CCTexture2D_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLuint ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real name ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2DPixelFormat (i)
JSBool JSPROXY_CCTexture2D_pixelFormat(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2DPixelFormat ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real pixelFormat ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTexture2D_pixelsHigh(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real pixelsHigh ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTexture2D_pixelsWide(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real pixelsWide ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_setAliasTexParameters(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setAliasTexParameters ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_setAntiAliasTexParameters(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setAntiAliasTexParameters ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2DPixelFormat
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_setDefaultAlphaPixelFormat__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	[CCTexture2D setDefaultAlphaPixelFormat:(CCTexture2DPixelFormat)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_setMaxS_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setMaxS:(GLfloat)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_setMaxT_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setMaxT:(GLfloat)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccResolutionType
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_setResolutionType_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setResolutionType:(ccResolutionType)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCGLProgram*
// Ret value: void (None)
JSBool JSPROXY_CCTexture2D_setShaderProgram_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	[real setShaderProgram:(CCGLProgram*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGLProgram* (o)
JSBool JSPROXY_CCTexture2D_shaderProgram(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGLProgram* ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real shaderProgram ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTexture2D_stringForFormat(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTexture2D *real = (CCTexture2D*) [proxy realObj];
	ret_val = [real stringForFormat ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

void JSPROXY_CCTexture2D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTexture2D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTexture2D_class->name = name;
	JSPROXY_CCTexture2D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTexture2D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTexture2D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTexture2D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTexture2D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTexture2D_class->resolve = JS_ResolveStub;
	JSPROXY_CCTexture2D_class->convert = JS_ConvertStub;
	JSPROXY_CCTexture2D_class->finalize = JSPROXY_CCTexture2D_finalize;
//	JSPROXY_CCTexture2D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("bitsPerPixelForFormat", JSPROXY_CCTexture2D_bitsPerPixelForFormat, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("contentSize", JSPROXY_CCTexture2D_contentSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getContentSizeInPixels", JSPROXY_CCTexture2D_contentSizeInPixels, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawAtPoint", JSPROXY_CCTexture2D_drawAtPoint_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawInRect", JSPROXY_CCTexture2D_drawInRect_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("generateMipmap", JSPROXY_CCTexture2D_generateMipmap, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getHasPremultipliedAlpha", JSPROXY_CCTexture2D_hasPremultipliedAlpha, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithPVRFile", JSPROXY_CCTexture2D_initWithPVRFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringDimensionsHAlignmentVAlignmentFontNameFontSize", JSPROXY_CCTexture2D_initWithString_dimensions_hAlignment_vAlignment_fontName_fontSize_, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringDimensionsHAlignmentVAlignmentLineBreakModeFontNameFontSize", JSPROXY_CCTexture2D_initWithString_dimensions_hAlignment_vAlignment_lineBreakMode_fontName_fontSize_, 7, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringFontNameFontSize", JSPROXY_CCTexture2D_initWithString_fontName_fontSize_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMaxS", JSPROXY_CCTexture2D_maxS, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMaxT", JSPROXY_CCTexture2D_maxT, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getName", JSPROXY_CCTexture2D_name, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPixelFormat", JSPROXY_CCTexture2D_pixelFormat, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPixelsHigh", JSPROXY_CCTexture2D_pixelsHigh, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPixelsWide", JSPROXY_CCTexture2D_pixelsWide, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAliasTexParameters", JSPROXY_CCTexture2D_setAliasTexParameters, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAntiAliasTexParameters", JSPROXY_CCTexture2D_setAntiAliasTexParameters, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMaxS", JSPROXY_CCTexture2D_setMaxS_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMaxT", JSPROXY_CCTexture2D_setMaxT_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setResolutionType", JSPROXY_CCTexture2D_setResolutionType_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setShaderProgram", JSPROXY_CCTexture2D_setShaderProgram_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexParameters", JSPROXY_CCTexture2D_setTexParameters_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getShaderProgram", JSPROXY_CCTexture2D_shaderProgram, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("stringForFormat", JSPROXY_CCTexture2D_stringForFormat, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("PVRImagesHavePremultipliedAlpha", JSPROXY_CCTexture2D_PVRImagesHavePremultipliedAlpha__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("bitsPerPixelForFormat", JSPROXY_CCTexture2D_bitsPerPixelForFormat__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("defaultAlphaPixelFormat", JSPROXY_CCTexture2D_defaultAlphaPixelFormat_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDefaultAlphaPixelFormat", JSPROXY_CCTexture2D_setDefaultAlphaPixelFormat__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTexture2D_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTexture2D_class, JSPROXY_CCTexture2D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTexture2D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTexture2D_class, JSPROXY_CCTexture2D_object, NULL);
	JSPROXY_CCTexture2D *proxy = [[JSPROXY_CCTexture2D alloc] initWithJSObject:jsobj class:[CCTexture2D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAccelDeccelAmplitude
 */
#pragma mark - CCAccelDeccelAmplitude

JSClass* JSPROXY_CCAccelDeccelAmplitude_class = NULL;
JSObject* JSPROXY_CCAccelDeccelAmplitude_object = NULL;
 // Constructor
JSBool JSPROXY_CCAccelDeccelAmplitude_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAccelDeccelAmplitude createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAccelDeccelAmplitude_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAccelDeccelAmplitude)", obj);
}

// Arguments: CCAction*, ccTime
// Ret value: CCAccelDeccelAmplitude* (o)
JSBool JSPROXY_CCAccelDeccelAmplitude_actionWithAction_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCAccelDeccelAmplitude* ret_val;

	ret_val = [CCAccelDeccelAmplitude actionWithAction:(CCAction*)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCAccelDeccelAmplitude_initWithAction_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCAccelDeccelAmplitude *real = [(CCAccelDeccelAmplitude*)[proxy.klass alloc] initWithAction:(CCAction*)arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCAccelDeccelAmplitude_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCAccelDeccelAmplitude *real = (CCAccelDeccelAmplitude*) [proxy realObj];
	ret_val = [real rate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCAccelDeccelAmplitude_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAccelDeccelAmplitude *real = (CCAccelDeccelAmplitude*) [proxy realObj];
	[real setRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCAccelDeccelAmplitude* (o)
JSBool JSPROXY_CCAccelDeccelAmplitude_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCAccelDeccelAmplitude* ret_val;

	ret_val = [CCAccelDeccelAmplitude actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAccelDeccelAmplitude* (o)
JSBool JSPROXY_CCAccelDeccelAmplitude_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCAccelDeccelAmplitude* ret_val;

	ret_val = [CCAccelDeccelAmplitude action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCAccelDeccelAmplitude_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAccelDeccelAmplitude_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAccelDeccelAmplitude_class->name = name;
	JSPROXY_CCAccelDeccelAmplitude_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAccelDeccelAmplitude_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAccelDeccelAmplitude_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAccelDeccelAmplitude_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAccelDeccelAmplitude_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAccelDeccelAmplitude_class->resolve = JS_ResolveStub;
	JSPROXY_CCAccelDeccelAmplitude_class->convert = JS_ConvertStub;
	JSPROXY_CCAccelDeccelAmplitude_class->finalize = JSPROXY_CCAccelDeccelAmplitude_finalize;
//	JSPROXY_CCAccelDeccelAmplitude_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionDuration", JSPROXY_CCAccelDeccelAmplitude_initWithAction_duration_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRate", JSPROXY_CCAccelDeccelAmplitude_rate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRate", JSPROXY_CCAccelDeccelAmplitude_setRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionDuration", JSPROXY_CCAccelDeccelAmplitude_actionWithAction_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCAccelDeccelAmplitude_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCAccelDeccelAmplitude_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCAccelDeccelAmplitude_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCAccelDeccelAmplitude_class, JSPROXY_CCAccelDeccelAmplitude_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAccelDeccelAmplitude

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAccelDeccelAmplitude_class, JSPROXY_CCAccelDeccelAmplitude_object, NULL);
	JSPROXY_CCAccelDeccelAmplitude *proxy = [[JSPROXY_CCAccelDeccelAmplitude alloc] initWithJSObject:jsobj class:[CCAccelDeccelAmplitude class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCJumpTiles3D
 */
#pragma mark - CCJumpTiles3D

JSClass* JSPROXY_CCJumpTiles3D_class = NULL;
JSObject* JSPROXY_CCJumpTiles3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCJumpTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCJumpTiles3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCJumpTiles3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCJumpTiles3D)", obj);
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: CCJumpTiles3D* (o)
JSBool JSPROXY_CCJumpTiles3D_actionWithJumps_amplitude_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCJumpTiles3D* ret_val;

	ret_val = [CCJumpTiles3D actionWithJumps:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCJumpTiles3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	ret_val = [real amplitude ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCJumpTiles3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCJumpTiles3D_initWithJumps_amplitude_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCJumpTiles3D *real = [(CCJumpTiles3D*)[proxy.klass alloc] initWithJumps:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCJumpTiles3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCJumpTiles3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCJumpTiles3D *real = (CCJumpTiles3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCJumpTiles3D* (o)
JSBool JSPROXY_CCJumpTiles3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCJumpTiles3D* ret_val;

	ret_val = [CCJumpTiles3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCJumpTiles3D* (o)
JSBool JSPROXY_CCJumpTiles3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCJumpTiles3D* ret_val;

	ret_val = [CCJumpTiles3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCJumpTiles3D* (o)
JSBool JSPROXY_CCJumpTiles3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCJumpTiles3D* ret_val;

	ret_val = [CCJumpTiles3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCJumpTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCJumpTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCJumpTiles3D_class->name = name;
	JSPROXY_CCJumpTiles3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCJumpTiles3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCJumpTiles3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCJumpTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCJumpTiles3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCJumpTiles3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCJumpTiles3D_class->convert = JS_ConvertStub;
	JSPROXY_CCJumpTiles3D_class->finalize = JSPROXY_CCJumpTiles3D_finalize;
//	JSPROXY_CCJumpTiles3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSPROXY_CCJumpTiles3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSPROXY_CCJumpTiles3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithJumpsAmplitudeGridDuration", JSPROXY_CCJumpTiles3D_initWithJumps_amplitude_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSPROXY_CCJumpTiles3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSPROXY_CCJumpTiles3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithJumpsAmplitudeGridDuration", JSPROXY_CCJumpTiles3D_actionWithJumps_amplitude_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCJumpTiles3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCJumpTiles3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCJumpTiles3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCJumpTiles3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCJumpTiles3D_class, JSPROXY_CCJumpTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCJumpTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCJumpTiles3D_class, JSPROXY_CCJumpTiles3D_object, NULL);
	JSPROXY_CCJumpTiles3D *proxy = [[JSPROXY_CCJumpTiles3D alloc] initWithJSObject:jsobj class:[CCJumpTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGrid3DAction
 */
#pragma mark - CCGrid3DAction

JSClass* JSPROXY_CCGrid3DAction_class = NULL;
JSObject* JSPROXY_CCGrid3DAction_object = NULL;
 // Constructor
JSBool JSPROXY_CCGrid3DAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCGrid3DAction createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCGrid3DAction_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCGrid3DAction)", obj);
}

// Arguments: ccGridSize
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSPROXY_CCGrid3DAction_originalVertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	ccVertex3F ret_val;

	CCGrid3DAction *real = (CCGrid3DAction*) [proxy realObj];
	ret_val = [real originalVertex:(ccGridSize)arg0  ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	ccVertex3F* buffer = (ccVertex3F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: ccGridSize, ccVertex3F
// Ret value: void (None)
JSBool JSPROXY_CCGrid3DAction_setVertex_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; ccVertex3F arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );

	JSObject *tmp_arg1;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(ccVertex3F*)JS_GetTypedArrayData( tmp_arg1);
	if( ! ok ) return JS_FALSE;

	CCGrid3DAction *real = (CCGrid3DAction*) [proxy realObj];
	[real setVertex:(ccGridSize)arg0 vertex:(ccVertex3F)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSPROXY_CCGrid3DAction_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	ccVertex3F ret_val;

	CCGrid3DAction *real = (CCGrid3DAction*) [proxy realObj];
	ret_val = [real vertex:(ccGridSize)arg0  ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	ccVertex3F* buffer = (ccVertex3F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCGrid3DAction* (o)
JSBool JSPROXY_CCGrid3DAction_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCGrid3DAction* ret_val;

	ret_val = [CCGrid3DAction actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCGrid3DAction* (o)
JSBool JSPROXY_CCGrid3DAction_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCGrid3DAction* ret_val;

	ret_val = [CCGrid3DAction actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGrid3DAction* (o)
JSBool JSPROXY_CCGrid3DAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGrid3DAction* ret_val;

	ret_val = [CCGrid3DAction action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCGrid3DAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCGrid3DAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCGrid3DAction_class->name = name;
	JSPROXY_CCGrid3DAction_class->addProperty = JS_PropertyStub;
	JSPROXY_CCGrid3DAction_class->delProperty = JS_PropertyStub;
	JSPROXY_CCGrid3DAction_class->getProperty = JS_PropertyStub;
	JSPROXY_CCGrid3DAction_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCGrid3DAction_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCGrid3DAction_class->resolve = JS_ResolveStub;
	JSPROXY_CCGrid3DAction_class->convert = JS_ConvertStub;
	JSPROXY_CCGrid3DAction_class->finalize = JSPROXY_CCGrid3DAction_finalize;
//	JSPROXY_CCGrid3DAction_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("originalVertex", JSPROXY_CCGrid3DAction_originalVertex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setVertexVertex", JSPROXY_CCGrid3DAction_setVertex_vertex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("vertex", JSPROXY_CCGrid3DAction_vertex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithSizeDuration", JSPROXY_CCGrid3DAction_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCGrid3DAction_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCGrid3DAction_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCGrid3DAction_object = JS_InitClass(cx, globalObj, JSPROXY_CCGridAction_object, JSPROXY_CCGrid3DAction_class, JSPROXY_CCGrid3DAction_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCGrid3DAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCGrid3DAction_class, JSPROXY_CCGrid3DAction_object, NULL);
	JSPROXY_CCGrid3DAction *proxy = [[JSPROXY_CCGrid3DAction alloc] initWithJSObject:jsobj class:[CCGrid3DAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemSprite
 */
#pragma mark - CCMenuItemSprite

JSClass* JSPROXY_CCMenuItemSprite_class = NULL;
JSObject* JSPROXY_CCMenuItemSprite_object = NULL;
 // Constructor
JSBool JSPROXY_CCMenuItemSprite_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMenuItemSprite createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMenuItemSprite_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMenuItemSprite)", obj);
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSPROXY_CCMenuItemSprite_disabledImage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real disabledImage ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*, CCNode*, CCNode*, void (^)(id)
// Ret value: None (None)
JSBool JSPROXY_CCMenuItemSprite_initWithNormalSprite_selectedSprite_disabledSprite_block_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; id arg2; js_block arg3; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg2);
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg3 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemSprite *real = [(CCMenuItemSprite*)[proxy.klass alloc] initWithNormalSprite:(CCNode*)arg0 selectedSprite:(CCNode*)arg1 disabledSprite:(CCNode*)arg2 block:(void (^)(id))arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*, CCNode*
// Ret value: CCMenuItemSprite* (o)
JSBool JSPROXY_CCMenuItemSprite_itemWithNormalSprite_selectedSprite__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCMenuItemSprite* ret_val;

	ret_val = [CCMenuItemSprite itemWithNormalSprite:(CCNode*)arg0 selectedSprite:(CCNode*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSPROXY_CCMenuItemSprite_normalImage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real normalImage ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCNode* (o)
JSBool JSPROXY_CCMenuItemSprite_selectedImage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCNode* ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real selectedImage ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemSprite_setDisabledImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setDisabledImage:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemSprite_setNormalImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setNormalImage:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemSprite_setSelectedImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setSelectedImage:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCMenuItemSprite_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCMenuItemSprite_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCMenuItemSprite_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemSprite_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemSprite_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemSprite_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemSprite *real = (CCMenuItemSprite*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItemSprite* (o)
JSBool JSPROXY_CCMenuItemSprite_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemSprite* ret_val;

	ret_val = [CCMenuItemSprite itemWithBlock:(void (^)(id))arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItemSprite* (o)
JSBool JSPROXY_CCMenuItemSprite_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItemSprite* ret_val;

	ret_val = [CCMenuItemSprite node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMenuItemSprite_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMenuItemSprite_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMenuItemSprite_class->name = name;
	JSPROXY_CCMenuItemSprite_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemSprite_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemSprite_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemSprite_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMenuItemSprite_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMenuItemSprite_class->resolve = JS_ResolveStub;
	JSPROXY_CCMenuItemSprite_class->convert = JS_ConvertStub;
	JSPROXY_CCMenuItemSprite_class->finalize = JSPROXY_CCMenuItemSprite_finalize;
//	JSPROXY_CCMenuItemSprite_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("disabledImage", JSPROXY_CCMenuItemSprite_disabledImage, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithNormalSpriteSelectedSpriteDisabledSpriteBlock", JSPROXY_CCMenuItemSprite_initWithNormalSprite_selectedSprite_disabledSprite_block_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("normalImage", JSPROXY_CCMenuItemSprite_normalImage, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("selectedImage", JSPROXY_CCMenuItemSprite_selectedImage, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDisabledImage", JSPROXY_CCMenuItemSprite_setDisabledImage_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setNormalImage", JSPROXY_CCMenuItemSprite_setNormalImage_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSelectedImage", JSPROXY_CCMenuItemSprite_setSelectedImage_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("color", JSPROXY_CCMenuItemSprite_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCMenuItemSprite_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("opacity", JSPROXY_CCMenuItemSprite_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCMenuItemSprite_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCMenuItemSprite_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCMenuItemSprite_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("itemWithNormalSpriteSelectedSprite", JSPROXY_CCMenuItemSprite_itemWithNormalSprite_selectedSprite__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCMenuItemSprite_itemWithNormalSprite_selectedSprite_disabledSprite_block__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithBlock", JSPROXY_CCMenuItemSprite_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCMenuItemSprite_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMenuItemSprite_object = JS_InitClass(cx, globalObj, JSPROXY_CCMenuItem_object, JSPROXY_CCMenuItemSprite_class, JSPROXY_CCMenuItemSprite_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMenuItemSprite

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMenuItemSprite_class, JSPROXY_CCMenuItemSprite_object, NULL);
	JSPROXY_CCMenuItemSprite *proxy = [[JSPROXY_CCMenuItemSprite alloc] initWithJSObject:jsobj class:[CCMenuItemSprite class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemImage
 */
#pragma mark - CCMenuItemImage

JSClass* JSPROXY_CCMenuItemImage_class = NULL;
JSObject* JSPROXY_CCMenuItemImage_object = NULL;
 // Constructor
JSBool JSPROXY_CCMenuItemImage_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMenuItemImage createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMenuItemImage_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMenuItemImage)", obj);
}

// Arguments: NSString*, NSString*, NSString*, void (^)(id)
// Ret value: None (None)
JSBool JSPROXY_CCMenuItemImage_initWithNormalImage_selectedImage_disabledImage_block_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; NSString* arg2; js_block arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg2 );
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg3 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemImage *real = [(CCMenuItemImage*)[proxy.klass alloc] initWithNormalImage:(NSString*)arg0 selectedImage:(NSString*)arg1 disabledImage:(NSString*)arg2 block:(void (^)(id))arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCMenuItemImage* (o)
JSBool JSPROXY_CCMenuItemImage_itemWithNormalImage_selectedImage__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithNormalImage:(NSString*)arg0 selectedImage:(NSString*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, NSString*
// Ret value: CCMenuItemImage* (o)
JSBool JSPROXY_CCMenuItemImage_itemWithNormalImage_selectedImage_disabledImage__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; NSString* arg2; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithNormalImage:(NSString*)arg0 selectedImage:(NSString*)arg1 disabledImage:(NSString*)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemImage_setDisabledSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemImage *real = (CCMenuItemImage*) [proxy realObj];
	[real setDisabledSpriteFrame:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemImage_setNormalSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemImage *real = (CCMenuItemImage*) [proxy realObj];
	[real setNormalSpriteFrame:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemImage_setSelectedSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemImage *real = (CCMenuItemImage*) [proxy realObj];
	[real setSelectedSpriteFrame:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*, CCNode*
// Ret value: CCMenuItemImage* (o)
JSBool JSPROXY_CCMenuItemImage_itemWithNormalSprite_selectedSprite__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithNormalSprite:(CCNode*)arg0 selectedSprite:(CCNode*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*, CCNode*, void (^)(id)
// Ret value: CCMenuItemImage* (o)
JSBool JSPROXY_CCMenuItemImage_itemWithNormalSprite_selectedSprite_block__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; js_block arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg2 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithNormalSprite:(CCNode*)arg0 selectedSprite:(CCNode*)arg1 block:(void (^)(id))arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*, CCNode*, CCNode*, void (^)(id)
// Ret value: CCMenuItemImage* (o)
JSBool JSPROXY_CCMenuItemImage_itemWithNormalSprite_selectedSprite_disabledSprite_block__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; id arg2; js_block arg3; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg2);
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg3 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithNormalSprite:(CCNode*)arg0 selectedSprite:(CCNode*)arg1 disabledSprite:(CCNode*)arg2 block:(void (^)(id))arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItemImage* (o)
JSBool JSPROXY_CCMenuItemImage_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage itemWithBlock:(void (^)(id))arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItemImage* (o)
JSBool JSPROXY_CCMenuItemImage_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItemImage* ret_val;

	ret_val = [CCMenuItemImage node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMenuItemImage_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMenuItemImage_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMenuItemImage_class->name = name;
	JSPROXY_CCMenuItemImage_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemImage_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemImage_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemImage_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMenuItemImage_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMenuItemImage_class->resolve = JS_ResolveStub;
	JSPROXY_CCMenuItemImage_class->convert = JS_ConvertStub;
	JSPROXY_CCMenuItemImage_class->finalize = JSPROXY_CCMenuItemImage_finalize;
//	JSPROXY_CCMenuItemImage_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithNormalImageSelectedImageDisabledImageBlock", JSPROXY_CCMenuItemImage_initWithNormalImage_selectedImage_disabledImage_block_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDisabledSpriteFrame", JSPROXY_CCMenuItemImage_setDisabledSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setNormalSpriteFrame", JSPROXY_CCMenuItemImage_setNormalSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSelectedSpriteFrame", JSPROXY_CCMenuItemImage_setSelectedSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("itemWithNormalImageSelectedImage", JSPROXY_CCMenuItemImage_itemWithNormalImage_selectedImage__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithNormalImageSelectedImageDisabledImage", JSPROXY_CCMenuItemImage_itemWithNormalImage_selectedImage_disabledImage__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCMenuItemImage_itemWithNormalImage_selectedImage_disabledImage_block__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithNormalSpriteSelectedSprite", JSPROXY_CCMenuItemImage_itemWithNormalSprite_selectedSprite__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithNormalSpriteSelectedSpriteBlock", JSPROXY_CCMenuItemImage_itemWithNormalSprite_selectedSprite_block__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithNormalSpriteSelectedSpriteDisabledSpriteBlock", JSPROXY_CCMenuItemImage_itemWithNormalSprite_selectedSprite_disabledSprite_block__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithBlock", JSPROXY_CCMenuItemImage_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCMenuItemImage_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMenuItemImage_object = JS_InitClass(cx, globalObj, JSPROXY_CCMenuItemSprite_object, JSPROXY_CCMenuItemImage_class, JSPROXY_CCMenuItemImage_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMenuItemImage

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMenuItemImage_class, JSPROXY_CCMenuItemImage_object, NULL);
	JSPROXY_CCMenuItemImage *proxy = [[JSPROXY_CCMenuItemImage alloc] initWithJSObject:jsobj class:[CCMenuItemImage class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleBatchNode
 */
#pragma mark - CCParticleBatchNode

JSClass* JSPROXY_CCParticleBatchNode_class = NULL;
JSObject* JSPROXY_CCParticleBatchNode_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleBatchNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleBatchNode createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleBatchNode_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleBatchNode)", obj);
}

// Arguments: CCParticleSystem*, NSInteger, NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCParticleBatchNode_addChild_z_tag_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; int32_t arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real addChild:(CCParticleSystem*)arg0 z:(NSInteger)arg1 tag:(NSInteger)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleBatchNode* (o)
JSBool JSPROXY_CCParticleBatchNode_batchNodeWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleBatchNode* ret_val;

	ret_val = [CCParticleBatchNode batchNodeWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCParticleBatchNode* (o)
JSBool JSPROXY_CCParticleBatchNode_batchNodeWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCParticleBatchNode* ret_val;

	ret_val = [CCParticleBatchNode batchNodeWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: CCParticleBatchNode* (o)
JSBool JSPROXY_CCParticleBatchNode_batchNodeWithTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCParticleBatchNode* ret_val;

	ret_val = [CCParticleBatchNode batchNodeWithTexture:(CCTexture2D*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCParticleBatchNode* (o)
JSBool JSPROXY_CCParticleBatchNode_batchNodeWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCParticleBatchNode* ret_val;

	ret_val = [CCParticleBatchNode batchNodeWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccBlendFunc ({_ccBlendFunc=II})
JSBool JSPROXY_CCParticleBatchNode_blendFunc(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccBlendFunc ret_val;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	ret_val = [real blendFunc ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT32, 2 );
	ccBlendFunc* buffer = (ccBlendFunc*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCParticleBatchNode_disableParticle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real disableParticle:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCParticleBatchNode_initWithFile_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = [(CCParticleBatchNode*)[proxy.klass alloc] initWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCParticleBatchNode_initWithTexture_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = [(CCParticleBatchNode*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCParticleSystem*, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCParticleBatchNode_insertChild_inAtlasAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real insertChild:(CCParticleSystem*)arg0 inAtlasAtIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCParticleSystem*, BOOL
// Ret value: void (None)
JSBool JSPROXY_CCParticleBatchNode_removeChild_cleanup_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; JSBool arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real removeChild:(CCParticleSystem*)arg0 cleanup:(BOOL)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccBlendFunc
// Ret value: void (None)
JSBool JSPROXY_CCParticleBatchNode_setBlendFunc_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccBlendFunc arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccBlendFunc*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real setBlendFunc:(ccBlendFunc)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSPROXY_CCParticleBatchNode_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real setTextureAtlas:(CCTextureAtlas*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSPROXY_CCParticleBatchNode_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCParticleBatchNode_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCParticleBatchNode_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCParticleBatchNode *real = (CCParticleBatchNode*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleBatchNode* (o)
JSBool JSPROXY_CCParticleBatchNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleBatchNode* ret_val;

	ret_val = [CCParticleBatchNode node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleBatchNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleBatchNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleBatchNode_class->name = name;
	JSPROXY_CCParticleBatchNode_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleBatchNode_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleBatchNode_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleBatchNode_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleBatchNode_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleBatchNode_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleBatchNode_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleBatchNode_class->finalize = JSPROXY_CCParticleBatchNode_finalize;
//	JSPROXY_CCParticleBatchNode_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addChildZTag", JSPROXY_CCParticleBatchNode_addChild_z_tag_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getBlendFunc", JSPROXY_CCParticleBatchNode_blendFunc, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("disableParticle", JSPROXY_CCParticleBatchNode_disableParticle_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFileCapacity", JSPROXY_CCParticleBatchNode_initWithFile_capacity_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureCapacity", JSPROXY_CCParticleBatchNode_initWithTexture_capacity_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("insertChildInAtlasAtIndex", JSPROXY_CCParticleBatchNode_insertChild_inAtlasAtIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeChildCleanup", JSPROXY_CCParticleBatchNode_removeChild_cleanup_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSPROXY_CCParticleBatchNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSPROXY_CCParticleBatchNode_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSPROXY_CCParticleBatchNode_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCParticleBatchNode_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCParticleBatchNode_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("batchNodeWithFile", JSPROXY_CCParticleBatchNode_batchNodeWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithFileCapacity", JSPROXY_CCParticleBatchNode_batchNodeWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithTexture", JSPROXY_CCParticleBatchNode_batchNodeWithTexture__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithTextureCapacity", JSPROXY_CCParticleBatchNode_batchNodeWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleBatchNode_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleBatchNode_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCParticleBatchNode_class, JSPROXY_CCParticleBatchNode_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleBatchNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleBatchNode_class, JSPROXY_CCParticleBatchNode_object, NULL);
	JSPROXY_CCParticleBatchNode *proxy = [[JSPROXY_CCParticleBatchNode alloc] initWithJSObject:jsobj class:[CCParticleBatchNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionCrossFade
 */
#pragma mark - CCTransitionCrossFade

JSClass* JSPROXY_CCTransitionCrossFade_class = NULL;
JSObject* JSPROXY_CCTransitionCrossFade_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionCrossFade_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionCrossFade createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionCrossFade_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionCrossFade)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionCrossFade_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionCrossFade *real = [(CCTransitionCrossFade*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionCrossFade* (o)
JSBool JSPROXY_CCTransitionCrossFade_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionCrossFade* ret_val;

	ret_val = [CCTransitionCrossFade transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionCrossFade* (o)
JSBool JSPROXY_CCTransitionCrossFade_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionCrossFade* ret_val;

	ret_val = [CCTransitionCrossFade node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionCrossFade_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionCrossFade_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionCrossFade_class->name = name;
	JSPROXY_CCTransitionCrossFade_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionCrossFade_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionCrossFade_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionCrossFade_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionCrossFade_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionCrossFade_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionCrossFade_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionCrossFade_class->finalize = JSPROXY_CCTransitionCrossFade_finalize;
//	JSPROXY_CCTransitionCrossFade_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionCrossFade_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionCrossFade_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionCrossFade_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionCrossFade_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionCrossFade_class, JSPROXY_CCTransitionCrossFade_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionCrossFade

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionCrossFade_class, JSPROXY_CCTransitionCrossFade_object, NULL);
	JSPROXY_CCTransitionCrossFade *proxy = [[JSPROXY_CCTransitionCrossFade alloc] initWithJSObject:jsobj class:[CCTransitionCrossFade class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBMFontConfiguration
 */
#pragma mark - CCBMFontConfiguration

JSClass* JSPROXY_CCBMFontConfiguration_class = NULL;
JSObject* JSPROXY_CCBMFontConfiguration_object = NULL;
 // Constructor
JSBool JSPROXY_CCBMFontConfiguration_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCBMFontConfiguration createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCBMFontConfiguration_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCBMFontConfiguration)", obj);
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCBMFontConfiguration_atlasName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCBMFontConfiguration *real = (CCBMFontConfiguration*) [proxy realObj];
	ret_val = [real atlasName ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCBMFontConfiguration* (o)
JSBool JSPROXY_CCBMFontConfiguration_configurationWithFNTFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCBMFontConfiguration* ret_val;

	ret_val = [CCBMFontConfiguration configurationWithFNTFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCBMFontConfiguration_initWithFNTfile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCBMFontConfiguration *real = [(CCBMFontConfiguration*)[proxy.klass alloc] initWithFNTfile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCBMFontConfiguration_setAtlasName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCBMFontConfiguration *real = (CCBMFontConfiguration*) [proxy realObj];
	[real setAtlasName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCBMFontConfiguration_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCBMFontConfiguration_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCBMFontConfiguration_class->name = name;
	JSPROXY_CCBMFontConfiguration_class->addProperty = JS_PropertyStub;
	JSPROXY_CCBMFontConfiguration_class->delProperty = JS_PropertyStub;
	JSPROXY_CCBMFontConfiguration_class->getProperty = JS_PropertyStub;
	JSPROXY_CCBMFontConfiguration_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCBMFontConfiguration_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCBMFontConfiguration_class->resolve = JS_ResolveStub;
	JSPROXY_CCBMFontConfiguration_class->convert = JS_ConvertStub;
	JSPROXY_CCBMFontConfiguration_class->finalize = JSPROXY_CCBMFontConfiguration_finalize;
//	JSPROXY_CCBMFontConfiguration_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAtlasName", JSPROXY_CCBMFontConfiguration_atlasName, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFNTfile", JSPROXY_CCBMFontConfiguration_initWithFNTfile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAtlasName", JSPROXY_CCBMFontConfiguration_setAtlasName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("configurationWithFNTFile", JSPROXY_CCBMFontConfiguration_configurationWithFNTFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCBMFontConfiguration_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCBMFontConfiguration_class, JSPROXY_CCBMFontConfiguration_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCBMFontConfiguration

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCBMFontConfiguration_class, JSPROXY_CCBMFontConfiguration_object, NULL);
	JSPROXY_CCBMFontConfiguration *proxy = [[JSPROXY_CCBMFontConfiguration alloc] initWithJSObject:jsobj class:[CCBMFontConfiguration class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElasticIn
 */
#pragma mark - CCEaseElasticIn

JSClass* JSPROXY_CCEaseElasticIn_class = NULL;
JSObject* JSPROXY_CCEaseElasticIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseElasticIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseElasticIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseElasticIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseElasticIn)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseElasticIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseElasticIn *real = (CCEaseElasticIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElasticIn* (o)
JSBool JSPROXY_CCEaseElasticIn_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCEaseElasticIn* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElasticIn actionWithAction:(CCActionInterval*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElasticIn actionWithAction:(CCActionInterval*)arg0 period:(float)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseElasticIn* (o)
JSBool JSPROXY_CCEaseElasticIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseElasticIn* ret_val;

	ret_val = [CCEaseElasticIn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseElasticIn* (o)
JSBool JSPROXY_CCEaseElasticIn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseElasticIn* ret_val;

	ret_val = [CCEaseElasticIn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseElasticIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseElasticIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseElasticIn_class->name = name;
	JSPROXY_CCEaseElasticIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseElasticIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseElasticIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseElasticIn_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseElasticIn_class->finalize = JSPROXY_CCEaseElasticIn_finalize;
//	JSPROXY_CCEaseElasticIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseElasticIn_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseElasticIn_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseElasticIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseElasticIn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseElasticIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseElastic_object, JSPROXY_CCEaseElasticIn_class, JSPROXY_CCEaseElasticIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseElasticIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseElasticIn_class, JSPROXY_CCEaseElasticIn_object, NULL);
	JSPROXY_CCEaseElasticIn *proxy = [[JSPROXY_CCEaseElasticIn alloc] initWithJSObject:jsobj class:[CCEaseElasticIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpeed
 */
#pragma mark - CCSpeed

JSClass* JSPROXY_CCSpeed_class = NULL;
JSObject* JSPROXY_CCSpeed_object = NULL;
 // Constructor
JSBool JSPROXY_CCSpeed_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSpeed createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSpeed_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSpeed)", obj);
}

// Arguments: CCActionInterval*, float
// Ret value: CCSpeed* (o)
JSBool JSPROXY_CCSpeed_actionWithAction_speed__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCSpeed* ret_val;

	ret_val = [CCSpeed actionWithAction:(CCActionInterval*)arg0 speed:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: None (None)
JSBool JSPROXY_CCSpeed_initWithAction_speed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpeed *real = [(CCSpeed*)[proxy.klass alloc] initWithAction:(CCActionInterval*)arg0 speed:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCSpeed_innerAction(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	ret_val = [real innerAction ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: void (None)
JSBool JSPROXY_CCSpeed_setInnerAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	[real setInnerAction:(CCActionInterval*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCSpeed_setSpeed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	[real setSpeed:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCSpeed_speed(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCSpeed *real = (CCSpeed*) [proxy realObj];
	ret_val = [real speed ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpeed* (o)
JSBool JSPROXY_CCSpeed_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSpeed* ret_val;

	ret_val = [CCSpeed action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSpeed_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSpeed_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSpeed_class->name = name;
	JSPROXY_CCSpeed_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSpeed_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSpeed_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSpeed_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSpeed_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSpeed_class->resolve = JS_ResolveStub;
	JSPROXY_CCSpeed_class->convert = JS_ConvertStub;
	JSPROXY_CCSpeed_class->finalize = JSPROXY_CCSpeed_finalize;
//	JSPROXY_CCSpeed_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionSpeed", JSPROXY_CCSpeed_initWithAction_speed_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getInnerAction", JSPROXY_CCSpeed_innerAction, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setInnerAction", JSPROXY_CCSpeed_setInnerAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSpeed", JSPROXY_CCSpeed_setSpeed_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSpeed", JSPROXY_CCSpeed_speed, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionSpeed", JSPROXY_CCSpeed_actionWithAction_speed__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCSpeed_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSpeed_object = JS_InitClass(cx, globalObj, JSPROXY_CCAction_object, JSPROXY_CCSpeed_class, JSPROXY_CCSpeed_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSpeed

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSpeed_class, JSPROXY_CCSpeed_object, NULL);
	JSPROXY_CCSpeed *proxy = [[JSPROXY_CCSpeed alloc] initWithJSObject:jsobj class:[CCSpeed class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRotateTo
 */
#pragma mark - CCRotateTo

JSClass* JSPROXY_CCRotateTo_class = NULL;
JSObject* JSPROXY_CCRotateTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCRotateTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCRotateTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCRotateTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCRotateTo)", obj);
}

// Arguments: ccTime, float
// Ret value: CCRotateTo* (o)
JSBool JSPROXY_CCRotateTo_actionWithDuration_angle__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCRotateTo* ret_val;

	ret_val = [CCRotateTo actionWithDuration:(ccTime)arg0 angle:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCRotateTo* (o)
JSBool JSPROXY_CCRotateTo_actionWithDuration_angleX_angleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCRotateTo* ret_val;

	ret_val = [CCRotateTo actionWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSPROXY_CCRotateTo_initWithDuration_angle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCRotateTo *real = [(CCRotateTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angle:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSPROXY_CCRotateTo_initWithDuration_angleX_angleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCRotateTo *real = [(CCRotateTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCRotateTo* (o)
JSBool JSPROXY_CCRotateTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCRotateTo* ret_val;

	ret_val = [CCRotateTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCRotateTo* (o)
JSBool JSPROXY_CCRotateTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCRotateTo* ret_val;

	ret_val = [CCRotateTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCRotateTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCRotateTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCRotateTo_class->name = name;
	JSPROXY_CCRotateTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCRotateTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCRotateTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCRotateTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCRotateTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCRotateTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCRotateTo_class->convert = JS_ConvertStub;
	JSPROXY_CCRotateTo_class->finalize = JSPROXY_CCRotateTo_finalize;
//	JSPROXY_CCRotateTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationAngle", JSPROXY_CCRotateTo_initWithDuration_angle_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithDurationAngleXAngleY", JSPROXY_CCRotateTo_initWithDuration_angleX_angleY_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCRotateTo_actionWithDuration_angle__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDurationAngleXAngleY", JSPROXY_CCRotateTo_actionWithDuration_angleX_angleY__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCRotateTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCRotateTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCRotateTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCRotateTo_class, JSPROXY_CCRotateTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCRotateTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCRotateTo_class, JSPROXY_CCRotateTo_object, NULL);
	JSPROXY_CCRotateTo *proxy = [[JSPROXY_CCRotateTo alloc] initWithJSObject:jsobj class:[CCRotateTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionCamera
 */
#pragma mark - CCActionCamera

JSClass* JSPROXY_CCActionCamera_class = NULL;
JSObject* JSPROXY_CCActionCamera_object = NULL;
 // Constructor
JSBool JSPROXY_CCActionCamera_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCActionCamera createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCActionCamera_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCActionCamera)", obj);
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCActionCamera_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCActionCamera *real = (CCActionCamera*) [proxy realObj];
	[real startWithTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCActionCamera* (o)
JSBool JSPROXY_CCActionCamera_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionCamera* ret_val;

	ret_val = [CCActionCamera actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionCamera* (o)
JSBool JSPROXY_CCActionCamera_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionCamera* ret_val;

	ret_val = [CCActionCamera action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCActionCamera_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCActionCamera_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCActionCamera_class->name = name;
	JSPROXY_CCActionCamera_class->addProperty = JS_PropertyStub;
	JSPROXY_CCActionCamera_class->delProperty = JS_PropertyStub;
	JSPROXY_CCActionCamera_class->getProperty = JS_PropertyStub;
	JSPROXY_CCActionCamera_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCActionCamera_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCActionCamera_class->resolve = JS_ResolveStub;
	JSPROXY_CCActionCamera_class->convert = JS_ConvertStub;
	JSPROXY_CCActionCamera_class->finalize = JSPROXY_CCActionCamera_finalize;
//	JSPROXY_CCActionCamera_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSPROXY_CCActionCamera_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDuration", JSPROXY_CCActionCamera_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCActionCamera_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCActionCamera_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCActionCamera_class, JSPROXY_CCActionCamera_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCActionCamera

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCActionCamera_class, JSPROXY_CCActionCamera_object, NULL);
	JSPROXY_CCActionCamera *proxy = [[JSPROXY_CCActionCamera alloc] initWithJSObject:jsobj class:[CCActionCamera class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleGalaxy
 */
#pragma mark - CCParticleGalaxy

JSClass* JSPROXY_CCParticleGalaxy_class = NULL;
JSObject* JSPROXY_CCParticleGalaxy_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleGalaxy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleGalaxy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleGalaxy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleGalaxy)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleGalaxy_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleGalaxy *real = [(CCParticleGalaxy*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleGalaxy* (o)
JSBool JSPROXY_CCParticleGalaxy_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleGalaxy* ret_val;

	ret_val = [CCParticleGalaxy particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleGalaxy* (o)
JSBool JSPROXY_CCParticleGalaxy_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleGalaxy* ret_val;

	ret_val = [CCParticleGalaxy particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleGalaxy* (o)
JSBool JSPROXY_CCParticleGalaxy_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleGalaxy* ret_val;

	ret_val = [CCParticleGalaxy node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleGalaxy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleGalaxy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleGalaxy_class->name = name;
	JSPROXY_CCParticleGalaxy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleGalaxy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleGalaxy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleGalaxy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleGalaxy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleGalaxy_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleGalaxy_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleGalaxy_class->finalize = JSPROXY_CCParticleGalaxy_finalize;
//	JSPROXY_CCParticleGalaxy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleGalaxy_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleGalaxy_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleGalaxy_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleGalaxy_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleGalaxy_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleGalaxy_class, JSPROXY_CCParticleGalaxy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleGalaxy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleGalaxy_class, JSPROXY_CCParticleGalaxy_object, NULL);
	JSPROXY_CCParticleGalaxy *proxy = [[JSPROXY_CCParticleGalaxy alloc] initWithJSObject:jsobj class:[CCParticleGalaxy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMotionStreak
 */
#pragma mark - CCMotionStreak

JSClass* JSPROXY_CCMotionStreak_class = NULL;
JSObject* JSPROXY_CCMotionStreak_object = NULL;
 // Constructor
JSBool JSPROXY_CCMotionStreak_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMotionStreak createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMotionStreak_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMotionStreak)", obj);
}

// Arguments: 
// Ret value: ccBlendFunc ({_ccBlendFunc=II})
JSBool JSPROXY_CCMotionStreak_blendFunc(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccBlendFunc ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real blendFunc ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT32, 2 );
	ccBlendFunc* buffer = (ccBlendFunc*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, CCTexture2D*
// Ret value: None (None)
JSBool JSPROXY_CCMotionStreak_initWithFade_minSeg_width_color_texture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; id arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );

	JSObject *tmp_arg3;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg3 );
	arg3 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg3);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg4);
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = [(CCMotionStreak*)[proxy.klass alloc] initWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 texture:(CCTexture2D*)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, NSString*
// Ret value: None (None)
JSBool JSPROXY_CCMotionStreak_initWithFade_minSeg_width_color_textureFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; NSString* arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );

	JSObject *tmp_arg3;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg3 );
	arg3 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg3);
	ok &= jsval_to_nsstring( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = [(CCMotionStreak*)[proxy.klass alloc] initWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 textureFilename:(NSString*)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCMotionStreak_isFastMode(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real isFastMode ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_reset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real reset ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccBlendFunc
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_setBlendFunc_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccBlendFunc arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccBlendFunc*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setBlendFunc:(ccBlendFunc)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_setFastMode_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setFastMode:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, CCTexture2D*
// Ret value: CCMotionStreak* (o)
JSBool JSPROXY_CCMotionStreak_streakWithFade_minSeg_width_color_texture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; id arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );

	JSObject *tmp_arg3;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg3 );
	arg3 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg3);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg4);
	if( ! ok ) return JS_FALSE;
	CCMotionStreak* ret_val;

	ret_val = [CCMotionStreak streakWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 texture:(CCTexture2D*)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: float, float, float, ccColor3B, NSString*
// Ret value: CCMotionStreak* (o)
JSBool JSPROXY_CCMotionStreak_streakWithFade_minSeg_width_color_textureFilename__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; ccColor3B arg3; NSString* arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );

	JSObject *tmp_arg3;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg3 );
	arg3 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg3);
	ok &= jsval_to_nsstring( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;
	CCMotionStreak* ret_val;

	ret_val = [CCMotionStreak streakWithFade:(float)arg0 minSeg:(float)arg1 width:(float)arg2 color:(ccColor3B)arg3 textureFilename:(NSString*)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCMotionStreak_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_tintWithColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real tintWithColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCMotionStreak_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCMotionStreak_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCMotionStreak_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCMotionStreak_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMotionStreak *real = (CCMotionStreak*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMotionStreak* (o)
JSBool JSPROXY_CCMotionStreak_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMotionStreak* ret_val;

	ret_val = [CCMotionStreak node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMotionStreak_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMotionStreak_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMotionStreak_class->name = name;
	JSPROXY_CCMotionStreak_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMotionStreak_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMotionStreak_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMotionStreak_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMotionStreak_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMotionStreak_class->resolve = JS_ResolveStub;
	JSPROXY_CCMotionStreak_class->convert = JS_ConvertStub;
	JSPROXY_CCMotionStreak_class->finalize = JSPROXY_CCMotionStreak_finalize;
//	JSPROXY_CCMotionStreak_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBlendFunc", JSPROXY_CCMotionStreak_blendFunc, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFadeMinSegWidthColorTexture", JSPROXY_CCMotionStreak_initWithFade_minSeg_width_color_texture_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFadeMinSegWidthColorTextureFilename", JSPROXY_CCMotionStreak_initWithFade_minSeg_width_color_textureFilename_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("isFastMode", JSPROXY_CCMotionStreak_isFastMode, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reset", JSPROXY_CCMotionStreak_reset, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSPROXY_CCMotionStreak_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFastMode", JSPROXY_CCMotionStreak_setFastMode_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCMotionStreak_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCMotionStreak_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("tintWithColor", JSPROXY_CCMotionStreak_tintWithColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("color", JSPROXY_CCMotionStreak_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCMotionStreak_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("opacity", JSPROXY_CCMotionStreak_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCMotionStreak_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCMotionStreak_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCMotionStreak_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("streakWithFadeMinSegWidthColorTexture", JSPROXY_CCMotionStreak_streakWithFade_minSeg_width_color_texture__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("streakWithFadeMinSegWidthColorTextureFilename", JSPROXY_CCMotionStreak_streakWithFade_minSeg_width_color_textureFilename__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCMotionStreak_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMotionStreak_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCMotionStreak_class, JSPROXY_CCMotionStreak_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMotionStreak

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMotionStreak_class, JSPROXY_CCMotionStreak_object, NULL);
	JSPROXY_CCMotionStreak *proxy = [[JSPROXY_CCMotionStreak alloc] initWithJSObject:jsobj class:[CCMotionStreak class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShow
 */
#pragma mark - CCShow

JSClass* JSPROXY_CCShow_class = NULL;
JSObject* JSPROXY_CCShow_object = NULL;
 // Constructor
JSBool JSPROXY_CCShow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCShow createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCShow_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCShow)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCShow_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCShow *real = (CCShow*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShow* (o)
JSBool JSPROXY_CCShow_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCShow* ret_val;

	ret_val = [CCShow action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCShow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCShow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCShow_class->name = name;
	JSPROXY_CCShow_class->addProperty = JS_PropertyStub;
	JSPROXY_CCShow_class->delProperty = JS_PropertyStub;
	JSPROXY_CCShow_class->getProperty = JS_PropertyStub;
	JSPROXY_CCShow_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCShow_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCShow_class->resolve = JS_ResolveStub;
	JSPROXY_CCShow_class->convert = JS_ConvertStub;
	JSPROXY_CCShow_class->finalize = JSPROXY_CCShow_finalize;
//	JSPROXY_CCShow_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCShow_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCShow_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCShow_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCShow_class, JSPROXY_CCShow_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCShow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCShow_class, JSPROXY_CCShow_object, NULL);
	JSPROXY_CCShow *proxy = [[JSPROXY_CCShow alloc] initWithJSObject:jsobj class:[CCShow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAccelAmplitude
 */
#pragma mark - CCAccelAmplitude

JSClass* JSPROXY_CCAccelAmplitude_class = NULL;
JSObject* JSPROXY_CCAccelAmplitude_object = NULL;
 // Constructor
JSBool JSPROXY_CCAccelAmplitude_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAccelAmplitude createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAccelAmplitude_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAccelAmplitude)", obj);
}

// Arguments: CCAction*, ccTime
// Ret value: CCAccelAmplitude* (o)
JSBool JSPROXY_CCAccelAmplitude_actionWithAction_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCAccelAmplitude* ret_val;

	ret_val = [CCAccelAmplitude actionWithAction:(CCAction*)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCAccelAmplitude_initWithAction_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCAccelAmplitude *real = [(CCAccelAmplitude*)[proxy.klass alloc] initWithAction:(CCAction*)arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCAccelAmplitude_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCAccelAmplitude *real = (CCAccelAmplitude*) [proxy realObj];
	ret_val = [real rate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCAccelAmplitude_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAccelAmplitude *real = (CCAccelAmplitude*) [proxy realObj];
	[real setRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCAccelAmplitude* (o)
JSBool JSPROXY_CCAccelAmplitude_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCAccelAmplitude* ret_val;

	ret_val = [CCAccelAmplitude actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAccelAmplitude* (o)
JSBool JSPROXY_CCAccelAmplitude_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCAccelAmplitude* ret_val;

	ret_val = [CCAccelAmplitude action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCAccelAmplitude_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAccelAmplitude_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAccelAmplitude_class->name = name;
	JSPROXY_CCAccelAmplitude_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAccelAmplitude_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAccelAmplitude_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAccelAmplitude_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAccelAmplitude_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAccelAmplitude_class->resolve = JS_ResolveStub;
	JSPROXY_CCAccelAmplitude_class->convert = JS_ConvertStub;
	JSPROXY_CCAccelAmplitude_class->finalize = JSPROXY_CCAccelAmplitude_finalize;
//	JSPROXY_CCAccelAmplitude_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionDuration", JSPROXY_CCAccelAmplitude_initWithAction_duration_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRate", JSPROXY_CCAccelAmplitude_rate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRate", JSPROXY_CCAccelAmplitude_setRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionDuration", JSPROXY_CCAccelAmplitude_actionWithAction_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCAccelAmplitude_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCAccelAmplitude_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCAccelAmplitude_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCAccelAmplitude_class, JSPROXY_CCAccelAmplitude_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAccelAmplitude

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAccelAmplitude_class, JSPROXY_CCAccelAmplitude_object, NULL);
	JSPROXY_CCAccelAmplitude *proxy = [[JSPROXY_CCAccelAmplitude alloc] initWithJSObject:jsobj class:[CCAccelAmplitude class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGridBase
 */
#pragma mark - CCGridBase

JSClass* JSPROXY_CCGridBase_class = NULL;
JSObject* JSPROXY_CCGridBase_object = NULL;
 // Constructor
JSBool JSPROXY_CCGridBase_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCGridBase createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCGridBase_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCGridBase)", obj);
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCGridBase_active(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real active ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_afterDraw_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real afterDraw:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_beforeDraw(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real beforeDraw ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_blit(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real blit ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_calculateVertexPoints(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real calculateVertexPoints ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGrabber* (o)
JSBool JSPROXY_CCGridBase_grabber(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGrabber* ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real grabber ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccGridSize ({_ccGridSize=ii})
JSBool JSPROXY_CCGridBase_gridSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccGridSize ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real gridSize ];

	jsval ret_jsval = ccGridSize_to_jsval( cx, (ccGridSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: ccGridSize
// Ret value: CCGridBase* (o)
JSBool JSPROXY_CCGridBase_gridWithSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCGridBase* ret_val;

	ret_val = [CCGridBase gridWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccGridSize, CCTexture2D*, BOOL
// Ret value: CCGridBase* (o)
JSBool JSPROXY_CCGridBase_gridWithSize_texture_flippedTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; id arg1; JSBool arg2; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCGridBase* ret_val;

	ret_val = [CCGridBase gridWithSize:(ccGridSize)arg0 texture:(CCTexture2D*)arg1 flippedTexture:(BOOL)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccGridSize
// Ret value: None (None)
JSBool JSPROXY_CCGridBase_initWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = [(CCGridBase*)[proxy.klass alloc] initWithSize:(ccGridSize)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, CCTexture2D*, BOOL
// Ret value: None (None)
JSBool JSPROXY_CCGridBase_initWithSize_texture_flippedTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; id arg1; JSBool arg2; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = [(CCGridBase*)[proxy.klass alloc] initWithSize:(ccGridSize)arg0 texture:(CCTexture2D*)arg1 flippedTexture:(BOOL)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCGridBase_isTextureFlipped(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real isTextureFlipped ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_reuse(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real reuse ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSPROXY_CCGridBase_reuseGrid(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	int ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real reuseGrid ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_setActive_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setActive:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCGrabber*
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_setGrabber_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setGrabber:(CCGrabber*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_setIsTextureFlipped_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setIsTextureFlipped:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_setReuseGrid_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setReuseGrid:(int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCGLProgram*
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_setShaderProgram_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setShaderProgram:(CCGLProgram*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_setStep_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setStep:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCGridBase_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCGLProgram* (o)
JSBool JSPROXY_CCGridBase_shaderProgram(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCGLProgram* ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real shaderProgram ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCGridBase_step(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real step ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCGridBase_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCGridBase *real = (CCGridBase*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCGridBase_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCGridBase_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCGridBase_class->name = name;
	JSPROXY_CCGridBase_class->addProperty = JS_PropertyStub;
	JSPROXY_CCGridBase_class->delProperty = JS_PropertyStub;
	JSPROXY_CCGridBase_class->getProperty = JS_PropertyStub;
	JSPROXY_CCGridBase_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCGridBase_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCGridBase_class->resolve = JS_ResolveStub;
	JSPROXY_CCGridBase_class->convert = JS_ConvertStub;
	JSPROXY_CCGridBase_class->finalize = JSPROXY_CCGridBase_finalize;
//	JSPROXY_CCGridBase_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getActive", JSPROXY_CCGridBase_active, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("afterDraw", JSPROXY_CCGridBase_afterDraw_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("beforeDraw", JSPROXY_CCGridBase_beforeDraw, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("blit", JSPROXY_CCGridBase_blit, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("calculateVertexPoints", JSPROXY_CCGridBase_calculateVertexPoints, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getGrabber", JSPROXY_CCGridBase_grabber, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getGridSize", JSPROXY_CCGridBase_gridSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSize", JSPROXY_CCGridBase_initWithSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSizeTextureFlippedTexture", JSPROXY_CCGridBase_initWithSize_texture_flippedTexture_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getIsTextureFlipped", JSPROXY_CCGridBase_isTextureFlipped, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reuse", JSPROXY_CCGridBase_reuse, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getReuseGrid", JSPROXY_CCGridBase_reuseGrid, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setActive", JSPROXY_CCGridBase_setActive_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setGrabber", JSPROXY_CCGridBase_setGrabber_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setIsTextureFlipped", JSPROXY_CCGridBase_setIsTextureFlipped_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setReuseGrid", JSPROXY_CCGridBase_setReuseGrid_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setShaderProgram", JSPROXY_CCGridBase_setShaderProgram_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setStep", JSPROXY_CCGridBase_setStep_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCGridBase_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getShaderProgram", JSPROXY_CCGridBase_shaderProgram, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getStep", JSPROXY_CCGridBase_step, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCGridBase_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("gridWithSize", JSPROXY_CCGridBase_gridWithSize__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("gridWithSizeTextureFlippedTexture", JSPROXY_CCGridBase_gridWithSize_texture_flippedTexture__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCGridBase_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCGridBase_class, JSPROXY_CCGridBase_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCGridBase

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCGridBase_class, JSPROXY_CCGridBase_object, NULL);
	JSPROXY_CCGridBase *proxy = [[JSPROXY_CCGridBase alloc] initWithJSObject:jsobj class:[CCGridBase class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTiledGrid3D
 */
#pragma mark - CCTiledGrid3D

JSClass* JSPROXY_CCTiledGrid3D_class = NULL;
JSObject* JSPROXY_CCTiledGrid3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCTiledGrid3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTiledGrid3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTiledGrid3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTiledGrid3D)", obj);
}

// Arguments: ccGridSize
// Ret value: CCTiledGrid3D* (o)
JSBool JSPROXY_CCTiledGrid3D_gridWithSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTiledGrid3D* ret_val;

	ret_val = [CCTiledGrid3D gridWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccGridSize, CCTexture2D*, BOOL
// Ret value: CCTiledGrid3D* (o)
JSBool JSPROXY_CCTiledGrid3D_gridWithSize_texture_flippedTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; id arg1; JSBool arg2; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTiledGrid3D* ret_val;

	ret_val = [CCTiledGrid3D gridWithSize:(ccGridSize)arg0 texture:(CCTexture2D*)arg1 flippedTexture:(BOOL)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTiledGrid3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTiledGrid3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTiledGrid3D_class->name = name;
	JSPROXY_CCTiledGrid3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTiledGrid3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTiledGrid3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTiledGrid3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTiledGrid3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTiledGrid3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCTiledGrid3D_class->convert = JS_ConvertStub;
	JSPROXY_CCTiledGrid3D_class->finalize = JSPROXY_CCTiledGrid3D_finalize;
//	JSPROXY_CCTiledGrid3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("gridWithSize", JSPROXY_CCTiledGrid3D_gridWithSize__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("gridWithSizeTextureFlippedTexture", JSPROXY_CCTiledGrid3D_gridWithSize_texture_flippedTexture__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTiledGrid3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCGridBase_object, JSPROXY_CCTiledGrid3D_class, JSPROXY_CCTiledGrid3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTiledGrid3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTiledGrid3D_class, JSPROXY_CCTiledGrid3D_object, NULL);
	JSPROXY_CCTiledGrid3D *proxy = [[JSPROXY_CCTiledGrid3D alloc] initWithJSObject:jsobj class:[CCTiledGrid3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounce
 */
#pragma mark - CCEaseBounce

JSClass* JSPROXY_CCEaseBounce_class = NULL;
JSObject* JSPROXY_CCEaseBounce_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseBounce_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseBounce createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseBounce_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseBounce)", obj);
}

// Arguments: ccTime
// Ret value: ccTime (d)
JSBool JSPROXY_CCEaseBounce_bounceTime_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	ccTime ret_val;

	CCEaseBounce *real = (CCEaseBounce*) [proxy realObj];
	ret_val = [real bounceTime:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounce* (o)
JSBool JSPROXY_CCEaseBounce_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseBounce* ret_val;

	ret_val = [CCEaseBounce actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseBounce* (o)
JSBool JSPROXY_CCEaseBounce_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseBounce* ret_val;

	ret_val = [CCEaseBounce actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseBounce* (o)
JSBool JSPROXY_CCEaseBounce_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseBounce* ret_val;

	ret_val = [CCEaseBounce action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseBounce_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseBounce_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseBounce_class->name = name;
	JSPROXY_CCEaseBounce_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounce_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounce_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounce_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseBounce_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseBounce_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseBounce_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseBounce_class->finalize = JSPROXY_CCEaseBounce_finalize;
//	JSPROXY_CCEaseBounce_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("bounceTime", JSPROXY_CCEaseBounce_bounceTime_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseBounce_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseBounce_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseBounce_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseBounce_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseBounce_class, JSPROXY_CCEaseBounce_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseBounce

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseBounce_class, JSPROXY_CCEaseBounce_object, NULL);
	JSPROXY_CCEaseBounce *proxy = [[JSPROXY_CCEaseBounce alloc] initWithJSObject:jsobj class:[CCEaseBounce class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounceOut
 */
#pragma mark - CCEaseBounceOut

JSClass* JSPROXY_CCEaseBounceOut_class = NULL;
JSObject* JSPROXY_CCEaseBounceOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseBounceOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseBounceOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseBounceOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseBounceOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseBounceOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseBounceOut *real = (CCEaseBounceOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounceOut* (o)
JSBool JSPROXY_CCEaseBounceOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseBounceOut* ret_val;

	ret_val = [CCEaseBounceOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseBounceOut* (o)
JSBool JSPROXY_CCEaseBounceOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseBounceOut* ret_val;

	ret_val = [CCEaseBounceOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseBounceOut* (o)
JSBool JSPROXY_CCEaseBounceOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseBounceOut* ret_val;

	ret_val = [CCEaseBounceOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseBounceOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseBounceOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseBounceOut_class->name = name;
	JSPROXY_CCEaseBounceOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseBounceOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseBounceOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseBounceOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseBounceOut_class->finalize = JSPROXY_CCEaseBounceOut_finalize;
//	JSPROXY_CCEaseBounceOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseBounceOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseBounceOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseBounceOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseBounceOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseBounceOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseBounce_object, JSPROXY_CCEaseBounceOut_class, JSPROXY_CCEaseBounceOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseBounceOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseBounceOut_class, JSPROXY_CCEaseBounceOut_object, NULL);
	JSPROXY_CCEaseBounceOut *proxy = [[JSPROXY_CCEaseBounceOut alloc] initWithJSObject:jsobj class:[CCEaseBounceOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeOut
 */
#pragma mark - CCFadeOut

JSClass* JSPROXY_CCFadeOut_class = NULL;
JSObject* JSPROXY_CCFadeOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCFadeOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFadeOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFadeOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFadeOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCFadeOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFadeOut *real = (CCFadeOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFadeOut* (o)
JSBool JSPROXY_CCFadeOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCFadeOut* ret_val;

	ret_val = [CCFadeOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFadeOut* (o)
JSBool JSPROXY_CCFadeOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFadeOut* ret_val;

	ret_val = [CCFadeOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFadeOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFadeOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFadeOut_class->name = name;
	JSPROXY_CCFadeOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFadeOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFadeOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFadeOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFadeOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFadeOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCFadeOut_class->convert = JS_ConvertStub;
	JSPROXY_CCFadeOut_class->finalize = JSPROXY_CCFadeOut_finalize;
//	JSPROXY_CCFadeOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCFadeOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFadeOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFadeOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFadeOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCFadeOut_class, JSPROXY_CCFadeOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFadeOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFadeOut_class, JSPROXY_CCFadeOut_object, NULL);
	JSPROXY_CCFadeOut *proxy = [[JSPROXY_CCFadeOut alloc] initWithJSObject:jsobj class:[CCFadeOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimationCache
 */
#pragma mark - CCAnimationCache

JSClass* JSPROXY_CCAnimationCache_class = NULL;
JSObject* JSPROXY_CCAnimationCache_object = NULL;
 // Constructor
JSBool JSPROXY_CCAnimationCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAnimationCache createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAnimationCache_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAnimationCache)", obj);
}

// Arguments: CCAnimation*, NSString*
// Ret value: void (None)
JSBool JSPROXY_CCAnimationCache_addAnimation_name_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; NSString* arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	[real addAnimation:(CCAnimation*)arg0 name:(NSString*)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCAnimationCache_addAnimationsWithFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	[real addAnimationsWithFile:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCAnimation* (o)
JSBool JSPROXY_CCAnimationCache_animationByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCAnimation* ret_val;

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	ret_val = [real animationByName:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCAnimationCache_purgeSharedAnimationCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	[CCAnimationCache purgeSharedAnimationCache ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCAnimationCache_removeAnimationByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimationCache *real = (CCAnimationCache*) [proxy realObj];
	[real removeAnimationByName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAnimationCache* (o)
JSBool JSPROXY_CCAnimationCache_sharedAnimationCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCAnimationCache* ret_val;

	ret_val = [CCAnimationCache sharedAnimationCache ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCAnimationCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAnimationCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAnimationCache_class->name = name;
	JSPROXY_CCAnimationCache_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAnimationCache_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAnimationCache_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAnimationCache_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAnimationCache_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAnimationCache_class->resolve = JS_ResolveStub;
	JSPROXY_CCAnimationCache_class->convert = JS_ConvertStub;
	JSPROXY_CCAnimationCache_class->finalize = JSPROXY_CCAnimationCache_finalize;
//	JSPROXY_CCAnimationCache_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addAnimationName", JSPROXY_CCAnimationCache_addAnimation_name_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("addAnimationsWithFile", JSPROXY_CCAnimationCache_addAnimationsWithFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAnimationByName", JSPROXY_CCAnimationCache_animationByName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeAnimationByName", JSPROXY_CCAnimationCache_removeAnimationByName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedAnimationCache", JSPROXY_CCAnimationCache_purgeSharedAnimationCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getInstance", JSPROXY_CCAnimationCache_sharedAnimationCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCAnimationCache_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCAnimationCache_class, JSPROXY_CCAnimationCache_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAnimationCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAnimationCache_class, JSPROXY_CCAnimationCache_object, NULL);
	JSPROXY_CCAnimationCache *proxy = [[JSPROXY_CCAnimationCache alloc] initWithJSObject:jsobj class:[CCAnimationCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRepeatForever
 */
#pragma mark - CCRepeatForever

JSClass* JSPROXY_CCRepeatForever_class = NULL;
JSObject* JSPROXY_CCRepeatForever_object = NULL;
 // Constructor
JSBool JSPROXY_CCRepeatForever_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCRepeatForever createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCRepeatForever_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCRepeatForever)", obj);
}

// Arguments: CCActionInterval*
// Ret value: CCRepeatForever* (o)
JSBool JSPROXY_CCRepeatForever_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCRepeatForever* ret_val;

	ret_val = [CCRepeatForever actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: None (None)
JSBool JSPROXY_CCRepeatForever_initWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCRepeatForever *real = [(CCRepeatForever*)[proxy.klass alloc] initWithAction:(CCActionInterval*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCRepeatForever_innerAction(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCRepeatForever *real = (CCRepeatForever*) [proxy realObj];
	ret_val = [real innerAction ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: void (None)
JSBool JSPROXY_CCRepeatForever_setInnerAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCRepeatForever *real = (CCRepeatForever*) [proxy realObj];
	[real setInnerAction:(CCActionInterval*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCRepeatForever* (o)
JSBool JSPROXY_CCRepeatForever_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCRepeatForever* ret_val;

	ret_val = [CCRepeatForever action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCRepeatForever_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCRepeatForever_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCRepeatForever_class->name = name;
	JSPROXY_CCRepeatForever_class->addProperty = JS_PropertyStub;
	JSPROXY_CCRepeatForever_class->delProperty = JS_PropertyStub;
	JSPROXY_CCRepeatForever_class->getProperty = JS_PropertyStub;
	JSPROXY_CCRepeatForever_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCRepeatForever_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCRepeatForever_class->resolve = JS_ResolveStub;
	JSPROXY_CCRepeatForever_class->convert = JS_ConvertStub;
	JSPROXY_CCRepeatForever_class->finalize = JSPROXY_CCRepeatForever_finalize;
//	JSPROXY_CCRepeatForever_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithAction", JSPROXY_CCRepeatForever_initWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getInnerAction", JSPROXY_CCRepeatForever_innerAction, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setInnerAction", JSPROXY_CCRepeatForever_setInnerAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCRepeatForever_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCRepeatForever_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCRepeatForever_object = JS_InitClass(cx, globalObj, JSPROXY_CCAction_object, JSPROXY_CCRepeatForever_class, JSPROXY_CCRepeatForever_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCRepeatForever

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCRepeatForever_class, JSPROXY_CCRepeatForever_object, NULL);
	JSPROXY_CCRepeatForever *proxy = [[JSPROXY_CCRepeatForever alloc] initWithJSObject:jsobj class:[CCRepeatForever class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeIn
 */
#pragma mark - CCFadeIn

JSClass* JSPROXY_CCFadeIn_class = NULL;
JSObject* JSPROXY_CCFadeIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCFadeIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFadeIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFadeIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFadeIn)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCFadeIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFadeIn *real = (CCFadeIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFadeIn* (o)
JSBool JSPROXY_CCFadeIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCFadeIn* ret_val;

	ret_val = [CCFadeIn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFadeIn* (o)
JSBool JSPROXY_CCFadeIn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFadeIn* ret_val;

	ret_val = [CCFadeIn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFadeIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFadeIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFadeIn_class->name = name;
	JSPROXY_CCFadeIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFadeIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFadeIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFadeIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFadeIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFadeIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCFadeIn_class->convert = JS_ConvertStub;
	JSPROXY_CCFadeIn_class->finalize = JSPROXY_CCFadeIn_finalize;
//	JSPROXY_CCFadeIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCFadeIn_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFadeIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFadeIn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFadeIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCFadeIn_class, JSPROXY_CCFadeIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFadeIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFadeIn_class, JSPROXY_CCFadeIn_object, NULL);
	JSPROXY_CCFadeIn *proxy = [[JSPROXY_CCFadeIn alloc] initWithJSObject:jsobj class:[CCFadeIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSun
 */
#pragma mark - CCParticleSun

JSClass* JSPROXY_CCParticleSun_class = NULL;
JSObject* JSPROXY_CCParticleSun_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleSun_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleSun createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleSun_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleSun)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleSun_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSun *real = [(CCParticleSun*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSun* (o)
JSBool JSPROXY_CCParticleSun_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSun* ret_val;

	ret_val = [CCParticleSun particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSun* (o)
JSBool JSPROXY_CCParticleSun_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSun* ret_val;

	ret_val = [CCParticleSun particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSun* (o)
JSBool JSPROXY_CCParticleSun_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleSun* ret_val;

	ret_val = [CCParticleSun node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleSun_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleSun_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleSun_class->name = name;
	JSPROXY_CCParticleSun_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleSun_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleSun_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleSun_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleSun_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleSun_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleSun_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleSun_class->finalize = JSPROXY_CCParticleSun_finalize;
//	JSPROXY_CCParticleSun_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleSun_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleSun_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleSun_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleSun_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleSun_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleSun_class, JSPROXY_CCParticleSun_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleSun

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleSun_class, JSPROXY_CCParticleSun_object, NULL);
	JSPROXY_CCParticleSun *proxy = [[JSPROXY_CCParticleSun alloc] initWithJSObject:jsobj class:[CCParticleSun class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressVertical
 */
#pragma mark - CCTransitionProgressVertical

JSClass* JSPROXY_CCTransitionProgressVertical_class = NULL;
JSObject* JSPROXY_CCTransitionProgressVertical_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionProgressVertical_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionProgressVertical createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionProgressVertical_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionProgressVertical)", obj);
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCTransitionProgressVertical_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	CCTransitionProgressVertical *real = (CCTransitionProgressVertical*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:(CCRenderTexture*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressVertical* (o)
JSBool JSPROXY_CCTransitionProgressVertical_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionProgressVertical* ret_val;

	ret_val = [CCTransitionProgressVertical transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressVertical* (o)
JSBool JSPROXY_CCTransitionProgressVertical_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionProgressVertical* ret_val;

	ret_val = [CCTransitionProgressVertical node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionProgressVertical_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionProgressVertical_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionProgressVertical_class->name = name;
	JSPROXY_CCTransitionProgressVertical_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressVertical_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressVertical_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressVertical_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionProgressVertical_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionProgressVertical_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionProgressVertical_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionProgressVertical_class->finalize = JSPROXY_CCTransitionProgressVertical_finalize;
//	JSPROXY_CCTransitionProgressVertical_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSPROXY_CCTransitionProgressVertical_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionProgressVertical_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionProgressVertical_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionProgressVertical_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionProgress_object, JSPROXY_CCTransitionProgressVertical_class, JSPROXY_CCTransitionProgressVertical_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionProgressVertical

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionProgressVertical_class, JSPROXY_CCTransitionProgressVertical_object, NULL);
	JSPROXY_CCTransitionProgressVertical *proxy = [[JSPROXY_CCTransitionProgressVertical alloc] initWithJSObject:jsobj class:[CCTransitionProgressVertical class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFileUtils
 */
#pragma mark - CCFileUtils

JSClass* JSPROXY_CCFileUtils_class = NULL;
JSObject* JSPROXY_CCFileUtils_object = NULL;
 // Constructor
JSBool JSPROXY_CCFileUtils_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFileUtils createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFileUtils_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFileUtils)", obj);
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCFileUtils_enableFallbackSuffixes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real enableFallbackSuffixes ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: NSString* (S)
JSBool JSPROXY_CCFileUtils_fullPathFromRelativePath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	NSString* ret_val;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	ret_val = [real fullPathFromRelativePath:(NSString*)arg0  ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCFileUtils_purgeCachedEntries(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real purgeCachedEntries ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCFileUtils_setEnableFallbackSuffixes_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFileUtils *real = (CCFileUtils*) [proxy realObj];
	[real setEnableFallbackSuffixes:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFileUtils* (o)
JSBool JSPROXY_CCFileUtils_sharedFileUtils_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFileUtils* ret_val;

	ret_val = [CCFileUtils sharedFileUtils ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFileUtils_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFileUtils_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFileUtils_class->name = name;
	JSPROXY_CCFileUtils_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFileUtils_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFileUtils_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFileUtils_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFileUtils_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFileUtils_class->resolve = JS_ResolveStub;
	JSPROXY_CCFileUtils_class->convert = JS_ConvertStub;
	JSPROXY_CCFileUtils_class->finalize = JSPROXY_CCFileUtils_finalize;
//	JSPROXY_CCFileUtils_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getEnableFallbackSuffixes", JSPROXY_CCFileUtils_enableFallbackSuffixes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("fullPathFromRelativePath", JSPROXY_CCFileUtils_fullPathFromRelativePath_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("purgeCachedEntries", JSPROXY_CCFileUtils_purgeCachedEntries, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setEnableFallbackSuffixes", JSPROXY_CCFileUtils_setEnableFallbackSuffixes_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("sharedFileUtils", JSPROXY_CCFileUtils_sharedFileUtils_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFileUtils_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCFileUtils_class, JSPROXY_CCFileUtils_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFileUtils

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFileUtils_class, JSPROXY_CCFileUtils_object, NULL);
	JSPROXY_CCFileUtils *proxy = [[JSPROXY_CCFileUtils alloc] initWithJSObject:jsobj class:[CCFileUtils class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSpiral
 */
#pragma mark - CCParticleSpiral

JSClass* JSPROXY_CCParticleSpiral_class = NULL;
JSObject* JSPROXY_CCParticleSpiral_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleSpiral_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleSpiral createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleSpiral_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleSpiral)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleSpiral_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSpiral *real = [(CCParticleSpiral*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSpiral* (o)
JSBool JSPROXY_CCParticleSpiral_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSpiral* ret_val;

	ret_val = [CCParticleSpiral particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSpiral* (o)
JSBool JSPROXY_CCParticleSpiral_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSpiral* ret_val;

	ret_val = [CCParticleSpiral particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSpiral* (o)
JSBool JSPROXY_CCParticleSpiral_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleSpiral* ret_val;

	ret_val = [CCParticleSpiral node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleSpiral_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleSpiral_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleSpiral_class->name = name;
	JSPROXY_CCParticleSpiral_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleSpiral_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleSpiral_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleSpiral_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleSpiral_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleSpiral_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleSpiral_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleSpiral_class->finalize = JSPROXY_CCParticleSpiral_finalize;
//	JSPROXY_CCParticleSpiral_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleSpiral_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleSpiral_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleSpiral_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleSpiral_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleSpiral_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleSpiral_class, JSPROXY_CCParticleSpiral_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleSpiral

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleSpiral_class, JSPROXY_CCParticleSpiral_object, NULL);
	JSPROXY_CCParticleSpiral *proxy = [[JSPROXY_CCParticleSpiral alloc] initWithJSObject:jsobj class:[CCParticleSpiral class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAtlasNode
 */
#pragma mark - CCAtlasNode

JSClass* JSPROXY_CCAtlasNode_class = NULL;
JSObject* JSPROXY_CCAtlasNode_object = NULL;
 // Constructor
JSBool JSPROXY_CCAtlasNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAtlasNode createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAtlasNode_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAtlasNode)", obj);
}

// Arguments: NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: CCAtlasNode* (o)
JSBool JSPROXY_CCAtlasNode_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCAtlasNode* ret_val;

	ret_val = [CCAtlasNode atlasWithTileFile:(NSString*)arg0 tileWidth:(NSUInteger)arg1 tileHeight:(NSUInteger)arg2 itemsToRender:(NSUInteger)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccBlendFunc ({_ccBlendFunc=II})
JSBool JSPROXY_CCAtlasNode_blendFunc(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccBlendFunc ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real blendFunc ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT32, 2 );
	ccBlendFunc* buffer = (ccBlendFunc*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCAtlasNode_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCAtlasNode_initWithTileFile_tileWidth_tileHeight_itemsToRender_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = [(CCAtlasNode*)[proxy.klass alloc] initWithTileFile:(NSString*)arg0 tileWidth:(NSUInteger)arg1 tileHeight:(NSUInteger)arg2 itemsToRender:(NSUInteger)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCAtlasNode_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCAtlasNode_quadsToDraw(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real quadsToDraw ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccBlendFunc
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_setBlendFunc_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccBlendFunc arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccBlendFunc*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setBlendFunc:(ccBlendFunc)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_setQuadsToDraw_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setQuadsToDraw:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTextureAtlas*
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_setTextureAtlas_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setTextureAtlas:(CCTextureAtlas*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureAtlas* (o)
JSBool JSPROXY_CCAtlasNode_textureAtlas(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTextureAtlas* ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real textureAtlas ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_updateAtlasValues(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real updateAtlasValues ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCAtlasNode_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCAtlasNode_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCAtlasNode_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCAtlasNode *real = (CCAtlasNode*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAtlasNode* (o)
JSBool JSPROXY_CCAtlasNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCAtlasNode* ret_val;

	ret_val = [CCAtlasNode node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCAtlasNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAtlasNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAtlasNode_class->name = name;
	JSPROXY_CCAtlasNode_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAtlasNode_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAtlasNode_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAtlasNode_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAtlasNode_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAtlasNode_class->resolve = JS_ResolveStub;
	JSPROXY_CCAtlasNode_class->convert = JS_ConvertStub;
	JSPROXY_CCAtlasNode_class->finalize = JSPROXY_CCAtlasNode_finalize;
//	JSPROXY_CCAtlasNode_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBlendFunc", JSPROXY_CCAtlasNode_blendFunc, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getColor", JSPROXY_CCAtlasNode_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTileFileTileWidthTileHeightItemsToRender", JSPROXY_CCAtlasNode_initWithTileFile_tileWidth_tileHeight_itemsToRender_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSPROXY_CCAtlasNode_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getQuadsToDraw", JSPROXY_CCAtlasNode_quadsToDraw, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSPROXY_CCAtlasNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCAtlasNode_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCAtlasNode_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setQuadsToDraw", JSPROXY_CCAtlasNode_setQuadsToDraw_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTextureAtlas", JSPROXY_CCAtlasNode_setTextureAtlas_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTextureAtlas", JSPROXY_CCAtlasNode_textureAtlas, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("updateAtlasValues", JSPROXY_CCAtlasNode_updateAtlasValues, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCAtlasNode_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCAtlasNode_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCAtlasNode_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCAtlasNode_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("atlasWithTileFileTileWidthTileHeightItemsToRender", JSPROXY_CCAtlasNode_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCAtlasNode_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCAtlasNode_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCAtlasNode_class, JSPROXY_CCAtlasNode_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAtlasNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAtlasNode_class, JSPROXY_CCAtlasNode_object, NULL);
	JSPROXY_CCAtlasNode *proxy = [[JSPROXY_CCAtlasNode alloc] initWithJSObject:jsobj class:[CCAtlasNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTileMapAtlas
 */
#pragma mark - CCTileMapAtlas

JSClass* JSPROXY_CCTileMapAtlas_class = NULL;
JSObject* JSPROXY_CCTileMapAtlas_object = NULL;
 // Constructor
JSBool JSPROXY_CCTileMapAtlas_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTileMapAtlas createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTileMapAtlas_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTileMapAtlas)", obj);
}

// Arguments: NSString*, NSString*, int, int
// Ret value: None (None)
JSBool JSPROXY_CCTileMapAtlas_initWithTileFile_mapFile_tileWidth_tileHeight_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCTileMapAtlas *real = [(CCTileMapAtlas*)[proxy.klass alloc] initWithTileFile:(NSString*)arg0 mapFile:(NSString*)arg1 tileWidth:(int)arg2 tileHeight:(int)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTileMapAtlas_releaseMap(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTileMapAtlas *real = (CCTileMapAtlas*) [proxy realObj];
	[real releaseMap ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor3B, ccGridSize
// Ret value: void (None)
JSBool JSPROXY_CCTileMapAtlas_setTile_at_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; ccGridSize arg1; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTileMapAtlas *real = (CCTileMapAtlas*) [proxy realObj];
	[real setTile:(ccColor3B)arg0 at:(ccGridSize)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCTileMapAtlas_tileAt_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	ccColor3B ret_val;

	CCTileMapAtlas *real = (CCTileMapAtlas*) [proxy realObj];
	ret_val = [real tileAt:(ccGridSize)arg0  ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, int, int
// Ret value: CCTileMapAtlas* (o)
JSBool JSPROXY_CCTileMapAtlas_tileMapAtlasWithTileFile_mapFile_tileWidth_tileHeight__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCTileMapAtlas* ret_val;

	ret_val = [CCTileMapAtlas tileMapAtlasWithTileFile:(NSString*)arg0 mapFile:(NSString*)arg1 tileWidth:(int)arg2 tileHeight:(int)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: CCTileMapAtlas* (o)
JSBool JSPROXY_CCTileMapAtlas_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCTileMapAtlas* ret_val;

	ret_val = [CCTileMapAtlas atlasWithTileFile:(NSString*)arg0 tileWidth:(NSUInteger)arg1 tileHeight:(NSUInteger)arg2 itemsToRender:(NSUInteger)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTileMapAtlas* (o)
JSBool JSPROXY_CCTileMapAtlas_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTileMapAtlas* ret_val;

	ret_val = [CCTileMapAtlas node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTileMapAtlas_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTileMapAtlas_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTileMapAtlas_class->name = name;
	JSPROXY_CCTileMapAtlas_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTileMapAtlas_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTileMapAtlas_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTileMapAtlas_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTileMapAtlas_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTileMapAtlas_class->resolve = JS_ResolveStub;
	JSPROXY_CCTileMapAtlas_class->convert = JS_ConvertStub;
	JSPROXY_CCTileMapAtlas_class->finalize = JSPROXY_CCTileMapAtlas_finalize;
//	JSPROXY_CCTileMapAtlas_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTileFileMapFileTileWidthTileHeight", JSPROXY_CCTileMapAtlas_initWithTileFile_mapFile_tileWidth_tileHeight_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("releaseMap", JSPROXY_CCTileMapAtlas_releaseMap, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTileAt", JSPROXY_CCTileMapAtlas_setTile_at_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("tileAt", JSPROXY_CCTileMapAtlas_tileAt_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTileMapAtlas_tileMapAtlasWithTileFile_mapFile_tileWidth_tileHeight__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("atlasWithTileFileTileWidthTileHeightItemsToRender", JSPROXY_CCTileMapAtlas_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTileMapAtlas_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTileMapAtlas_object = JS_InitClass(cx, globalObj, JSPROXY_CCAtlasNode_object, JSPROXY_CCTileMapAtlas_class, JSPROXY_CCTileMapAtlas_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTileMapAtlas

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTileMapAtlas_class, JSPROXY_CCTileMapAtlas_object, NULL);
	JSPROXY_CCTileMapAtlas *proxy = [[JSPROXY_CCTileMapAtlas alloc] initWithJSObject:jsobj class:[CCTileMapAtlas class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXTilesetInfo
 */
#pragma mark - CCTMXTilesetInfo

JSClass* JSPROXY_CCTMXTilesetInfo_class = NULL;
JSObject* JSPROXY_CCTMXTilesetInfo_object = NULL;
 // Constructor
JSBool JSPROXY_CCTMXTilesetInfo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTMXTilesetInfo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTMXTilesetInfo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTMXTilesetInfo)", obj);
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSPROXY_CCTMXTilesetInfo_firstGid(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	unsigned int ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real firstGid ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXTilesetInfo_imageSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real imageSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSPROXY_CCTMXTilesetInfo_margin(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	unsigned int ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real margin ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTMXTilesetInfo_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real name ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: CGRect (N/A)
JSBool JSPROXY_CCTMXTilesetInfo_rectForGID_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CGRect ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real rectForGID:(unsigned int)arg0  ];

	jsval ret_jsval = CGRect_to_jsval( cx, (CGRect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSPROXY_CCTMXTilesetInfo_setFirstGid_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	[real setFirstGid:(unsigned int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCTMXTilesetInfo_setImageSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	[real setImageSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSPROXY_CCTMXTilesetInfo_setMargin_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	[real setMargin:(unsigned int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTMXTilesetInfo_setName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	[real setName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTMXTilesetInfo_setSourceImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	[real setSourceImage:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSPROXY_CCTMXTilesetInfo_setSpacing_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	[real setSpacing:(unsigned int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCTMXTilesetInfo_setTileSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	[real setTileSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTMXTilesetInfo_sourceImage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real sourceImage ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSPROXY_CCTMXTilesetInfo_spacing(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	unsigned int ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real spacing ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXTilesetInfo_tileSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXTilesetInfo *real = (CCTMXTilesetInfo*) [proxy realObj];
	ret_val = [real tileSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

void JSPROXY_CCTMXTilesetInfo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTMXTilesetInfo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTMXTilesetInfo_class->name = name;
	JSPROXY_CCTMXTilesetInfo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTMXTilesetInfo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTMXTilesetInfo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTMXTilesetInfo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTMXTilesetInfo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTMXTilesetInfo_class->resolve = JS_ResolveStub;
	JSPROXY_CCTMXTilesetInfo_class->convert = JS_ConvertStub;
	JSPROXY_CCTMXTilesetInfo_class->finalize = JSPROXY_CCTMXTilesetInfo_finalize;
//	JSPROXY_CCTMXTilesetInfo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getFirstGid", JSPROXY_CCTMXTilesetInfo_firstGid, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getImageSize", JSPROXY_CCTMXTilesetInfo_imageSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMargin", JSPROXY_CCTMXTilesetInfo_margin, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getName", JSPROXY_CCTMXTilesetInfo_name, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("rectForGID", JSPROXY_CCTMXTilesetInfo_rectForGID_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFirstGid", JSPROXY_CCTMXTilesetInfo_setFirstGid_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setImageSize", JSPROXY_CCTMXTilesetInfo_setImageSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMargin", JSPROXY_CCTMXTilesetInfo_setMargin_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setName", JSPROXY_CCTMXTilesetInfo_setName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSourceImage", JSPROXY_CCTMXTilesetInfo_setSourceImage_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSpacing", JSPROXY_CCTMXTilesetInfo_setSpacing_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTileSize", JSPROXY_CCTMXTilesetInfo_setTileSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSourceImage", JSPROXY_CCTMXTilesetInfo_sourceImage, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSpacing", JSPROXY_CCTMXTilesetInfo_spacing, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTileSize", JSPROXY_CCTMXTilesetInfo_tileSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCTMXTilesetInfo_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTMXTilesetInfo_class, JSPROXY_CCTMXTilesetInfo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTMXTilesetInfo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTMXTilesetInfo_class, JSPROXY_CCTMXTilesetInfo_object, NULL);
	JSPROXY_CCTMXTilesetInfo *proxy = [[JSPROXY_CCTMXTilesetInfo alloc] initWithJSObject:jsobj class:[CCTMXTilesetInfo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleFlower
 */
#pragma mark - CCParticleFlower

JSClass* JSPROXY_CCParticleFlower_class = NULL;
JSObject* JSPROXY_CCParticleFlower_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleFlower_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleFlower createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleFlower_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleFlower)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleFlower_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleFlower *real = [(CCParticleFlower*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleFlower* (o)
JSBool JSPROXY_CCParticleFlower_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleFlower* ret_val;

	ret_val = [CCParticleFlower particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleFlower* (o)
JSBool JSPROXY_CCParticleFlower_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleFlower* ret_val;

	ret_val = [CCParticleFlower particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleFlower* (o)
JSBool JSPROXY_CCParticleFlower_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleFlower* ret_val;

	ret_val = [CCParticleFlower node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleFlower_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleFlower_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleFlower_class->name = name;
	JSPROXY_CCParticleFlower_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleFlower_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleFlower_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleFlower_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleFlower_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleFlower_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleFlower_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleFlower_class->finalize = JSPROXY_CCParticleFlower_finalize;
//	JSPROXY_CCParticleFlower_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleFlower_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleFlower_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleFlower_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleFlower_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleFlower_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleFlower_class, JSPROXY_CCParticleFlower_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleFlower

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleFlower_class, JSPROXY_CCParticleFlower_object, NULL);
	JSPROXY_CCParticleFlower *proxy = [[JSPROXY_CCParticleFlower alloc] initWithJSObject:jsobj class:[CCParticleFlower class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCallBlock
 */
#pragma mark - CCCallBlock

JSClass* JSPROXY_CCCallBlock_class = NULL;
JSObject* JSPROXY_CCCallBlock_object = NULL;
 // Constructor
JSBool JSPROXY_CCCallBlock_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCCallBlock createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCCallBlock_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCCallBlock)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCCallBlock_execute(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCCallBlock *real = (CCCallBlock*) [proxy realObj];
	[real execute ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCallBlock* (o)
JSBool JSPROXY_CCCallBlock_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCCallBlock* ret_val;

	ret_val = [CCCallBlock action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCCallBlock_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCCallBlock_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCCallBlock_class->name = name;
	JSPROXY_CCCallBlock_class->addProperty = JS_PropertyStub;
	JSPROXY_CCCallBlock_class->delProperty = JS_PropertyStub;
	JSPROXY_CCCallBlock_class->getProperty = JS_PropertyStub;
	JSPROXY_CCCallBlock_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCCallBlock_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCCallBlock_class->resolve = JS_ResolveStub;
	JSPROXY_CCCallBlock_class->convert = JS_ConvertStub;
	JSPROXY_CCCallBlock_class->finalize = JSPROXY_CCCallBlock_finalize;
//	JSPROXY_CCCallBlock_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("execute", JSPROXY_CCCallBlock_execute, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("action", JSPROXY_CCCallBlock_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCCallBlock_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCCallBlock_class, JSPROXY_CCCallBlock_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCCallBlock

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCCallBlock_class, JSPROXY_CCCallBlock_object, NULL);
	JSPROXY_CCCallBlock *proxy = [[JSPROXY_CCCallBlock alloc] initWithJSObject:jsobj class:[CCCallBlock class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionShrinkGrow
 */
#pragma mark - CCTransitionShrinkGrow

JSClass* JSPROXY_CCTransitionShrinkGrow_class = NULL;
JSObject* JSPROXY_CCTransitionShrinkGrow_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionShrinkGrow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionShrinkGrow createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionShrinkGrow_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionShrinkGrow)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionShrinkGrow_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionShrinkGrow *real = [(CCTransitionShrinkGrow*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionShrinkGrow_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionShrinkGrow *real = (CCTransitionShrinkGrow*) [proxy realObj];
	ret_val = [real easeActionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionShrinkGrow* (o)
JSBool JSPROXY_CCTransitionShrinkGrow_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionShrinkGrow* ret_val;

	ret_val = [CCTransitionShrinkGrow transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionShrinkGrow* (o)
JSBool JSPROXY_CCTransitionShrinkGrow_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionShrinkGrow* ret_val;

	ret_val = [CCTransitionShrinkGrow node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionShrinkGrow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionShrinkGrow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionShrinkGrow_class->name = name;
	JSPROXY_CCTransitionShrinkGrow_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionShrinkGrow_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionShrinkGrow_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionShrinkGrow_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionShrinkGrow_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionShrinkGrow_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionShrinkGrow_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionShrinkGrow_class->finalize = JSPROXY_CCTransitionShrinkGrow_finalize;
//	JSPROXY_CCTransitionShrinkGrow_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionShrinkGrow_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSPROXY_CCTransitionShrinkGrow_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionShrinkGrow_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionShrinkGrow_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionShrinkGrow_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionShrinkGrow_class, JSPROXY_CCTransitionShrinkGrow_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionShrinkGrow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionShrinkGrow_class, JSPROXY_CCTransitionShrinkGrow_object, NULL);
	JSPROXY_CCTransitionShrinkGrow *proxy = [[JSPROXY_CCTransitionShrinkGrow alloc] initWithJSObject:jsobj class:[CCTransitionShrinkGrow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseExponentialInOut
 */
#pragma mark - CCEaseExponentialInOut

JSClass* JSPROXY_CCEaseExponentialInOut_class = NULL;
JSObject* JSPROXY_CCEaseExponentialInOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseExponentialInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseExponentialInOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseExponentialInOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseExponentialInOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseExponentialInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseExponentialInOut *real = (CCEaseExponentialInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseExponentialInOut* (o)
JSBool JSPROXY_CCEaseExponentialInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseExponentialInOut* ret_val;

	ret_val = [CCEaseExponentialInOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseExponentialInOut* (o)
JSBool JSPROXY_CCEaseExponentialInOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseExponentialInOut* ret_val;

	ret_val = [CCEaseExponentialInOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseExponentialInOut* (o)
JSBool JSPROXY_CCEaseExponentialInOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseExponentialInOut* ret_val;

	ret_val = [CCEaseExponentialInOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseExponentialInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseExponentialInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseExponentialInOut_class->name = name;
	JSPROXY_CCEaseExponentialInOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialInOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialInOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialInOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseExponentialInOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseExponentialInOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseExponentialInOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseExponentialInOut_class->finalize = JSPROXY_CCEaseExponentialInOut_finalize;
//	JSPROXY_CCEaseExponentialInOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseExponentialInOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseExponentialInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseExponentialInOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseExponentialInOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseExponentialInOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseExponentialInOut_class, JSPROXY_CCEaseExponentialInOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseExponentialInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseExponentialInOut_class, JSPROXY_CCEaseExponentialInOut_object, NULL);
	JSPROXY_CCEaseExponentialInOut *proxy = [[JSPROXY_CCEaseExponentialInOut alloc] initWithJSObject:jsobj class:[CCEaseExponentialInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleRain
 */
#pragma mark - CCParticleRain

JSClass* JSPROXY_CCParticleRain_class = NULL;
JSObject* JSPROXY_CCParticleRain_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleRain_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleRain createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleRain_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleRain)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleRain_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleRain *real = [(CCParticleRain*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleRain* (o)
JSBool JSPROXY_CCParticleRain_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleRain* ret_val;

	ret_val = [CCParticleRain particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleRain* (o)
JSBool JSPROXY_CCParticleRain_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleRain* ret_val;

	ret_val = [CCParticleRain particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleRain* (o)
JSBool JSPROXY_CCParticleRain_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleRain* ret_val;

	ret_val = [CCParticleRain node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleRain_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleRain_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleRain_class->name = name;
	JSPROXY_CCParticleRain_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleRain_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleRain_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleRain_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleRain_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleRain_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleRain_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleRain_class->finalize = JSPROXY_CCParticleRain_finalize;
//	JSPROXY_CCParticleRain_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleRain_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleRain_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleRain_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleRain_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleRain_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleRain_class, JSPROXY_CCParticleRain_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleRain

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleRain_class, JSPROXY_CCParticleRain_object, NULL);
	JSPROXY_CCParticleRain *proxy = [[JSPROXY_CCParticleRain alloc] initWithJSObject:jsobj class:[CCParticleRain class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemFont
 */
#pragma mark - CCMenuItemFont

JSClass* JSPROXY_CCMenuItemFont_class = NULL;
JSObject* JSPROXY_CCMenuItemFont_object = NULL;
 // Constructor
JSBool JSPROXY_CCMenuItemFont_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMenuItemFont createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMenuItemFont_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMenuItemFont)", obj);
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCMenuItemFont_fontName_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	ret_val = [CCMenuItemFont fontName ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCMenuItemFont_fontName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	ret_val = [real fontName ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCMenuItemFont_fontSize_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	ret_val = [CCMenuItemFont fontSize ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCMenuItemFont_fontSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	ret_val = [real fontSize ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*, void (^)(id)
// Ret value: None (None)
JSBool JSPROXY_CCMenuItemFont_initWithString_block_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; js_block arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemFont *real = [(CCMenuItemFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 block:(void (^)(id))arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemFont_setFontName__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	[CCMenuItemFont setFontName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemFont_setFontName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	[real setFontName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemFont_setFontSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	[CCMenuItemFont setFontSize:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemFont_setFontSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemFont *real = (CCMenuItemFont*) [proxy realObj];
	[real setFontSize:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: CCMenuItemFont* (o)
JSBool JSPROXY_CCMenuItemFont_itemWithLabel__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCMenuItemFont* ret_val;

	ret_val = [CCMenuItemFont itemWithLabel:(CCNode*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCNode*, void (^)(id)
// Ret value: CCMenuItemFont* (o)
JSBool JSPROXY_CCMenuItemFont_itemWithLabel_block__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; js_block arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemFont* ret_val;

	ret_val = [CCMenuItemFont itemWithLabel:(CCNode*)arg0 block:(void (^)(id))arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItemFont* (o)
JSBool JSPROXY_CCMenuItemFont_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemFont* ret_val;

	ret_val = [CCMenuItemFont itemWithBlock:(void (^)(id))arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItemFont* (o)
JSBool JSPROXY_CCMenuItemFont_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItemFont* ret_val;

	ret_val = [CCMenuItemFont node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMenuItemFont_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMenuItemFont_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMenuItemFont_class->name = name;
	JSPROXY_CCMenuItemFont_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemFont_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemFont_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemFont_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMenuItemFont_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMenuItemFont_class->resolve = JS_ResolveStub;
	JSPROXY_CCMenuItemFont_class->convert = JS_ConvertStub;
	JSPROXY_CCMenuItemFont_class->finalize = JSPROXY_CCMenuItemFont_finalize;
//	JSPROXY_CCMenuItemFont_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("fontName", JSPROXY_CCMenuItemFont_fontName, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("fontSize", JSPROXY_CCMenuItemFont_fontSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringBlock", JSPROXY_CCMenuItemFont_initWithString_block_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFontName", JSPROXY_CCMenuItemFont_setFontName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFontSize", JSPROXY_CCMenuItemFont_setFontSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("fontName", JSPROXY_CCMenuItemFont_fontName_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("fontSize", JSPROXY_CCMenuItemFont_fontSize_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCMenuItemFont_itemWithString_block__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFontName", JSPROXY_CCMenuItemFont_setFontName__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFontSize", JSPROXY_CCMenuItemFont_setFontSize__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithLabel", JSPROXY_CCMenuItemFont_itemWithLabel__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithLabelBlock", JSPROXY_CCMenuItemFont_itemWithLabel_block__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithBlock", JSPROXY_CCMenuItemFont_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCMenuItemFont_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMenuItemFont_object = JS_InitClass(cx, globalObj, JSPROXY_CCMenuItemLabel_object, JSPROXY_CCMenuItemFont_class, JSPROXY_CCMenuItemFont_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMenuItemFont

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMenuItemFont_class, JSPROXY_CCMenuItemFont_object, NULL);
	JSPROXY_CCMenuItemFont *proxy = [[JSPROXY_CCMenuItemFont alloc] initWithJSObject:jsobj class:[CCMenuItemFont class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTargetedAction
 */
#pragma mark - CCTargetedAction

JSClass* JSPROXY_CCTargetedAction_class = NULL;
JSObject* JSPROXY_CCTargetedAction_object = NULL;
 // Constructor
JSBool JSPROXY_CCTargetedAction_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTargetedAction createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTargetedAction_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTargetedAction)", obj);
}

// Arguments: NSObject*, CCFiniteTimeAction*
// Ret value: CCTargetedAction* (o)
JSBool JSPROXY_CCTargetedAction_actionWithTarget_action__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTargetedAction* ret_val;

	ret_val = [CCTargetedAction actionWithTarget:(NSObject*)arg0 action:(CCFiniteTimeAction*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSObject*, CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSPROXY_CCTargetedAction_initWithTarget_action_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCTargetedAction *real = [(CCTargetedAction*)[proxy.klass alloc] initWithTarget:(NSObject*)arg0 action:(CCFiniteTimeAction*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCTargetedAction_setForcedTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCTargetedAction *real = (CCTargetedAction*) [proxy realObj];
	[real setForcedTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCTargetedAction* (o)
JSBool JSPROXY_CCTargetedAction_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTargetedAction* ret_val;

	ret_val = [CCTargetedAction actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTargetedAction* (o)
JSBool JSPROXY_CCTargetedAction_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTargetedAction* ret_val;

	ret_val = [CCTargetedAction action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTargetedAction_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTargetedAction_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTargetedAction_class->name = name;
	JSPROXY_CCTargetedAction_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTargetedAction_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTargetedAction_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTargetedAction_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTargetedAction_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTargetedAction_class->resolve = JS_ResolveStub;
	JSPROXY_CCTargetedAction_class->convert = JS_ConvertStub;
	JSPROXY_CCTargetedAction_class->finalize = JSPROXY_CCTargetedAction_finalize;
//	JSPROXY_CCTargetedAction_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTargetAction", JSPROXY_CCTargetedAction_initWithTarget_action_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setForcedTarget", JSPROXY_CCTargetedAction_setForcedTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTargetedAction_actionWithTarget_action__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCTargetedAction_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCTargetedAction_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTargetedAction_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCTargetedAction_class, JSPROXY_CCTargetedAction_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTargetedAction

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTargetedAction_class, JSPROXY_CCTargetedAction_object, NULL);
	JSPROXY_CCTargetedAction *proxy = [[JSPROXY_CCTargetedAction alloc] initWithJSObject:jsobj class:[CCTargetedAction class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSkewTo
 */
#pragma mark - CCSkewTo

JSClass* JSPROXY_CCSkewTo_class = NULL;
JSObject* JSPROXY_CCSkewTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCSkewTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSkewTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSkewTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSkewTo)", obj);
}

// Arguments: ccTime, float, float
// Ret value: CCSkewTo* (o)
JSBool JSPROXY_CCSkewTo_actionWithDuration_skewX_skewY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCSkewTo* ret_val;

	ret_val = [CCSkewTo actionWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSPROXY_CCSkewTo_initWithDuration_skewX_skewY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCSkewTo *real = [(CCSkewTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCSkewTo* (o)
JSBool JSPROXY_CCSkewTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSkewTo* ret_val;

	ret_val = [CCSkewTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSkewTo* (o)
JSBool JSPROXY_CCSkewTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSkewTo* ret_val;

	ret_val = [CCSkewTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSkewTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSkewTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSkewTo_class->name = name;
	JSPROXY_CCSkewTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSkewTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSkewTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSkewTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSkewTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSkewTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCSkewTo_class->convert = JS_ConvertStub;
	JSPROXY_CCSkewTo_class->finalize = JSPROXY_CCSkewTo_finalize;
//	JSPROXY_CCSkewTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSkewXSkewY", JSPROXY_CCSkewTo_initWithDuration_skewX_skewY_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCSkewTo_actionWithDuration_skewX_skewY__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCSkewTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCSkewTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSkewTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCSkewTo_class, JSPROXY_CCSkewTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSkewTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSkewTo_class, JSPROXY_CCSkewTo_object, NULL);
	JSPROXY_CCSkewTo *proxy = [[JSPROXY_CCSkewTo alloc] initWithJSObject:jsobj class:[CCSkewTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSkewBy
 */
#pragma mark - CCSkewBy

JSClass* JSPROXY_CCSkewBy_class = NULL;
JSObject* JSPROXY_CCSkewBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCSkewBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSkewBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSkewBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSkewBy)", obj);
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSPROXY_CCSkewBy_initWithDuration_skewX_skewY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCSkewBy *real = [(CCSkewBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCSkewBy* (o)
JSBool JSPROXY_CCSkewBy_actionWithDuration_skewX_skewY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCSkewBy* ret_val;

	ret_val = [CCSkewBy actionWithDuration:(ccTime)arg0 skewX:(float)arg1 skewY:(float)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCSkewBy* (o)
JSBool JSPROXY_CCSkewBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSkewBy* ret_val;

	ret_val = [CCSkewBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSkewBy* (o)
JSBool JSPROXY_CCSkewBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSkewBy* ret_val;

	ret_val = [CCSkewBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSkewBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSkewBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSkewBy_class->name = name;
	JSPROXY_CCSkewBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSkewBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSkewBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSkewBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSkewBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSkewBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCSkewBy_class->convert = JS_ConvertStub;
	JSPROXY_CCSkewBy_class->finalize = JSPROXY_CCSkewBy_finalize;
//	JSPROXY_CCSkewBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSkewXSkewY", JSPROXY_CCSkewBy_initWithDuration_skewX_skewY_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCSkewBy_actionWithDuration_skewX_skewY__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCSkewBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCSkewBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSkewBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCSkewTo_object, JSPROXY_CCSkewBy_class, JSPROXY_CCSkewBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSkewBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSkewBy_class, JSPROXY_CCSkewBy_object, NULL);
	JSPROXY_CCSkewBy *proxy = [[JSPROXY_CCSkewBy alloc] initWithJSObject:jsobj class:[CCSkewBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleFireworks
 */
#pragma mark - CCParticleFireworks

JSClass* JSPROXY_CCParticleFireworks_class = NULL;
JSObject* JSPROXY_CCParticleFireworks_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleFireworks_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleFireworks createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleFireworks_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleFireworks)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleFireworks_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleFireworks *real = [(CCParticleFireworks*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleFireworks* (o)
JSBool JSPROXY_CCParticleFireworks_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleFireworks* ret_val;

	ret_val = [CCParticleFireworks particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleFireworks* (o)
JSBool JSPROXY_CCParticleFireworks_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleFireworks* ret_val;

	ret_val = [CCParticleFireworks particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleFireworks* (o)
JSBool JSPROXY_CCParticleFireworks_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleFireworks* ret_val;

	ret_val = [CCParticleFireworks node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleFireworks_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleFireworks_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleFireworks_class->name = name;
	JSPROXY_CCParticleFireworks_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleFireworks_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleFireworks_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleFireworks_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleFireworks_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleFireworks_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleFireworks_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleFireworks_class->finalize = JSPROXY_CCParticleFireworks_finalize;
//	JSPROXY_CCParticleFireworks_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleFireworks_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleFireworks_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleFireworks_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleFireworks_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleFireworks_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleFireworks_class, JSPROXY_CCParticleFireworks_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleFireworks

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleFireworks_class, JSPROXY_CCParticleFireworks_object, NULL);
	JSPROXY_CCParticleFireworks *proxy = [[JSPROXY_CCParticleFireworks alloc] initWithJSObject:jsobj class:[CCParticleFireworks class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpawn
 */
#pragma mark - CCSpawn

JSClass* JSPROXY_CCSpawn_class = NULL;
JSObject* JSPROXY_CCSpawn_object = NULL;
 // Constructor
JSBool JSPROXY_CCSpawn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSpawn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSpawn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSpawn)", obj);
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: CCSpawn* (o)
JSBool JSPROXY_CCSpawn_actionOne_two__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCSpawn* ret_val;

	ret_val = [CCSpawn actionOne:(CCFiniteTimeAction*)arg0 two:(CCFiniteTimeAction*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCSpawn* (o)
JSBool JSPROXY_CCSpawn_actionWithArray__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 0, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsvals_variadic_to_nsarray( cx, argvp, argc, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSpawn* ret_val;

	ret_val = [CCSpawn actionWithArray:(NSArray*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSPROXY_CCSpawn_initOne_two_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCSpawn *real = [(CCSpawn*)[proxy.klass alloc] initOne:(CCFiniteTimeAction*)arg0 two:(CCFiniteTimeAction*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCSpawn* (o)
JSBool JSPROXY_CCSpawn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSpawn* ret_val;

	ret_val = [CCSpawn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpawn* (o)
JSBool JSPROXY_CCSpawn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSpawn* ret_val;

	ret_val = [CCSpawn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSpawn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSpawn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSpawn_class->name = name;
	JSPROXY_CCSpawn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSpawn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSpawn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSpawn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSpawn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSpawn_class->resolve = JS_ResolveStub;
	JSPROXY_CCSpawn_class->convert = JS_ConvertStub;
	JSPROXY_CCSpawn_class->finalize = JSPROXY_CCSpawn_finalize;
//	JSPROXY_CCSpawn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initOneTwo", JSPROXY_CCSpawn_initOne_two_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionOneTwo", JSPROXY_CCSpawn_actionOne_two__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCSpawn_actionWithArray__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCSpawn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCSpawn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSpawn_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCSpawn_class, JSPROXY_CCSpawn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSpawn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSpawn_class, JSPROXY_CCSpawn_object, NULL);
	JSPROXY_CCSpawn *proxy = [[JSPROXY_CCSpawn alloc] initWithJSObject:jsobj class:[CCSpawn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXTiledMap
 */
#pragma mark - CCTMXTiledMap

JSClass* JSPROXY_CCTMXTiledMap_class = NULL;
JSObject* JSPROXY_CCTMXTiledMap_object = NULL;
 // Constructor
JSBool JSPROXY_CCTMXTiledMap_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTMXTiledMap createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTMXTiledMap_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTMXTiledMap)", obj);
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCTMXTiledMap_initWithTMXFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTiledMap *real = [(CCTMXTiledMap*)[proxy.klass alloc] initWithTMXFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSPROXY_CCTMXTiledMap_initWithXML_resourcePath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTMXTiledMap *real = [(CCTMXTiledMap*)[proxy.klass alloc] initWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXLayer* (o)
JSBool JSPROXY_CCTMXTiledMap_layerNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTMXLayer* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real layerNamed:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSPROXY_CCTMXTiledMap_mapOrientation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	int ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real mapOrientation ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXTiledMap_mapSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real mapSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXObjectGroup* (o)
JSBool JSPROXY_CCTMXTiledMap_objectGroupNamed_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTMXObjectGroup* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real objectGroupNamed:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCTMXTiledMap_objectGroups(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real objectGroups ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCTMXTiledMap_setObjectGroups_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	[real setObjectGroups:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXTiledMap_tileSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXTiledMap *real = (CCTMXTiledMap*) [proxy realObj];
	ret_val = [real tileSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXTiledMap* (o)
JSBool JSPROXY_CCTMXTiledMap_tiledMapWithTMXFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTMXTiledMap* ret_val;

	ret_val = [CCTMXTiledMap tiledMapWithTMXFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCTMXTiledMap* (o)
JSBool JSPROXY_CCTMXTiledMap_tiledMapWithXML_resourcePath__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTMXTiledMap* ret_val;

	ret_val = [CCTMXTiledMap tiledMapWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTMXTiledMap* (o)
JSBool JSPROXY_CCTMXTiledMap_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTMXTiledMap* ret_val;

	ret_val = [CCTMXTiledMap node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTMXTiledMap_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTMXTiledMap_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTMXTiledMap_class->name = name;
	JSPROXY_CCTMXTiledMap_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTMXTiledMap_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTMXTiledMap_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTMXTiledMap_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTMXTiledMap_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTMXTiledMap_class->resolve = JS_ResolveStub;
	JSPROXY_CCTMXTiledMap_class->convert = JS_ConvertStub;
	JSPROXY_CCTMXTiledMap_class->finalize = JSPROXY_CCTMXTiledMap_finalize;
//	JSPROXY_CCTMXTiledMap_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTMXFile", JSPROXY_CCTMXTiledMap_initWithTMXFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithXMLResourcePath", JSPROXY_CCTMXTiledMap_initWithXML_resourcePath_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("layerNamed", JSPROXY_CCTMXTiledMap_layerNamed_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMapOrientation", JSPROXY_CCTMXTiledMap_mapOrientation, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMapSize", JSPROXY_CCTMXTiledMap_mapSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("objectGroupNamed", JSPROXY_CCTMXTiledMap_objectGroupNamed_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getObjectGroups", JSPROXY_CCTMXTiledMap_objectGroups, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setObjectGroups", JSPROXY_CCTMXTiledMap_setObjectGroups_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTileSize", JSPROXY_CCTMXTiledMap_tileSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTMXTiledMap_tiledMapWithTMXFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("tiledMapWithXMLResourcePath", JSPROXY_CCTMXTiledMap_tiledMapWithXML_resourcePath__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTMXTiledMap_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTMXTiledMap_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCTMXTiledMap_class, JSPROXY_CCTMXTiledMap_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTMXTiledMap

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTMXTiledMap_class, JSPROXY_CCTMXTiledMap_object, NULL);
	JSPROXY_CCTMXTiledMap *proxy = [[JSPROXY_CCTMXTiledMap alloc] initWithJSObject:jsobj class:[CCTMXTiledMap class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleExplosion
 */
#pragma mark - CCParticleExplosion

JSClass* JSPROXY_CCParticleExplosion_class = NULL;
JSObject* JSPROXY_CCParticleExplosion_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleExplosion_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleExplosion createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleExplosion_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleExplosion)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleExplosion_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleExplosion *real = [(CCParticleExplosion*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleExplosion* (o)
JSBool JSPROXY_CCParticleExplosion_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleExplosion* ret_val;

	ret_val = [CCParticleExplosion particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleExplosion* (o)
JSBool JSPROXY_CCParticleExplosion_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleExplosion* ret_val;

	ret_val = [CCParticleExplosion particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleExplosion* (o)
JSBool JSPROXY_CCParticleExplosion_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleExplosion* ret_val;

	ret_val = [CCParticleExplosion node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleExplosion_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleExplosion_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleExplosion_class->name = name;
	JSPROXY_CCParticleExplosion_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleExplosion_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleExplosion_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleExplosion_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleExplosion_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleExplosion_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleExplosion_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleExplosion_class->finalize = JSPROXY_CCParticleExplosion_finalize;
//	JSPROXY_CCParticleExplosion_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleExplosion_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleExplosion_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleExplosion_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleExplosion_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleExplosion_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleExplosion_class, JSPROXY_CCParticleExplosion_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleExplosion

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleExplosion_class, JSPROXY_CCParticleExplosion_object, NULL);
	JSPROXY_CCParticleExplosion *proxy = [[JSPROXY_CCParticleExplosion alloc] initWithJSObject:jsobj class:[CCParticleExplosion class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCToggleVisibility
 */
#pragma mark - CCToggleVisibility

JSClass* JSPROXY_CCToggleVisibility_class = NULL;
JSObject* JSPROXY_CCToggleVisibility_object = NULL;
 // Constructor
JSBool JSPROXY_CCToggleVisibility_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCToggleVisibility createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCToggleVisibility_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCToggleVisibility)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCToggleVisibility_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCToggleVisibility *real = (CCToggleVisibility*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCToggleVisibility* (o)
JSBool JSPROXY_CCToggleVisibility_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCToggleVisibility* ret_val;

	ret_val = [CCToggleVisibility action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCToggleVisibility_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCToggleVisibility_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCToggleVisibility_class->name = name;
	JSPROXY_CCToggleVisibility_class->addProperty = JS_PropertyStub;
	JSPROXY_CCToggleVisibility_class->delProperty = JS_PropertyStub;
	JSPROXY_CCToggleVisibility_class->getProperty = JS_PropertyStub;
	JSPROXY_CCToggleVisibility_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCToggleVisibility_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCToggleVisibility_class->resolve = JS_ResolveStub;
	JSPROXY_CCToggleVisibility_class->convert = JS_ConvertStub;
	JSPROXY_CCToggleVisibility_class->finalize = JSPROXY_CCToggleVisibility_finalize;
//	JSPROXY_CCToggleVisibility_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCToggleVisibility_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCToggleVisibility_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCToggleVisibility_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCToggleVisibility_class, JSPROXY_CCToggleVisibility_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCToggleVisibility

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCToggleVisibility_class, JSPROXY_CCToggleVisibility_object, NULL);
	JSPROXY_CCToggleVisibility *proxy = [[JSPROXY_CCToggleVisibility alloc] initWithJSObject:jsobj class:[CCToggleVisibility class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFade
 */
#pragma mark - CCTransitionFade

JSClass* JSPROXY_CCTransitionFade_class = NULL;
JSObject* JSPROXY_CCTransitionFade_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFade_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFade createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFade_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFade)", obj);
}

// Arguments: ccTime, CCScene*, ccColor3B
// Ret value: None (None)
JSBool JSPROXY_CCTransitionFade_initWithDuration_scene_withColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; ccColor3B arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);

	JSObject *tmp_arg2;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg2);
	if( ! ok ) return JS_FALSE;

	CCTransitionFade *real = [(CCTransitionFade*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 withColor:(ccColor3B)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, ccColor3B
// Ret value: CCTransitionFade* (o)
JSBool JSPROXY_CCTransitionFade_transitionWithDuration_scene_withColor__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 2 && argc <= 3 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; ccColor3B arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if (argc >= 3) {
	
	JSObject *tmp_arg2;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg2);
	}
	if( ! ok ) return JS_FALSE;
	CCTransitionFade* ret_val;

	if( argc == 2 ) {
		ret_val = [CCTransitionFade transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCTransitionFade transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 withColor:(ccColor3B)arg2  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFade* (o)
JSBool JSPROXY_CCTransitionFade_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFade* ret_val;

	ret_val = [CCTransitionFade node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFade_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFade_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFade_class->name = name;
	JSPROXY_CCTransitionFade_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFade_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFade_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFade_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFade_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFade_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFade_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFade_class->finalize = JSPROXY_CCTransitionFade_finalize;
//	JSPROXY_CCTransitionFade_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationSceneWithColor", JSPROXY_CCTransitionFade_initWithDuration_scene_withColor_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionFade_transitionWithDuration_scene_withColor__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFade_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFade_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionFade_class, JSPROXY_CCTransitionFade_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFade

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFade_class, JSPROXY_CCTransitionFade_object, NULL);
	JSPROXY_CCTransitionFade *proxy = [[JSPROXY_CCTransitionFade alloc] initWithJSObject:jsobj class:[CCTransitionFade class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLabelAtlas
 */
#pragma mark - CCLabelAtlas

JSClass* JSPROXY_CCLabelAtlas_class = NULL;
JSObject* JSPROXY_CCLabelAtlas_object = NULL;
 // Constructor
JSBool JSPROXY_CCLabelAtlas_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCLabelAtlas createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCLabelAtlas_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCLabelAtlas)", obj);
}

// Arguments: NSString*, NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCLabelAtlas_initWithString_charMapFile_itemWidth_itemHeight_startCharMap_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; uint32_t arg2; uint32_t arg3; uint32_t arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;

	CCLabelAtlas *real = [(CCLabelAtlas*)[proxy.klass alloc] initWithString:(NSString*)arg0 charMapFile:(NSString*)arg1 itemWidth:(NSUInteger)arg2 itemHeight:(NSUInteger)arg3 startCharMap:(NSUInteger)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSPROXY_CCLabelAtlas_initWithString_fntFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCLabelAtlas *real = [(CCLabelAtlas*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: CCLabelAtlas* (o)
JSBool JSPROXY_CCLabelAtlas_labelWithString_charMapFile_itemWidth_itemHeight_startCharMap__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; uint32_t arg2; uint32_t arg3; uint32_t arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;
	CCLabelAtlas* ret_val;

	ret_val = [CCLabelAtlas labelWithString:(NSString*)arg0 charMapFile:(NSString*)arg1 itemWidth:(NSUInteger)arg2 itemHeight:(NSUInteger)arg3 startCharMap:(NSUInteger)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCLabelAtlas* (o)
JSBool JSPROXY_CCLabelAtlas_labelWithString_fntFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLabelAtlas* ret_val;

	ret_val = [CCLabelAtlas labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCLabelAtlas_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelAtlas *real = (CCLabelAtlas*) [proxy realObj];
	[real setString:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCLabelAtlas_string(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelAtlas *real = (CCLabelAtlas*) [proxy realObj];
	ret_val = [real string ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger, NSUInteger, NSUInteger
// Ret value: CCLabelAtlas* (o)
JSBool JSPROXY_CCLabelAtlas_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCLabelAtlas* ret_val;

	ret_val = [CCLabelAtlas atlasWithTileFile:(NSString*)arg0 tileWidth:(NSUInteger)arg1 tileHeight:(NSUInteger)arg2 itemsToRender:(NSUInteger)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLabelAtlas* (o)
JSBool JSPROXY_CCLabelAtlas_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCLabelAtlas* ret_val;

	ret_val = [CCLabelAtlas node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCLabelAtlas_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCLabelAtlas_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCLabelAtlas_class->name = name;
	JSPROXY_CCLabelAtlas_class->addProperty = JS_PropertyStub;
	JSPROXY_CCLabelAtlas_class->delProperty = JS_PropertyStub;
	JSPROXY_CCLabelAtlas_class->getProperty = JS_PropertyStub;
	JSPROXY_CCLabelAtlas_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCLabelAtlas_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCLabelAtlas_class->resolve = JS_ResolveStub;
	JSPROXY_CCLabelAtlas_class->convert = JS_ConvertStub;
	JSPROXY_CCLabelAtlas_class->finalize = JSPROXY_CCLabelAtlas_finalize;
//	JSPROXY_CCLabelAtlas_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithStringCharMapFileItemWidthItemHeightStartCharMap", JSPROXY_CCLabelAtlas_initWithString_charMapFile_itemWidth_itemHeight_startCharMap_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFile", JSPROXY_CCLabelAtlas_initWithString_fntFile_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setString", JSPROXY_CCLabelAtlas_setString_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("string", JSPROXY_CCLabelAtlas_string, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("labelWithStringCharMapFileItemWidthItemHeightStartCharMap", JSPROXY_CCLabelAtlas_labelWithString_charMapFile_itemWidth_itemHeight_startCharMap__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCLabelAtlas_labelWithString_fntFile__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("atlasWithTileFileTileWidthTileHeightItemsToRender", JSPROXY_CCLabelAtlas_atlasWithTileFile_tileWidth_tileHeight_itemsToRender__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCLabelAtlas_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCLabelAtlas_object = JS_InitClass(cx, globalObj, JSPROXY_CCAtlasNode_object, JSPROXY_CCLabelAtlas_class, JSPROXY_CCLabelAtlas_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCLabelAtlas

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCLabelAtlas_class, JSPROXY_CCLabelAtlas_object, NULL);
	JSPROXY_CCLabelAtlas *proxy = [[JSPROXY_CCLabelAtlas alloc] initWithJSObject:jsobj class:[CCLabelAtlas class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInL
 */
#pragma mark - CCTransitionMoveInL

JSClass* JSPROXY_CCTransitionMoveInL_class = NULL;
JSObject* JSPROXY_CCTransitionMoveInL_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionMoveInL_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionMoveInL createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionMoveInL_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionMoveInL)", obj);
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionMoveInL_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionMoveInL *real = (CCTransitionMoveInL*) [proxy realObj];
	ret_val = [real action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionMoveInL_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionMoveInL *real = (CCTransitionMoveInL*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionMoveInL_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionMoveInL *real = (CCTransitionMoveInL*) [proxy realObj];
	ret_val = [real easeActionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInL* (o)
JSBool JSPROXY_CCTransitionMoveInL_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionMoveInL* ret_val;

	ret_val = [CCTransitionMoveInL transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInL* (o)
JSBool JSPROXY_CCTransitionMoveInL_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionMoveInL* ret_val;

	ret_val = [CCTransitionMoveInL node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionMoveInL_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionMoveInL_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionMoveInL_class->name = name;
	JSPROXY_CCTransitionMoveInL_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInL_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInL_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInL_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionMoveInL_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionMoveInL_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionMoveInL_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionMoveInL_class->finalize = JSPROXY_CCTransitionMoveInL_finalize;
//	JSPROXY_CCTransitionMoveInL_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSPROXY_CCTransitionMoveInL_action, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initScenes", JSPROXY_CCTransitionMoveInL_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSPROXY_CCTransitionMoveInL_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionMoveInL_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionMoveInL_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionMoveInL_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionMoveInL_class, JSPROXY_CCTransitionMoveInL_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionMoveInL

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionMoveInL_class, JSPROXY_CCTransitionMoveInL_object, NULL);
	JSPROXY_CCTransitionMoveInL *proxy = [[JSPROXY_CCTransitionMoveInL alloc] initWithJSObject:jsobj class:[CCTransitionMoveInL class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInT
 */
#pragma mark - CCTransitionMoveInT

JSClass* JSPROXY_CCTransitionMoveInT_class = NULL;
JSObject* JSPROXY_CCTransitionMoveInT_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionMoveInT_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionMoveInT createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionMoveInT_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionMoveInT)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionMoveInT_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionMoveInT *real = (CCTransitionMoveInT*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInT* (o)
JSBool JSPROXY_CCTransitionMoveInT_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionMoveInT* ret_val;

	ret_val = [CCTransitionMoveInT transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInT* (o)
JSBool JSPROXY_CCTransitionMoveInT_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionMoveInT* ret_val;

	ret_val = [CCTransitionMoveInT node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionMoveInT_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionMoveInT_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionMoveInT_class->name = name;
	JSPROXY_CCTransitionMoveInT_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInT_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInT_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInT_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionMoveInT_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionMoveInT_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionMoveInT_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionMoveInT_class->finalize = JSPROXY_CCTransitionMoveInT_finalize;
//	JSPROXY_CCTransitionMoveInT_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSPROXY_CCTransitionMoveInT_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionMoveInT_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionMoveInT_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionMoveInT_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionMoveInL_object, JSPROXY_CCTransitionMoveInT_class, JSPROXY_CCTransitionMoveInT_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionMoveInT

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionMoveInT_class, JSPROXY_CCTransitionMoveInT_object, NULL);
	JSPROXY_CCTransitionMoveInT *proxy = [[JSPROXY_CCTransitionMoveInT alloc] initWithJSObject:jsobj class:[CCTransitionMoveInT class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInR
 */
#pragma mark - CCTransitionMoveInR

JSClass* JSPROXY_CCTransitionMoveInR_class = NULL;
JSObject* JSPROXY_CCTransitionMoveInR_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionMoveInR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionMoveInR createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionMoveInR_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionMoveInR)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionMoveInR_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionMoveInR *real = (CCTransitionMoveInR*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInR* (o)
JSBool JSPROXY_CCTransitionMoveInR_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionMoveInR* ret_val;

	ret_val = [CCTransitionMoveInR transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInR* (o)
JSBool JSPROXY_CCTransitionMoveInR_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionMoveInR* ret_val;

	ret_val = [CCTransitionMoveInR node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionMoveInR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionMoveInR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionMoveInR_class->name = name;
	JSPROXY_CCTransitionMoveInR_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInR_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInR_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInR_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionMoveInR_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionMoveInR_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionMoveInR_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionMoveInR_class->finalize = JSPROXY_CCTransitionMoveInR_finalize;
//	JSPROXY_CCTransitionMoveInR_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSPROXY_CCTransitionMoveInR_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionMoveInR_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionMoveInR_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionMoveInR_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionMoveInL_object, JSPROXY_CCTransitionMoveInR_class, JSPROXY_CCTransitionMoveInR_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionMoveInR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionMoveInR_class, JSPROXY_CCTransitionMoveInR_object, NULL);
	JSPROXY_CCTransitionMoveInR *proxy = [[JSPROXY_CCTransitionMoveInR alloc] initWithJSObject:jsobj class:[CCTransitionMoveInR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseExponentialIn
 */
#pragma mark - CCEaseExponentialIn

JSClass* JSPROXY_CCEaseExponentialIn_class = NULL;
JSObject* JSPROXY_CCEaseExponentialIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseExponentialIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseExponentialIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseExponentialIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseExponentialIn)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseExponentialIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseExponentialIn *real = (CCEaseExponentialIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseExponentialIn* (o)
JSBool JSPROXY_CCEaseExponentialIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseExponentialIn* ret_val;

	ret_val = [CCEaseExponentialIn actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseExponentialIn* (o)
JSBool JSPROXY_CCEaseExponentialIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseExponentialIn* ret_val;

	ret_val = [CCEaseExponentialIn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseExponentialIn* (o)
JSBool JSPROXY_CCEaseExponentialIn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseExponentialIn* ret_val;

	ret_val = [CCEaseExponentialIn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseExponentialIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseExponentialIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseExponentialIn_class->name = name;
	JSPROXY_CCEaseExponentialIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseExponentialIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseExponentialIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseExponentialIn_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseExponentialIn_class->finalize = JSPROXY_CCEaseExponentialIn_finalize;
//	JSPROXY_CCEaseExponentialIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseExponentialIn_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseExponentialIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseExponentialIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseExponentialIn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseExponentialIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseExponentialIn_class, JSPROXY_CCEaseExponentialIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseExponentialIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseExponentialIn_class, JSPROXY_CCEaseExponentialIn_object, NULL);
	JSPROXY_CCEaseExponentialIn *proxy = [[JSPROXY_CCEaseExponentialIn alloc] initWithJSObject:jsobj class:[CCEaseExponentialIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCPlace
 */
#pragma mark - CCPlace

JSClass* JSPROXY_CCPlace_class = NULL;
JSObject* JSPROXY_CCPlace_object = NULL;
 // Constructor
JSBool JSPROXY_CCPlace_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCPlace createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCPlace_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCPlace)", obj);
}

// Arguments: CGPoint
// Ret value: CCPlace* (o)
JSBool JSPROXY_CCPlace_actionWithPosition__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCPlace* ret_val;

	ret_val = [CCPlace actionWithPosition:(CGPoint)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: None (None)
JSBool JSPROXY_CCPlace_initWithPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCPlace *real = [(CCPlace*)[proxy.klass alloc] initWithPosition:(CGPoint)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCPlace* (o)
JSBool JSPROXY_CCPlace_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCPlace* ret_val;

	ret_val = [CCPlace action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCPlace_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCPlace_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCPlace_class->name = name;
	JSPROXY_CCPlace_class->addProperty = JS_PropertyStub;
	JSPROXY_CCPlace_class->delProperty = JS_PropertyStub;
	JSPROXY_CCPlace_class->getProperty = JS_PropertyStub;
	JSPROXY_CCPlace_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCPlace_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCPlace_class->resolve = JS_ResolveStub;
	JSPROXY_CCPlace_class->convert = JS_ConvertStub;
	JSPROXY_CCPlace_class->finalize = JSPROXY_CCPlace_finalize;
//	JSPROXY_CCPlace_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithPosition", JSPROXY_CCPlace_initWithPosition_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCPlace_actionWithPosition__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCPlace_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCPlace_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCPlace_class, JSPROXY_CCPlace_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCPlace

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCPlace_class, JSPROXY_CCPlace_object, NULL);
	JSPROXY_CCPlace *proxy = [[JSPROXY_CCPlace alloc] initWithJSObject:jsobj class:[CCPlace class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleFire
 */
#pragma mark - CCParticleFire

JSClass* JSPROXY_CCParticleFire_class = NULL;
JSObject* JSPROXY_CCParticleFire_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleFire_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleFire createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleFire_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleFire)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleFire_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleFire *real = [(CCParticleFire*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleFire* (o)
JSBool JSPROXY_CCParticleFire_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleFire* ret_val;

	ret_val = [CCParticleFire particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleFire* (o)
JSBool JSPROXY_CCParticleFire_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleFire* ret_val;

	ret_val = [CCParticleFire particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleFire* (o)
JSBool JSPROXY_CCParticleFire_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleFire* ret_val;

	ret_val = [CCParticleFire node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleFire_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleFire_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleFire_class->name = name;
	JSPROXY_CCParticleFire_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleFire_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleFire_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleFire_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleFire_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleFire_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleFire_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleFire_class->finalize = JSPROXY_CCParticleFire_finalize;
//	JSPROXY_CCParticleFire_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleFire_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleFire_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleFire_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleFire_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleFire_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleFire_class, JSPROXY_CCParticleFire_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleFire

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleFire_class, JSPROXY_CCParticleFire_object, NULL);
	JSPROXY_CCParticleFire *proxy = [[JSPROXY_CCParticleFire alloc] initWithJSObject:jsobj class:[CCParticleFire class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCatmullRomTo
 */
#pragma mark - CCCatmullRomTo

JSClass* JSPROXY_CCCatmullRomTo_class = NULL;
JSObject* JSPROXY_CCCatmullRomTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCCatmullRomTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCCatmullRomTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCCatmullRomTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCCatmullRomTo)", obj);
}

// Arguments: ccTime, CCPointArray*
// Ret value: CCCatmullRomTo* (o)
JSBool JSPROXY_CCCatmullRomTo_actionWithDuration_points__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCCatmullRomTo* ret_val;

	ret_val = [CCCatmullRomTo actionWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*
// Ret value: None (None)
JSBool JSPROXY_CCCatmullRomTo_initWithDuration_points_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCCatmullRomTo *real = [(CCCatmullRomTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCPointArray*, CGFloat
// Ret value: CCCatmullRomTo* (o)
JSBool JSPROXY_CCCatmullRomTo_actionWithDuration_points_tension__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCCatmullRomTo* ret_val;

	ret_val = [CCCatmullRomTo actionWithDuration:(ccTime)arg0 points:(CCPointArray*)arg1 tension:(CGFloat)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCCatmullRomTo* (o)
JSBool JSPROXY_CCCatmullRomTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCCatmullRomTo* ret_val;

	ret_val = [CCCatmullRomTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCatmullRomTo* (o)
JSBool JSPROXY_CCCatmullRomTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCCatmullRomTo* ret_val;

	ret_val = [CCCatmullRomTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCCatmullRomTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCCatmullRomTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCCatmullRomTo_class->name = name;
	JSPROXY_CCCatmullRomTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCCatmullRomTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCCatmullRomTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCCatmullRomTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCCatmullRomTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCCatmullRomTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCCatmullRomTo_class->convert = JS_ConvertStub;
	JSPROXY_CCCatmullRomTo_class->finalize = JSPROXY_CCCatmullRomTo_finalize;
//	JSPROXY_CCCatmullRomTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationPoints", JSPROXY_CCCatmullRomTo_initWithDuration_points_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCCatmullRomTo_actionWithDuration_points__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDurationPointsTension", JSPROXY_CCCatmullRomTo_actionWithDuration_points_tension__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCCatmullRomTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCCatmullRomTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCCatmullRomTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCCardinalSplineTo_object, JSPROXY_CCCatmullRomTo_class, JSPROXY_CCCatmullRomTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCCatmullRomTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCCatmullRomTo_class, JSPROXY_CCCatmullRomTo_object, NULL);
	JSPROXY_CCCatmullRomTo *proxy = [[JSPROXY_CCCatmullRomTo alloc] initWithJSObject:jsobj class:[CCCatmullRomTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLabelBMFont
 */
#pragma mark - CCLabelBMFont

JSClass* JSPROXY_CCLabelBMFont_class = NULL;
JSObject* JSPROXY_CCLabelBMFont_object = NULL;
 // Constructor
JSBool JSPROXY_CCLabelBMFont_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCLabelBMFont createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCLabelBMFont_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCLabelBMFont)", obj);
}

// Arguments: 
// Ret value: CCTextAlignment (i)
JSBool JSPROXY_CCLabelBMFont_alignment(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTextAlignment ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real alignment ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCLabelBMFont_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_createFontChars(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real createFontChars ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCLabelBMFont_fntFile(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real fntFile ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSPROXY_CCLabelBMFont_initWithString_fntFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = [(CCLabelBMFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, float, CCTextAlignment
// Ret value: None (None)
JSBool JSPROXY_CCLabelBMFont_initWithString_fntFile_width_alignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; int32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = [(CCLabelBMFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*, float, CCTextAlignment, CGPoint
// Ret value: None (None)
JSBool JSPROXY_CCLabelBMFont_initWithString_fntFile_width_alignment_imageOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; int32_t arg3; CGPoint arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg4 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = [(CCLabelBMFont*)[proxy.klass alloc] initWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3 imageOffset:(CGPoint)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_labelWithString_fntFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, float, CCTextAlignment
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_labelWithString_fntFile_width_alignment__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; int32_t arg3; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*, float, CCTextAlignment, CGPoint
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_labelWithString_fntFile_width_alignment_imageOffset__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; double arg2; int32_t arg3; CGPoint arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg3 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg4 );
	if( ! ok ) return JS_FALSE;
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont labelWithString:(NSString*)arg0 fntFile:(NSString*)arg1 width:(float)arg2 alignment:(CCTextAlignment)arg3 imageOffset:(CGPoint)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCLabelBMFont_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_purgeCachedData_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	[CCLabelBMFont purgeCachedData ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTextAlignment
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_setAlignment_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setAlignment:(CCTextAlignment)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_setFntFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setFntFile:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_setWidth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setWidth:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_setString_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setString:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCLabelBMFont_string(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real string ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCLabelBMFont_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCLabelBMFont_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLabelBMFont *real = (CCLabelBMFont*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_batchNodeWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont batchNodeWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_batchNodeWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont batchNodeWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_batchNodeWithTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont batchNodeWithTexture:(CCTexture2D*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_batchNodeWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont batchNodeWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLabelBMFont* (o)
JSBool JSPROXY_CCLabelBMFont_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCLabelBMFont* ret_val;

	ret_val = [CCLabelBMFont node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCLabelBMFont_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCLabelBMFont_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCLabelBMFont_class->name = name;
	JSPROXY_CCLabelBMFont_class->addProperty = JS_PropertyStub;
	JSPROXY_CCLabelBMFont_class->delProperty = JS_PropertyStub;
	JSPROXY_CCLabelBMFont_class->getProperty = JS_PropertyStub;
	JSPROXY_CCLabelBMFont_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCLabelBMFont_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCLabelBMFont_class->resolve = JS_ResolveStub;
	JSPROXY_CCLabelBMFont_class->convert = JS_ConvertStub;
	JSPROXY_CCLabelBMFont_class->finalize = JSPROXY_CCLabelBMFont_finalize;
//	JSPROXY_CCLabelBMFont_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAlignment", JSPROXY_CCLabelBMFont_alignment, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getColor", JSPROXY_CCLabelBMFont_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("createFontChars", JSPROXY_CCLabelBMFont_createFontChars, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getFntFile", JSPROXY_CCLabelBMFont_fntFile, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFile", JSPROXY_CCLabelBMFont_initWithString_fntFile_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFileWidthAlignment", JSPROXY_CCLabelBMFont_initWithString_fntFile_width_alignment_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithStringFntFileWidthAlignmentImageOffset", JSPROXY_CCLabelBMFont_initWithString_fntFile_width_alignment_imageOffset_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSPROXY_CCLabelBMFont_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAlignment", JSPROXY_CCLabelBMFont_setAlignment_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCLabelBMFont_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFntFile", JSPROXY_CCLabelBMFont_setFntFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCLabelBMFont_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setWidth", JSPROXY_CCLabelBMFont_setWidth_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setString", JSPROXY_CCLabelBMFont_setString_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("string", JSPROXY_CCLabelBMFont_string, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCLabelBMFont_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCLabelBMFont_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCLabelBMFont_labelWithString_fntFile__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("labelWithStringFntFileWidthAlignment", JSPROXY_CCLabelBMFont_labelWithString_fntFile_width_alignment__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("labelWithStringFntFileWidthAlignmentImageOffset", JSPROXY_CCLabelBMFont_labelWithString_fntFile_width_alignment_imageOffset__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("purgeCachedData", JSPROXY_CCLabelBMFont_purgeCachedData_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithFile", JSPROXY_CCLabelBMFont_batchNodeWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithFileCapacity", JSPROXY_CCLabelBMFont_batchNodeWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithTexture", JSPROXY_CCLabelBMFont_batchNodeWithTexture__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("batchNodeWithTextureCapacity", JSPROXY_CCLabelBMFont_batchNodeWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCLabelBMFont_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCLabelBMFont_object = JS_InitClass(cx, globalObj, JSPROXY_CCSpriteBatchNode_object, JSPROXY_CCLabelBMFont_class, JSPROXY_CCLabelBMFont_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCLabelBMFont

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCLabelBMFont_class, JSPROXY_CCLabelBMFont_object, NULL);
	JSPROXY_CCLabelBMFont *proxy = [[JSPROXY_CCLabelBMFont alloc] initWithJSObject:jsobj class:[CCLabelBMFont class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionMoveInB
 */
#pragma mark - CCTransitionMoveInB

JSClass* JSPROXY_CCTransitionMoveInB_class = NULL;
JSObject* JSPROXY_CCTransitionMoveInB_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionMoveInB_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionMoveInB createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionMoveInB_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionMoveInB)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionMoveInB_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionMoveInB *real = (CCTransitionMoveInB*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionMoveInB* (o)
JSBool JSPROXY_CCTransitionMoveInB_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionMoveInB* ret_val;

	ret_val = [CCTransitionMoveInB transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionMoveInB* (o)
JSBool JSPROXY_CCTransitionMoveInB_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionMoveInB* ret_val;

	ret_val = [CCTransitionMoveInB node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionMoveInB_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionMoveInB_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionMoveInB_class->name = name;
	JSPROXY_CCTransitionMoveInB_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInB_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInB_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionMoveInB_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionMoveInB_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionMoveInB_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionMoveInB_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionMoveInB_class->finalize = JSPROXY_CCTransitionMoveInB_finalize;
//	JSPROXY_CCTransitionMoveInB_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSPROXY_CCTransitionMoveInB_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionMoveInB_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionMoveInB_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionMoveInB_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionMoveInL_object, JSPROXY_CCTransitionMoveInB_class, JSPROXY_CCTransitionMoveInB_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionMoveInB

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionMoveInB_class, JSPROXY_CCTransitionMoveInB_object, NULL);
	JSPROXY_CCTransitionMoveInB *proxy = [[JSPROXY_CCTransitionMoveInB alloc] initWithJSObject:jsobj class:[CCTransitionMoveInB class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionZoomFlipX
 */
#pragma mark - CCTransitionZoomFlipX

JSClass* JSPROXY_CCTransitionZoomFlipX_class = NULL;
JSObject* JSPROXY_CCTransitionZoomFlipX_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionZoomFlipX_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionZoomFlipX createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionZoomFlipX_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionZoomFlipX)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionZoomFlipX_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionZoomFlipX *real = [(CCTransitionZoomFlipX*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionZoomFlipX* (o)
JSBool JSPROXY_CCTransitionZoomFlipX_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTransitionZoomFlipX* ret_val;

	ret_val = [CCTransitionZoomFlipX transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionZoomFlipX* (o)
JSBool JSPROXY_CCTransitionZoomFlipX_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionZoomFlipX* ret_val;

	ret_val = [CCTransitionZoomFlipX transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionZoomFlipX* (o)
JSBool JSPROXY_CCTransitionZoomFlipX_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionZoomFlipX* ret_val;

	ret_val = [CCTransitionZoomFlipX node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionZoomFlipX_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionZoomFlipX_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionZoomFlipX_class->name = name;
	JSPROXY_CCTransitionZoomFlipX_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipX_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipX_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipX_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionZoomFlipX_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionZoomFlipX_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionZoomFlipX_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionZoomFlipX_class->finalize = JSPROXY_CCTransitionZoomFlipX_finalize;
//	JSPROXY_CCTransitionZoomFlipX_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionZoomFlipX_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSPROXY_CCTransitionZoomFlipX_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTransitionZoomFlipX_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionZoomFlipX_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionZoomFlipX_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSceneOriented_object, JSPROXY_CCTransitionZoomFlipX_class, JSPROXY_CCTransitionZoomFlipX_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionZoomFlipX

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionZoomFlipX_class, JSPROXY_CCTransitionZoomFlipX_object, NULL);
	JSPROXY_CCTransitionZoomFlipX *proxy = [[JSPROXY_CCTransitionZoomFlipX alloc] initWithJSObject:jsobj class:[CCTransitionZoomFlipX class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseOut
 */
#pragma mark - CCEaseOut

JSClass* JSPROXY_CCEaseOut_class = NULL;
JSObject* JSPROXY_CCEaseOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseOut *real = (CCEaseOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseOut* (o)
JSBool JSPROXY_CCEaseOut_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCEaseOut* ret_val;

	ret_val = [CCEaseOut actionWithAction:(CCActionInterval*)arg0 rate:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseOut* (o)
JSBool JSPROXY_CCEaseOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseOut* ret_val;

	ret_val = [CCEaseOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseOut* (o)
JSBool JSPROXY_CCEaseOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseOut* ret_val;

	ret_val = [CCEaseOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseOut* (o)
JSBool JSPROXY_CCEaseOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseOut* ret_val;

	ret_val = [CCEaseOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseOut_class->name = name;
	JSPROXY_CCEaseOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseOut_class->finalize = JSPROXY_CCEaseOut_finalize;
//	JSPROXY_CCEaseOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseOut_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithAction", JSPROXY_CCEaseOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseRateAction_object, JSPROXY_CCEaseOut_class, JSPROXY_CCEaseOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseOut_class, JSPROXY_CCEaseOut_object, NULL);
	JSPROXY_CCEaseOut *proxy = [[JSPROXY_CCEaseOut alloc] initWithJSObject:jsobj class:[CCEaseOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProfiler
 */
#pragma mark - CCProfiler

JSClass* JSPROXY_CCProfiler_class = NULL;
JSObject* JSPROXY_CCProfiler_object = NULL;
 // Constructor
JSBool JSPROXY_CCProfiler_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCProfiler createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCProfiler_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCProfiler)", obj);
}

// Arguments: NSString*
// Ret value: CCProfilingTimer* (o)
JSBool JSPROXY_CCProfiler_createAndAddTimerWithName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCProfilingTimer* ret_val;

	CCProfiler *real = (CCProfiler*) [proxy realObj];
	ret_val = [real createAndAddTimerWithName:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCProfiler_displayTimers(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCProfiler *real = (CCProfiler*) [proxy realObj];
	[real displayTimers ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCProfiler_releaseAllTimers(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCProfiler *real = (CCProfiler*) [proxy realObj];
	[real releaseAllTimers ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCProfiler_releaseTimer_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProfiler *real = (CCProfiler*) [proxy realObj];
	[real releaseTimer:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCProfiler* (o)
JSBool JSPROXY_CCProfiler_sharedProfiler_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCProfiler* ret_val;

	ret_val = [CCProfiler sharedProfiler ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCProfiler_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCProfiler_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCProfiler_class->name = name;
	JSPROXY_CCProfiler_class->addProperty = JS_PropertyStub;
	JSPROXY_CCProfiler_class->delProperty = JS_PropertyStub;
	JSPROXY_CCProfiler_class->getProperty = JS_PropertyStub;
	JSPROXY_CCProfiler_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCProfiler_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCProfiler_class->resolve = JS_ResolveStub;
	JSPROXY_CCProfiler_class->convert = JS_ConvertStub;
	JSPROXY_CCProfiler_class->finalize = JSPROXY_CCProfiler_finalize;
//	JSPROXY_CCProfiler_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("createAndAddTimerWithName", JSPROXY_CCProfiler_createAndAddTimerWithName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("displayTimers", JSPROXY_CCProfiler_displayTimers, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("releaseAllTimers", JSPROXY_CCProfiler_releaseAllTimers, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("releaseTimer", JSPROXY_CCProfiler_releaseTimer_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("sharedProfiler", JSPROXY_CCProfiler_sharedProfiler_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCProfiler_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCProfiler_class, JSPROXY_CCProfiler_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCProfiler

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCProfiler_class, JSPROXY_CCProfiler_object, NULL);
	JSPROXY_CCProfiler *proxy = [[JSPROXY_CCProfiler alloc] initWithJSObject:jsobj class:[CCProfiler class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCMenuItemToggle
 */
#pragma mark - CCMenuItemToggle

JSClass* JSPROXY_CCMenuItemToggle_class = NULL;
JSObject* JSPROXY_CCMenuItemToggle_object = NULL;
 // Constructor
JSBool JSPROXY_CCMenuItemToggle_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCMenuItemToggle createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCMenuItemToggle_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCMenuItemToggle)", obj);
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCMenuItemToggle_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: NSArray*, void (^)(id)
// Ret value: None (None)
JSBool JSPROXY_CCMenuItemToggle_initWithItems_block_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; js_block arg1; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemToggle *real = [(CCMenuItemToggle*)[proxy.klass alloc] initWithItems:(NSArray*)arg0 block:(void (^)(id))arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCMenuItemToggle* (o)
JSBool JSPROXY_CCMenuItemToggle_itemWithItems__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 0, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsvals_variadic_to_nsarray( cx, argvp, argc, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemToggle* ret_val;

	ret_val = [CCMenuItemToggle itemWithItems:(NSArray*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSArray*, void (^)(id)
// Ret value: CCMenuItemToggle* (o)
JSBool JSPROXY_CCMenuItemToggle_itemWithItems_block__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; js_block arg1; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg1 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemToggle* ret_val;

	ret_val = [CCMenuItemToggle itemWithItems:(NSArray*)arg0 block:(void (^)(id))arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCMenuItemToggle_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCMenuItemToggle_selectedIndex(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real selectedIndex ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItem* (o)
JSBool JSPROXY_CCMenuItemToggle_selectedItem(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItem* ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real selectedItem ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemToggle_setSelectedIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setSelectedIndex:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemToggle_setSubItems_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setSubItems:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCMenuItemToggle_subItems(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real subItems ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCMenuItemToggle_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemToggle_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemToggle_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCMenuItemToggle_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCMenuItemToggle *real = (CCMenuItemToggle*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: void (^)(id)
// Ret value: CCMenuItemToggle* (o)
JSBool JSPROXY_CCMenuItemToggle_itemWithBlock__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;
	CCMenuItemToggle* ret_val;

	ret_val = [CCMenuItemToggle itemWithBlock:(void (^)(id))arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCMenuItemToggle* (o)
JSBool JSPROXY_CCMenuItemToggle_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCMenuItemToggle* ret_val;

	ret_val = [CCMenuItemToggle node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCMenuItemToggle_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCMenuItemToggle_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCMenuItemToggle_class->name = name;
	JSPROXY_CCMenuItemToggle_class->addProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemToggle_class->delProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemToggle_class->getProperty = JS_PropertyStub;
	JSPROXY_CCMenuItemToggle_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCMenuItemToggle_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCMenuItemToggle_class->resolve = JS_ResolveStub;
	JSPROXY_CCMenuItemToggle_class->convert = JS_ConvertStub;
	JSPROXY_CCMenuItemToggle_class->finalize = JSPROXY_CCMenuItemToggle_finalize;
//	JSPROXY_CCMenuItemToggle_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getColor", JSPROXY_CCMenuItemToggle_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithItemsBlock", JSPROXY_CCMenuItemToggle_initWithItems_block_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSPROXY_CCMenuItemToggle_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSelectedIndex", JSPROXY_CCMenuItemToggle_selectedIndex, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("selectedItem", JSPROXY_CCMenuItemToggle_selectedItem, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSelectedIndex", JSPROXY_CCMenuItemToggle_setSelectedIndex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSubItems", JSPROXY_CCMenuItemToggle_setSubItems_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSubItems", JSPROXY_CCMenuItemToggle_subItems, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCMenuItemToggle_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCMenuItemToggle_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCMenuItemToggle_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCMenuItemToggle_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCMenuItemToggle_itemWithItems__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithItemsBlock", JSPROXY_CCMenuItemToggle_itemWithItems_block__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("itemWithBlock", JSPROXY_CCMenuItemToggle_itemWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCMenuItemToggle_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCMenuItemToggle_object = JS_InitClass(cx, globalObj, JSPROXY_CCMenuItem_object, JSPROXY_CCMenuItemToggle_class, JSPROXY_CCMenuItemToggle_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCMenuItemToggle

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCMenuItemToggle_class, JSPROXY_CCMenuItemToggle_object, NULL);
	JSPROXY_CCMenuItemToggle *proxy = [[JSPROXY_CCMenuItemToggle alloc] initWithJSObject:jsobj class:[CCMenuItemToggle class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCScheduler
 */
#pragma mark - CCScheduler

JSClass* JSPROXY_CCScheduler_class = NULL;
JSObject* JSPROXY_CCScheduler_object = NULL;
 // Constructor
JSBool JSPROXY_CCScheduler_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCScheduler createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCScheduler_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCScheduler)", obj);
}

// Arguments: NSObject*
// Ret value: BOOL (b)
JSBool JSPROXY_CCScheduler_isTargetPaused_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	BOOL ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real isTargetPaused:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSSet* (set)
JSBool JSPROXY_CCScheduler_pauseAllTargets(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSSet* ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real pauseAllTargets ];

	jsval ret_jsval = NSSet_to_jsval( cx, (NSSet*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: NSSet* (set)
JSBool JSPROXY_CCScheduler_pauseAllTargetsWithMinPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	NSSet* ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real pauseAllTargetsWithMinPriority:(NSInteger)arg0  ];

	jsval ret_jsval = NSSet_to_jsval( cx, (NSSet*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_pauseTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real pauseTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_resumeTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real resumeTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSSet*
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_resumeTargets_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSSet* arg0; 

	ok &= jsval_to_nsset( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real resumeTargets:(NSSet*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*, NSInteger, BOOL
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_scheduleUpdateForTarget_priority_paused_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; JSBool arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real scheduleUpdateForTarget:(NSObject*)arg0 priority:(NSInteger)arg1 paused:(BOOL)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_setTimeScale_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real setTimeScale:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSPROXY_CCScheduler_timeScale(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccTime ret_val;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	ret_val = [real timeScale ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_unscheduleAllSelectors(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleAllSelectors ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_unscheduleAllSelectorsForTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleAllSelectorsForTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_unscheduleAllSelectorsWithMinPriority_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleAllSelectorsWithMinPriority:(NSInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_unscheduleUpdateForTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real unscheduleUpdateForTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCScheduler_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCScheduler *real = (CCScheduler*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCScheduler_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCScheduler_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCScheduler_class->name = name;
	JSPROXY_CCScheduler_class->addProperty = JS_PropertyStub;
	JSPROXY_CCScheduler_class->delProperty = JS_PropertyStub;
	JSPROXY_CCScheduler_class->getProperty = JS_PropertyStub;
	JSPROXY_CCScheduler_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCScheduler_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCScheduler_class->resolve = JS_ResolveStub;
	JSPROXY_CCScheduler_class->convert = JS_ConvertStub;
	JSPROXY_CCScheduler_class->finalize = JSPROXY_CCScheduler_finalize;
//	JSPROXY_CCScheduler_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("isTargetPaused", JSPROXY_CCScheduler_isTargetPaused_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("pauseAllTargets", JSPROXY_CCScheduler_pauseAllTargets, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("pauseAllTargetsWithMinPriority", JSPROXY_CCScheduler_pauseAllTargetsWithMinPriority_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("pauseTarget", JSPROXY_CCScheduler_pauseTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("resumeTarget", JSPROXY_CCScheduler_resumeTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("resumeTargets", JSPROXY_CCScheduler_resumeTargets_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("scheduleUpdateForTargetPriorityPaused", JSPROXY_CCScheduler_scheduleUpdateForTarget_priority_paused_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTimeScale", JSPROXY_CCScheduler_setTimeScale_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTimeScale", JSPROXY_CCScheduler_timeScale, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllSelectors", JSPROXY_CCScheduler_unscheduleAllSelectors, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllSelectorsForTarget", JSPROXY_CCScheduler_unscheduleAllSelectorsForTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("unscheduleAllSelectorsWithMinPriority", JSPROXY_CCScheduler_unscheduleAllSelectorsWithMinPriority_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("unscheduleUpdateForTarget", JSPROXY_CCScheduler_unscheduleUpdateForTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("update", JSPROXY_CCScheduler_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCScheduler_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCScheduler_class, JSPROXY_CCScheduler_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCScheduler

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCScheduler_class, JSPROXY_CCScheduler_object, NULL);
	JSPROXY_CCScheduler *proxy = [[JSPROXY_CCScheduler alloc] initWithJSObject:jsobj class:[CCScheduler class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFollow
 */
#pragma mark - CCFollow

JSClass* JSPROXY_CCFollow_class = NULL;
JSObject* JSPROXY_CCFollow_object = NULL;
 // Constructor
JSBool JSPROXY_CCFollow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFollow createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFollow_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFollow)", obj);
}

// Arguments: CCNode*, CGRect
// Ret value: CCFollow* (o)
JSBool JSPROXY_CCFollow_actionWithTarget_worldBoundary__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if (argc >= 2) {
		ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCFollow* ret_val;

	if( argc == 1 ) {
		ret_val = [CCFollow actionWithTarget:(CCNode*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCFollow actionWithTarget:(CCNode*)arg0 worldBoundary:(CGRect)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCFollow_boundarySet(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCFollow *real = (CCFollow*) [proxy realObj];
	ret_val = [real boundarySet ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCNode*
// Ret value: None (None)
JSBool JSPROXY_CCFollow_initWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCFollow *real = [(CCFollow*)[proxy.klass alloc] initWithTarget:(CCNode*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCNode*, CGRect
// Ret value: None (None)
JSBool JSPROXY_CCFollow_initWithTarget_worldBoundary_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCFollow *real = [(CCFollow*)[proxy.klass alloc] initWithTarget:(CCNode*)arg0 worldBoundary:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCFollow_setBoundarySet_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFollow *real = (CCFollow*) [proxy realObj];
	[real setBoundarySet:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFollow* (o)
JSBool JSPROXY_CCFollow_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFollow* ret_val;

	ret_val = [CCFollow action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFollow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFollow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFollow_class->name = name;
	JSPROXY_CCFollow_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFollow_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFollow_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFollow_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFollow_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFollow_class->resolve = JS_ResolveStub;
	JSPROXY_CCFollow_class->convert = JS_ConvertStub;
	JSPROXY_CCFollow_class->finalize = JSPROXY_CCFollow_finalize;
//	JSPROXY_CCFollow_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBoundarySet", JSPROXY_CCFollow_boundarySet, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTarget", JSPROXY_CCFollow_initWithTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTargetWorldBoundary", JSPROXY_CCFollow_initWithTarget_worldBoundary_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBoundarySet", JSPROXY_CCFollow_setBoundarySet_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFollow_actionWithTarget_worldBoundary__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFollow_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFollow_object = JS_InitClass(cx, globalObj, JSPROXY_CCAction_object, JSPROXY_CCFollow_class, JSPROXY_CCFollow_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFollow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFollow_class, JSPROXY_CCFollow_object, NULL);
	JSPROXY_CCFollow *proxy = [[JSPROXY_CCFollow alloc] initWithJSObject:jsobj class:[CCFollow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCOrbitCamera
 */
#pragma mark - CCOrbitCamera

JSClass* JSPROXY_CCOrbitCamera_class = NULL;
JSObject* JSPROXY_CCOrbitCamera_object = NULL;
 // Constructor
JSBool JSPROXY_CCOrbitCamera_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCOrbitCamera createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCOrbitCamera_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCOrbitCamera)", obj);
}

// Arguments: float, float, float, float, float, float, float
// Ret value: CCOrbitCamera* (o)
JSBool JSPROXY_CCOrbitCamera_actionWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 7, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; double arg5; double arg6; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	if( ! ok ) return JS_FALSE;
	CCOrbitCamera* ret_val;

	ret_val = [CCOrbitCamera actionWithDuration:(float)arg0 radius:(float)arg1 deltaRadius:(float)arg2 angleZ:(float)arg3 deltaAngleZ:(float)arg4 angleX:(float)arg5 deltaAngleX:(float)arg6  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: float, float, float, float, float, float, float
// Ret value: None (None)
JSBool JSPROXY_CCOrbitCamera_initWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 7, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; double arg5; double arg6; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	if( ! ok ) return JS_FALSE;

	CCOrbitCamera *real = [(CCOrbitCamera*)[proxy.klass alloc] initWithDuration:(float)arg0 radius:(float)arg1 deltaRadius:(float)arg2 angleZ:(float)arg3 deltaAngleZ:(float)arg4 angleX:(float)arg5 deltaAngleX:(float)arg6  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCOrbitCamera* (o)
JSBool JSPROXY_CCOrbitCamera_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCOrbitCamera* ret_val;

	ret_val = [CCOrbitCamera actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCOrbitCamera* (o)
JSBool JSPROXY_CCOrbitCamera_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCOrbitCamera* ret_val;

	ret_val = [CCOrbitCamera action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCOrbitCamera_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCOrbitCamera_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCOrbitCamera_class->name = name;
	JSPROXY_CCOrbitCamera_class->addProperty = JS_PropertyStub;
	JSPROXY_CCOrbitCamera_class->delProperty = JS_PropertyStub;
	JSPROXY_CCOrbitCamera_class->getProperty = JS_PropertyStub;
	JSPROXY_CCOrbitCamera_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCOrbitCamera_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCOrbitCamera_class->resolve = JS_ResolveStub;
	JSPROXY_CCOrbitCamera_class->convert = JS_ConvertStub;
	JSPROXY_CCOrbitCamera_class->finalize = JSPROXY_CCOrbitCamera_finalize;
//	JSPROXY_CCOrbitCamera_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationRadiusDeltaRadiusAngleZDeltaAngleZAngleXDeltaAngleX", JSPROXY_CCOrbitCamera_initWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX_, 7, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDurationRadiusDeltaRadiusAngleZDeltaAngleZAngleXDeltaAngleX", JSPROXY_CCOrbitCamera_actionWithDuration_radius_deltaRadius_angleZ_deltaAngleZ_angleX_deltaAngleX__static, 7, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCOrbitCamera_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCOrbitCamera_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCOrbitCamera_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionCamera_object, JSPROXY_CCOrbitCamera_class, JSPROXY_CCOrbitCamera_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCOrbitCamera

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCOrbitCamera_class, JSPROXY_CCOrbitCamera_object, NULL);
	JSPROXY_CCOrbitCamera *proxy = [[JSPROXY_CCOrbitCamera alloc] initWithJSObject:jsobj class:[CCOrbitCamera class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimationFrame
 */
#pragma mark - CCAnimationFrame

JSClass* JSPROXY_CCAnimationFrame_class = NULL;
JSObject* JSPROXY_CCAnimationFrame_object = NULL;
 // Constructor
JSBool JSPROXY_CCAnimationFrame_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAnimationFrame createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAnimationFrame_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAnimationFrame)", obj);
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCAnimationFrame_delayUnits(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	ret_val = [real delayUnits ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCAnimationFrame_setDelayUnits_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	[real setDelayUnits:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSPROXY_CCAnimationFrame_setSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	[real setSpriteFrame:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteFrame* (o)
JSBool JSPROXY_CCAnimationFrame_spriteFrame(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSpriteFrame* ret_val;

	CCAnimationFrame *real = (CCAnimationFrame*) [proxy realObj];
	ret_val = [real spriteFrame ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCAnimationFrame_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAnimationFrame_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAnimationFrame_class->name = name;
	JSPROXY_CCAnimationFrame_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAnimationFrame_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAnimationFrame_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAnimationFrame_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAnimationFrame_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAnimationFrame_class->resolve = JS_ResolveStub;
	JSPROXY_CCAnimationFrame_class->convert = JS_ConvertStub;
	JSPROXY_CCAnimationFrame_class->finalize = JSPROXY_CCAnimationFrame_finalize;
//	JSPROXY_CCAnimationFrame_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDelayUnits", JSPROXY_CCAnimationFrame_delayUnits, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDelayUnits", JSPROXY_CCAnimationFrame_setDelayUnits_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSpriteFrame", JSPROXY_CCAnimationFrame_setSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSpriteFrame", JSPROXY_CCAnimationFrame_spriteFrame, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCAnimationFrame_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCAnimationFrame_class, JSPROXY_CCAnimationFrame_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAnimationFrame

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAnimationFrame_class, JSPROXY_CCAnimationFrame_object, NULL);
	JSPROXY_CCAnimationFrame *proxy = [[JSPROXY_CCAnimationFrame alloc] initWithJSObject:jsobj class:[CCAnimationFrame class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInL
 */
#pragma mark - CCTransitionSlideInL

JSClass* JSPROXY_CCTransitionSlideInL_class = NULL;
JSObject* JSPROXY_CCTransitionSlideInL_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionSlideInL_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionSlideInL createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionSlideInL_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionSlideInL)", obj);
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionSlideInL_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionSlideInL *real = (CCTransitionSlideInL*) [proxy realObj];
	ret_val = [real action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionSlideInL_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionSlideInL *real = (CCTransitionSlideInL*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionSlideInL_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionSlideInL *real = (CCTransitionSlideInL*) [proxy realObj];
	ret_val = [real easeActionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInL* (o)
JSBool JSPROXY_CCTransitionSlideInL_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionSlideInL* ret_val;

	ret_val = [CCTransitionSlideInL transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInL* (o)
JSBool JSPROXY_CCTransitionSlideInL_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionSlideInL* ret_val;

	ret_val = [CCTransitionSlideInL node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionSlideInL_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionSlideInL_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionSlideInL_class->name = name;
	JSPROXY_CCTransitionSlideInL_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInL_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInL_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInL_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionSlideInL_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionSlideInL_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionSlideInL_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionSlideInL_class->finalize = JSPROXY_CCTransitionSlideInL_finalize;
//	JSPROXY_CCTransitionSlideInL_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSPROXY_CCTransitionSlideInL_action, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initScenes", JSPROXY_CCTransitionSlideInL_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSPROXY_CCTransitionSlideInL_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionSlideInL_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionSlideInL_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionSlideInL_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionSlideInL_class, JSPROXY_CCTransitionSlideInL_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionSlideInL

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionSlideInL_class, JSPROXY_CCTransitionSlideInL_object, NULL);
	JSPROXY_CCTransitionSlideInL *proxy = [[JSPROXY_CCTransitionSlideInL alloc] initWithJSObject:jsobj class:[CCTransitionSlideInL class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInB
 */
#pragma mark - CCTransitionSlideInB

JSClass* JSPROXY_CCTransitionSlideInB_class = NULL;
JSObject* JSPROXY_CCTransitionSlideInB_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionSlideInB_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionSlideInB createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionSlideInB_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionSlideInB)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionSlideInB_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionSlideInB *real = (CCTransitionSlideInB*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInB* (o)
JSBool JSPROXY_CCTransitionSlideInB_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionSlideInB* ret_val;

	ret_val = [CCTransitionSlideInB transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInB* (o)
JSBool JSPROXY_CCTransitionSlideInB_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionSlideInB* ret_val;

	ret_val = [CCTransitionSlideInB node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionSlideInB_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionSlideInB_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionSlideInB_class->name = name;
	JSPROXY_CCTransitionSlideInB_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInB_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInB_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInB_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionSlideInB_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionSlideInB_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionSlideInB_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionSlideInB_class->finalize = JSPROXY_CCTransitionSlideInB_finalize;
//	JSPROXY_CCTransitionSlideInB_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSPROXY_CCTransitionSlideInB_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionSlideInB_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionSlideInB_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionSlideInB_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSlideInL_object, JSPROXY_CCTransitionSlideInB_class, JSPROXY_CCTransitionSlideInB_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionSlideInB

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionSlideInB_class, JSPROXY_CCTransitionSlideInB_object, NULL);
	JSPROXY_CCTransitionSlideInB *proxy = [[JSPROXY_CCTransitionSlideInB alloc] initWithJSObject:jsobj class:[CCTransitionSlideInB class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParallaxNode
 */
#pragma mark - CCParallaxNode

JSClass* JSPROXY_CCParallaxNode_class = NULL;
JSObject* JSPROXY_CCParallaxNode_object = NULL;
 // Constructor
JSBool JSPROXY_CCParallaxNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParallaxNode createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParallaxNode_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParallaxNode)", obj);
}

// Arguments: CCNode*, NSInteger, CGPoint, CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCParallaxNode_addChild_z_parallaxRatio_positionOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; int32_t arg1; CGPoint arg2; CGPoint arg3; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg2 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	if( ! ok ) return JS_FALSE;

	CCParallaxNode *real = (CCParallaxNode*) [proxy realObj];
	[real addChild:(CCNode*)arg0 z:(NSInteger)arg1 parallaxRatio:(CGPoint)arg2 positionOffset:(CGPoint)arg3  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParallaxNode* (o)
JSBool JSPROXY_CCParallaxNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParallaxNode* ret_val;

	ret_val = [CCParallaxNode node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParallaxNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParallaxNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParallaxNode_class->name = name;
	JSPROXY_CCParallaxNode_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParallaxNode_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParallaxNode_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParallaxNode_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParallaxNode_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParallaxNode_class->resolve = JS_ResolveStub;
	JSPROXY_CCParallaxNode_class->convert = JS_ConvertStub;
	JSPROXY_CCParallaxNode_class->finalize = JSPROXY_CCParallaxNode_finalize;
//	JSPROXY_CCParallaxNode_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addChild", JSPROXY_CCParallaxNode_addChild_z_parallaxRatio_positionOffset_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCParallaxNode_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParallaxNode_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCParallaxNode_class, JSPROXY_CCParallaxNode_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParallaxNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParallaxNode_class, JSPROXY_CCParallaxNode_object, NULL);
	JSPROXY_CCParallaxNode *proxy = [[JSPROXY_CCParallaxNode alloc] initWithJSObject:jsobj class:[CCParallaxNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressHorizontal
 */
#pragma mark - CCTransitionProgressHorizontal

JSClass* JSPROXY_CCTransitionProgressHorizontal_class = NULL;
JSObject* JSPROXY_CCTransitionProgressHorizontal_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionProgressHorizontal_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionProgressHorizontal createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionProgressHorizontal_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionProgressHorizontal)", obj);
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCTransitionProgressHorizontal_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	CCTransitionProgressHorizontal *real = (CCTransitionProgressHorizontal*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:(CCRenderTexture*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressHorizontal* (o)
JSBool JSPROXY_CCTransitionProgressHorizontal_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionProgressHorizontal* ret_val;

	ret_val = [CCTransitionProgressHorizontal transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressHorizontal* (o)
JSBool JSPROXY_CCTransitionProgressHorizontal_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionProgressHorizontal* ret_val;

	ret_val = [CCTransitionProgressHorizontal node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionProgressHorizontal_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionProgressHorizontal_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionProgressHorizontal_class->name = name;
	JSPROXY_CCTransitionProgressHorizontal_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressHorizontal_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressHorizontal_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressHorizontal_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionProgressHorizontal_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionProgressHorizontal_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionProgressHorizontal_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionProgressHorizontal_class->finalize = JSPROXY_CCTransitionProgressHorizontal_finalize;
//	JSPROXY_CCTransitionProgressHorizontal_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSPROXY_CCTransitionProgressHorizontal_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionProgressHorizontal_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionProgressHorizontal_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionProgressHorizontal_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionProgress_object, JSPROXY_CCTransitionProgressHorizontal_class, JSPROXY_CCTransitionProgressHorizontal_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionProgressHorizontal

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionProgressHorizontal_class, JSPROXY_CCTransitionProgressHorizontal_object, NULL);
	JSPROXY_CCTransitionProgressHorizontal *proxy = [[JSPROXY_CCTransitionProgressHorizontal alloc] initWithJSObject:jsobj class:[CCTransitionProgressHorizontal class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRepeat
 */
#pragma mark - CCRepeat

JSClass* JSPROXY_CCRepeat_class = NULL;
JSObject* JSPROXY_CCRepeat_object = NULL;
 // Constructor
JSBool JSPROXY_CCRepeat_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCRepeat createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCRepeat_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCRepeat)", obj);
}

// Arguments: CCFiniteTimeAction*, NSUInteger
// Ret value: CCRepeat* (o)
JSBool JSPROXY_CCRepeat_actionWithAction_times__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCRepeat* ret_val;

	ret_val = [CCRepeat actionWithAction:(CCFiniteTimeAction*)arg0 times:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCRepeat_initWithAction_times_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCRepeat *real = [(CCRepeat*)[proxy.klass alloc] initWithAction:(CCFiniteTimeAction*)arg0 times:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFiniteTimeAction* (o)
JSBool JSPROXY_CCRepeat_innerAction(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFiniteTimeAction* ret_val;

	CCRepeat *real = (CCRepeat*) [proxy realObj];
	ret_val = [real innerAction ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*
// Ret value: void (None)
JSBool JSPROXY_CCRepeat_setInnerAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCRepeat *real = (CCRepeat*) [proxy realObj];
	[real setInnerAction:(CCFiniteTimeAction*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCRepeat* (o)
JSBool JSPROXY_CCRepeat_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCRepeat* ret_val;

	ret_val = [CCRepeat actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCRepeat* (o)
JSBool JSPROXY_CCRepeat_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCRepeat* ret_val;

	ret_val = [CCRepeat action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCRepeat_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCRepeat_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCRepeat_class->name = name;
	JSPROXY_CCRepeat_class->addProperty = JS_PropertyStub;
	JSPROXY_CCRepeat_class->delProperty = JS_PropertyStub;
	JSPROXY_CCRepeat_class->getProperty = JS_PropertyStub;
	JSPROXY_CCRepeat_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCRepeat_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCRepeat_class->resolve = JS_ResolveStub;
	JSPROXY_CCRepeat_class->convert = JS_ConvertStub;
	JSPROXY_CCRepeat_class->finalize = JSPROXY_CCRepeat_finalize;
//	JSPROXY_CCRepeat_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionTimes", JSPROXY_CCRepeat_initWithAction_times_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getInnerAction", JSPROXY_CCRepeat_innerAction, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setInnerAction", JSPROXY_CCRepeat_setInnerAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCRepeat_actionWithAction_times__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCRepeat_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCRepeat_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCRepeat_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCRepeat_class, JSPROXY_CCRepeat_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCRepeat

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCRepeat_class, JSPROXY_CCRepeat_object, NULL);
	JSPROXY_CCRepeat *proxy = [[JSPROXY_CCRepeat alloc] initWithJSObject:jsobj class:[CCRepeat class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSnow
 */
#pragma mark - CCParticleSnow

JSClass* JSPROXY_CCParticleSnow_class = NULL;
JSObject* JSPROXY_CCParticleSnow_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleSnow_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleSnow createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleSnow_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleSnow)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleSnow_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSnow *real = [(CCParticleSnow*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSnow* (o)
JSBool JSPROXY_CCParticleSnow_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSnow* ret_val;

	ret_val = [CCParticleSnow particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSnow* (o)
JSBool JSPROXY_CCParticleSnow_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSnow* ret_val;

	ret_val = [CCParticleSnow particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSnow* (o)
JSBool JSPROXY_CCParticleSnow_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleSnow* ret_val;

	ret_val = [CCParticleSnow node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleSnow_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleSnow_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleSnow_class->name = name;
	JSPROXY_CCParticleSnow_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleSnow_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleSnow_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleSnow_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleSnow_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleSnow_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleSnow_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleSnow_class->finalize = JSPROXY_CCParticleSnow_finalize;
//	JSPROXY_CCParticleSnow_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleSnow_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleSnow_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleSnow_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleSnow_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleSnow_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleSnow_class, JSPROXY_CCParticleSnow_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleSnow

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleSnow_class, JSPROXY_CCParticleSnow_object, NULL);
	JSPROXY_CCParticleSnow *proxy = [[JSPROXY_CCParticleSnow alloc] initWithJSObject:jsobj class:[CCParticleSnow class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShatteredTiles3D
 */
#pragma mark - CCShatteredTiles3D

JSClass* JSPROXY_CCShatteredTiles3D_class = NULL;
JSObject* JSPROXY_CCShatteredTiles3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCShatteredTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCShatteredTiles3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCShatteredTiles3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCShatteredTiles3D)", obj);
}

// Arguments: int, BOOL, ccGridSize, ccTime
// Ret value: CCShatteredTiles3D* (o)
JSBool JSPROXY_CCShatteredTiles3D_actionWithRange_shatterZ_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCShatteredTiles3D* ret_val;

	ret_val = [CCShatteredTiles3D actionWithRange:(int)arg0 shatterZ:(BOOL)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int, BOOL, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCShatteredTiles3D_initWithRange_shatterZ_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCShatteredTiles3D *real = [(CCShatteredTiles3D*)[proxy.klass alloc] initWithRange:(int)arg0 shatterZ:(BOOL)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCShatteredTiles3D* (o)
JSBool JSPROXY_CCShatteredTiles3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCShatteredTiles3D* ret_val;

	ret_val = [CCShatteredTiles3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCShatteredTiles3D* (o)
JSBool JSPROXY_CCShatteredTiles3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCShatteredTiles3D* ret_val;

	ret_val = [CCShatteredTiles3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShatteredTiles3D* (o)
JSBool JSPROXY_CCShatteredTiles3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCShatteredTiles3D* ret_val;

	ret_val = [CCShatteredTiles3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCShatteredTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCShatteredTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCShatteredTiles3D_class->name = name;
	JSPROXY_CCShatteredTiles3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCShatteredTiles3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCShatteredTiles3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCShatteredTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCShatteredTiles3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCShatteredTiles3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCShatteredTiles3D_class->convert = JS_ConvertStub;
	JSPROXY_CCShatteredTiles3D_class->finalize = JSPROXY_CCShatteredTiles3D_finalize;
//	JSPROXY_CCShatteredTiles3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithRangeShatterZGridDuration", JSPROXY_CCShatteredTiles3D_initWithRange_shatterZ_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithRangeShatterZGridDuration", JSPROXY_CCShatteredTiles3D_actionWithRange_shatterZ_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCShatteredTiles3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCShatteredTiles3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCShatteredTiles3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCShatteredTiles3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCShatteredTiles3D_class, JSPROXY_CCShatteredTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCShatteredTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCShatteredTiles3D_class, JSPROXY_CCShatteredTiles3D_object, NULL);
	JSPROXY_CCShatteredTiles3D *proxy = [[JSPROXY_CCShatteredTiles3D alloc] initWithJSObject:jsobj class:[CCShatteredTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTimer
 */
#pragma mark - CCTimer

JSClass* JSPROXY_CCTimer_class = NULL;
JSObject* JSPROXY_CCTimer_object = NULL;
 // Constructor
JSBool JSPROXY_CCTimer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTimer createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTimer_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTimer)", obj);
}

// Arguments: 
// Ret value: ccTime (d)
JSBool JSPROXY_CCTimer_interval(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccTime ret_val;

	CCTimer *real = (CCTimer*) [proxy realObj];
	ret_val = [real interval ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCTimer_setInterval_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTimer *real = (CCTimer*) [proxy realObj];
	[real setInterval:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCTimer_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTimer *real = (CCTimer*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCTimer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTimer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTimer_class->name = name;
	JSPROXY_CCTimer_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTimer_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTimer_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTimer_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTimer_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTimer_class->resolve = JS_ResolveStub;
	JSPROXY_CCTimer_class->convert = JS_ConvertStub;
	JSPROXY_CCTimer_class->finalize = JSPROXY_CCTimer_finalize;
//	JSPROXY_CCTimer_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getInterval", JSPROXY_CCTimer_interval, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setInterval", JSPROXY_CCTimer_setInterval_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("update", JSPROXY_CCTimer_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCTimer_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTimer_class, JSPROXY_CCTimer_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTimer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTimer_class, JSPROXY_CCTimer_object, NULL);
	JSPROXY_CCTimer *proxy = [[JSPROXY_CCTimer alloc] initWithJSObject:jsobj class:[CCTimer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFlipY
 */
#pragma mark - CCTransitionFlipY

JSClass* JSPROXY_CCTransitionFlipY_class = NULL;
JSObject* JSPROXY_CCTransitionFlipY_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFlipY_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFlipY createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFlipY_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFlipY)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionFlipY_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionFlipY *real = [(CCTransitionFlipY*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionFlipY* (o)
JSBool JSPROXY_CCTransitionFlipY_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTransitionFlipY* ret_val;

	ret_val = [CCTransitionFlipY transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFlipY* (o)
JSBool JSPROXY_CCTransitionFlipY_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionFlipY* ret_val;

	ret_val = [CCTransitionFlipY transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFlipY* (o)
JSBool JSPROXY_CCTransitionFlipY_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFlipY* ret_val;

	ret_val = [CCTransitionFlipY node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFlipY_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFlipY_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFlipY_class->name = name;
	JSPROXY_CCTransitionFlipY_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipY_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipY_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipY_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFlipY_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFlipY_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFlipY_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFlipY_class->finalize = JSPROXY_CCTransitionFlipY_finalize;
//	JSPROXY_CCTransitionFlipY_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionFlipY_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSPROXY_CCTransitionFlipY_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTransitionFlipY_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFlipY_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFlipY_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSceneOriented_object, JSPROXY_CCTransitionFlipY_class, JSPROXY_CCTransitionFlipY_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFlipY

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFlipY_class, JSPROXY_CCTransitionFlipY_object, NULL);
	JSPROXY_CCTransitionFlipY *proxy = [[JSPROXY_CCTransitionFlipY alloc] initWithJSObject:jsobj class:[CCTransitionFlipY class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFlipX
 */
#pragma mark - CCTransitionFlipX

JSClass* JSPROXY_CCTransitionFlipX_class = NULL;
JSObject* JSPROXY_CCTransitionFlipX_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFlipX_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFlipX createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFlipX_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFlipX)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionFlipX_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionFlipX *real = [(CCTransitionFlipX*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionFlipX* (o)
JSBool JSPROXY_CCTransitionFlipX_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTransitionFlipX* ret_val;

	ret_val = [CCTransitionFlipX transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFlipX* (o)
JSBool JSPROXY_CCTransitionFlipX_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionFlipX* ret_val;

	ret_val = [CCTransitionFlipX transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFlipX* (o)
JSBool JSPROXY_CCTransitionFlipX_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFlipX* ret_val;

	ret_val = [CCTransitionFlipX node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFlipX_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFlipX_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFlipX_class->name = name;
	JSPROXY_CCTransitionFlipX_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipX_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipX_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFlipX_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFlipX_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFlipX_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFlipX_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFlipX_class->finalize = JSPROXY_CCTransitionFlipX_finalize;
//	JSPROXY_CCTransitionFlipX_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionFlipX_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSPROXY_CCTransitionFlipX_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTransitionFlipX_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFlipX_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFlipX_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSceneOriented_object, JSPROXY_CCTransitionFlipX_class, JSPROXY_CCTransitionFlipX_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFlipX

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFlipX_class, JSPROXY_CCTransitionFlipX_object, NULL);
	JSPROXY_CCTransitionFlipX *proxy = [[JSPROXY_CCTransitionFlipX alloc] initWithJSObject:jsobj class:[CCTransitionFlipX class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpriteFrame
 */
#pragma mark - CCSpriteFrame

JSClass* JSPROXY_CCSpriteFrame_class = NULL;
JSObject* JSPROXY_CCSpriteFrame_object = NULL;
 // Constructor
JSBool JSPROXY_CCSpriteFrame_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSpriteFrame createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSpriteFrame_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSpriteFrame)", obj);
}

// Arguments: CCTexture2D*, CGRect
// Ret value: CCSpriteFrame* (o)
JSBool JSPROXY_CCSpriteFrame_frameWithTexture_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;
	CCSpriteFrame* ret_val;

	ret_val = [CCSpriteFrame frameWithTexture:(CCTexture2D*)arg0 rect:(CGRect)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect, BOOL, CGPoint, CGSize
// Ret value: CCSpriteFrame* (o)
JSBool JSPROXY_CCSpriteFrame_frameWithTexture_rectInPixels_rotated_offset_originalSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	if( ! ok ) return JS_FALSE;
	CCSpriteFrame* ret_val;

	ret_val = [CCSpriteFrame frameWithTexture:(CCTexture2D*)arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: CCSpriteFrame* (o)
JSBool JSPROXY_CCSpriteFrame_frameWithTextureFilename_rect__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;
	CCSpriteFrame* ret_val;

	ret_val = [CCSpriteFrame frameWithTextureFilename:(NSString*)arg0 rect:(CGRect)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, CGRect, BOOL, CGPoint, CGSize
// Ret value: CCSpriteFrame* (o)
JSBool JSPROXY_CCSpriteFrame_frameWithTextureFilename_rectInPixels_rotated_offset_originalSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	if( ! ok ) return JS_FALSE;
	CCSpriteFrame* ret_val;

	ret_val = [CCSpriteFrame frameWithTextureFilename:(NSString*)arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: None (None)
JSBool JSPROXY_CCSpriteFrame_initWithTexture_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect, BOOL, CGPoint, CGSize
// Ret value: None (None)
JSBool JSPROXY_CCSpriteFrame_initWithTexture_rectInPixels_rotated_offset_originalSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGRect
// Ret value: None (None)
JSBool JSPROXY_CCSpriteFrame_initWithTextureFilename_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTextureFilename:(NSString*)arg0 rect:(CGRect)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CGRect, BOOL, CGPoint, CGSize
// Ret value: None (None)
JSBool JSPROXY_CCSpriteFrame_initWithTextureFilename_rectInPixels_rotated_offset_originalSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; CGRect arg1; JSBool arg2; CGPoint arg3; CGSize arg4; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg3 );
	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg4 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = [(CCSpriteFrame*)[proxy.klass alloc] initWithTextureFilename:(NSString*)arg0 rectInPixels:(CGRect)arg1 rotated:(BOOL)arg2 offset:(CGPoint)arg3 originalSize:(CGSize)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCSpriteFrame_offset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real offset ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCSpriteFrame_offsetInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real offsetInPixels ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCSpriteFrame_originalSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real originalSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCSpriteFrame_originalSizeInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real originalSizeInPixels ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSPROXY_CCSpriteFrame_rect(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGRect ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real rect ];

	jsval ret_jsval = CGRect_to_jsval( cx, (CGRect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGRect (N/A)
JSBool JSPROXY_CCSpriteFrame_rectInPixels(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGRect ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real rectInPixels ];

	jsval ret_jsval = CGRect_to_jsval( cx, (CGRect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCSpriteFrame_rotated(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real rotated ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOffset:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setOffsetInPixels_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOffsetInPixels:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setOriginalSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOriginalSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setOriginalSizeInPixels_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setOriginalSizeInPixels:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setRect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setRect:(CGRect)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGRect
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setRectInPixels_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGRect arg0; 

	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setRectInPixels:(CGRect)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setRotated_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setRotated:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrame_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCSpriteFrame_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCSpriteFrame_textureFilename(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCSpriteFrame *real = (CCSpriteFrame*) [proxy realObj];
	ret_val = [real textureFilename ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

void JSPROXY_CCSpriteFrame_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSpriteFrame_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSpriteFrame_class->name = name;
	JSPROXY_CCSpriteFrame_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSpriteFrame_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSpriteFrame_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSpriteFrame_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSpriteFrame_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSpriteFrame_class->resolve = JS_ResolveStub;
	JSPROXY_CCSpriteFrame_class->convert = JS_ConvertStub;
	JSPROXY_CCSpriteFrame_class->finalize = JSPROXY_CCSpriteFrame_finalize;
//	JSPROXY_CCSpriteFrame_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTextureRect", JSPROXY_CCSpriteFrame_initWithTexture_rect_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureRectInPixelsRotatedOffsetOriginalSize", JSPROXY_CCSpriteFrame_initWithTexture_rectInPixels_rotated_offset_originalSize_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureFilenameRect", JSPROXY_CCSpriteFrame_initWithTextureFilename_rect_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureFilenameRectInPixelsRotatedOffsetOriginalSize", JSPROXY_CCSpriteFrame_initWithTextureFilename_rectInPixels_rotated_offset_originalSize_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOffset", JSPROXY_CCSpriteFrame_offset, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOffsetInPixels", JSPROXY_CCSpriteFrame_offsetInPixels, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOriginalSize", JSPROXY_CCSpriteFrame_originalSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOriginalSizeInPixels", JSPROXY_CCSpriteFrame_originalSizeInPixels, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRect", JSPROXY_CCSpriteFrame_rect, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRectInPixels", JSPROXY_CCSpriteFrame_rectInPixels, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRotated", JSPROXY_CCSpriteFrame_rotated, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOffset", JSPROXY_CCSpriteFrame_setOffset_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOffsetInPixels", JSPROXY_CCSpriteFrame_setOffsetInPixels_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOriginalSize", JSPROXY_CCSpriteFrame_setOriginalSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOriginalSizeInPixels", JSPROXY_CCSpriteFrame_setOriginalSizeInPixels_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRect", JSPROXY_CCSpriteFrame_setRect_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRectInPixels", JSPROXY_CCSpriteFrame_setRectInPixels_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRotated", JSPROXY_CCSpriteFrame_setRotated_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCSpriteFrame_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCSpriteFrame_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTextureFilename", JSPROXY_CCSpriteFrame_textureFilename, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("frameWithTextureRect", JSPROXY_CCSpriteFrame_frameWithTexture_rect__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("frameWithTextureRectInPixelsRotatedOffsetOriginalSize", JSPROXY_CCSpriteFrame_frameWithTexture_rectInPixels_rotated_offset_originalSize__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("frameWithTextureFilenameRect", JSPROXY_CCSpriteFrame_frameWithTextureFilename_rect__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("frameWithTextureFilenameRectInPixelsRotatedOffsetOriginalSize", JSPROXY_CCSpriteFrame_frameWithTextureFilename_rectInPixels_rotated_offset_originalSize__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSpriteFrame_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCSpriteFrame_class, JSPROXY_CCSpriteFrame_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSpriteFrame

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSpriteFrame_class, JSPROXY_CCSpriteFrame_object, NULL);
	JSPROXY_CCSpriteFrame *proxy = [[JSPROXY_CCSpriteFrame alloc] initWithJSObject:jsobj class:[CCSpriteFrame class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSplitRows
 */
#pragma mark - CCSplitRows

JSClass* JSPROXY_CCSplitRows_class = NULL;
JSObject* JSPROXY_CCSplitRows_object = NULL;
 // Constructor
JSBool JSPROXY_CCSplitRows_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSplitRows createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSplitRows_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSplitRows)", obj);
}

// Arguments: int, ccTime
// Ret value: CCSplitRows* (o)
JSBool JSPROXY_CCSplitRows_actionWithRows_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCSplitRows* ret_val;

	ret_val = [CCSplitRows actionWithRows:(int)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCSplitRows_initWithRows_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSplitRows *real = [(CCSplitRows*)[proxy.klass alloc] initWithRows:(int)arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCSplitRows* (o)
JSBool JSPROXY_CCSplitRows_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCSplitRows* ret_val;

	ret_val = [CCSplitRows actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCSplitRows* (o)
JSBool JSPROXY_CCSplitRows_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSplitRows* ret_val;

	ret_val = [CCSplitRows actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSplitRows* (o)
JSBool JSPROXY_CCSplitRows_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSplitRows* ret_val;

	ret_val = [CCSplitRows action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSplitRows_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSplitRows_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSplitRows_class->name = name;
	JSPROXY_CCSplitRows_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSplitRows_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSplitRows_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSplitRows_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSplitRows_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSplitRows_class->resolve = JS_ResolveStub;
	JSPROXY_CCSplitRows_class->convert = JS_ConvertStub;
	JSPROXY_CCSplitRows_class->finalize = JSPROXY_CCSplitRows_finalize;
//	JSPROXY_CCSplitRows_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithRowsDuration", JSPROXY_CCSplitRows_initWithRows_duration_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithRowsDuration", JSPROXY_CCSplitRows_actionWithRows_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCSplitRows_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCSplitRows_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCSplitRows_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSplitRows_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCSplitRows_class, JSPROXY_CCSplitRows_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSplitRows

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSplitRows_class, JSPROXY_CCSplitRows_object, NULL);
	JSPROXY_CCSplitRows *proxy = [[JSPROXY_CCSplitRows alloc] initWithJSObject:jsobj class:[CCSplitRows class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * ChipmunkDebugNode
 */
#pragma mark - ChipmunkDebugNode

JSClass* JSPROXY_ChipmunkDebugNode_class = NULL;
JSObject* JSPROXY_ChipmunkDebugNode_object = NULL;
 // Constructor
JSBool JSPROXY_ChipmunkDebugNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_ChipmunkDebugNode createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_ChipmunkDebugNode_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (ChipmunkDebugNode)", obj);
}

// Arguments: cpSpace*
// Ret value: ChipmunkDebugNode* (o)
JSBool JSPROXY_ChipmunkDebugNode_debugNodeForCPSpace__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, *argvp++, (void**)&arg0 );
	if( ! ok ) return JS_FALSE;
	ChipmunkDebugNode* ret_val;

	ret_val = [ChipmunkDebugNode debugNodeForCPSpace:(cpSpace*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: ChipmunkDebugNode* (o)
JSBool JSPROXY_ChipmunkDebugNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ChipmunkDebugNode* ret_val;

	ret_val = [ChipmunkDebugNode node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_ChipmunkDebugNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_ChipmunkDebugNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_ChipmunkDebugNode_class->name = name;
	JSPROXY_ChipmunkDebugNode_class->addProperty = JS_PropertyStub;
	JSPROXY_ChipmunkDebugNode_class->delProperty = JS_PropertyStub;
	JSPROXY_ChipmunkDebugNode_class->getProperty = JS_PropertyStub;
	JSPROXY_ChipmunkDebugNode_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_ChipmunkDebugNode_class->enumerate = JS_EnumerateStub;
	JSPROXY_ChipmunkDebugNode_class->resolve = JS_ResolveStub;
	JSPROXY_ChipmunkDebugNode_class->convert = JS_ConvertStub;
	JSPROXY_ChipmunkDebugNode_class->finalize = JSPROXY_ChipmunkDebugNode_finalize;
//	JSPROXY_ChipmunkDebugNode_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_ChipmunkDebugNode_debugNodeForCPSpace__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_ChipmunkDebugNode_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_ChipmunkDebugNode_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_ChipmunkDebugNode_class, JSPROXY_ChipmunkDebugNode_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_ChipmunkDebugNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_ChipmunkDebugNode_class, JSPROXY_ChipmunkDebugNode_object, NULL);
	JSPROXY_ChipmunkDebugNode *proxy = [[JSPROXY_ChipmunkDebugNode alloc] initWithJSObject:jsobj class:[ChipmunkDebugNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTextureCache
 */
#pragma mark - CCTextureCache

JSClass* JSPROXY_CCTextureCache_class = NULL;
JSObject* JSPROXY_CCTextureCache_object = NULL;
 // Constructor
JSBool JSPROXY_CCTextureCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTextureCache createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTextureCache_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTextureCache)", obj);
}

// Arguments: NSString*
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCTextureCache_addImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTexture2D* ret_val;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	ret_val = [real addImage:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCTextureCache_addPVRImage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTexture2D* ret_val;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	ret_val = [real addPVRImage:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTextureCache_dumpCachedTextureInfo(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real dumpCachedTextureInfo ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTextureCache_purgeSharedTextureCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	[CCTextureCache purgeSharedTextureCache ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTextureCache_removeAllTextures(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeAllTextures ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCTextureCache_removeTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTextureCache_removeTextureForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeTextureForKey:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTextureCache_removeUnusedTextures(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	[real removeUnusedTextures ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTextureCache* (o)
JSBool JSPROXY_CCTextureCache_sharedTextureCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTextureCache* ret_val;

	ret_val = [CCTextureCache sharedTextureCache ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCTextureCache_textureForKey_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTexture2D* ret_val;

	CCTextureCache *real = (CCTextureCache*) [proxy realObj];
	ret_val = [real textureForKey:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTextureCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTextureCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTextureCache_class->name = name;
	JSPROXY_CCTextureCache_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTextureCache_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTextureCache_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTextureCache_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTextureCache_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTextureCache_class->resolve = JS_ResolveStub;
	JSPROXY_CCTextureCache_class->convert = JS_ConvertStub;
	JSPROXY_CCTextureCache_class->finalize = JSPROXY_CCTextureCache_finalize;
//	JSPROXY_CCTextureCache_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addImage", JSPROXY_CCTextureCache_addImage_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("addPVRImage", JSPROXY_CCTextureCache_addPVRImage_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("dumpCachedTextureInfo", JSPROXY_CCTextureCache_dumpCachedTextureInfo, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeAllTextures", JSPROXY_CCTextureCache_removeAllTextures, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeTexture", JSPROXY_CCTextureCache_removeTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeTextureForKey", JSPROXY_CCTextureCache_removeTextureForKey_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeUnusedTextures", JSPROXY_CCTextureCache_removeUnusedTextures, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("textureForKey", JSPROXY_CCTextureCache_textureForKey_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedTextureCache", JSPROXY_CCTextureCache_purgeSharedTextureCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getInstance", JSPROXY_CCTextureCache_sharedTextureCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTextureCache_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTextureCache_class, JSPROXY_CCTextureCache_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTextureCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTextureCache_class, JSPROXY_CCTextureCache_object, NULL);
	JSPROXY_CCTextureCache *proxy = [[JSPROXY_CCTextureCache alloc] initWithJSObject:jsobj class:[CCTextureCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRipple3D
 */
#pragma mark - CCRipple3D

JSClass* JSPROXY_CCRipple3D_class = NULL;
JSObject* JSPROXY_CCRipple3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCRipple3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCRipple3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCRipple3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCRipple3D)", obj);
}

// Arguments: CGPoint, float, int, float, ccGridSize, ccTime
// Ret value: CCRipple3D* (o)
JSBool JSPROXY_CCRipple3D_actionWithPosition_radius_waves_amplitude_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; double arg1; int32_t arg2; double arg3; ccGridSize arg4; double arg5; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;
	CCRipple3D* ret_val;

	ret_val = [CCRipple3D actionWithPosition:(CGPoint)arg0 radius:(float)arg1 waves:(int)arg2 amplitude:(float)arg3 grid:(ccGridSize)arg4 duration:(ccTime)arg5  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCRipple3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	ret_val = [real amplitude ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCRipple3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CGPoint, float, int, float, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCRipple3D_initWithPosition_radius_waves_amplitude_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; double arg1; int32_t arg2; double arg3; ccGridSize arg4; double arg5; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;

	CCRipple3D *real = [(CCRipple3D*)[proxy.klass alloc] initWithPosition:(CGPoint)arg0 radius:(float)arg1 waves:(int)arg2 amplitude:(float)arg3 grid:(ccGridSize)arg4 duration:(ccTime)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCRipple3D_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	ret_val = [real position ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCRipple3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCRipple3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCRipple3D_setPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCRipple3D *real = (CCRipple3D*) [proxy realObj];
	[real setPosition:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCRipple3D* (o)
JSBool JSPROXY_CCRipple3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCRipple3D* ret_val;

	ret_val = [CCRipple3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCRipple3D* (o)
JSBool JSPROXY_CCRipple3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCRipple3D* ret_val;

	ret_val = [CCRipple3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCRipple3D* (o)
JSBool JSPROXY_CCRipple3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCRipple3D* ret_val;

	ret_val = [CCRipple3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCRipple3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCRipple3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCRipple3D_class->name = name;
	JSPROXY_CCRipple3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCRipple3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCRipple3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCRipple3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCRipple3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCRipple3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCRipple3D_class->convert = JS_ConvertStub;
	JSPROXY_CCRipple3D_class->finalize = JSPROXY_CCRipple3D_finalize;
//	JSPROXY_CCRipple3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSPROXY_CCRipple3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSPROXY_CCRipple3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithPositionRadiusWavesAmplitudeGridDuration", JSPROXY_CCRipple3D_initWithPosition_radius_waves_amplitude_grid_duration_, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSPROXY_CCRipple3D_position, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSPROXY_CCRipple3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSPROXY_CCRipple3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSPROXY_CCRipple3D_setPosition_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithPositionRadiusWavesAmplitudeGridDuration", JSPROXY_CCRipple3D_actionWithPosition_radius_waves_amplitude_grid_duration__static, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCRipple3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCRipple3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCRipple3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCRipple3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCRipple3D_class, JSPROXY_CCRipple3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCRipple3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCRipple3D_class, JSPROXY_CCRipple3D_object, NULL);
	JSPROXY_CCRipple3D *proxy = [[JSPROXY_CCRipple3D alloc] initWithJSObject:jsobj class:[CCRipple3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRotateBy
 */
#pragma mark - CCRotateBy

JSClass* JSPROXY_CCRotateBy_class = NULL;
JSObject* JSPROXY_CCRotateBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCRotateBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCRotateBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCRotateBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCRotateBy)", obj);
}

// Arguments: ccTime, float
// Ret value: CCRotateBy* (o)
JSBool JSPROXY_CCRotateBy_actionWithDuration_angle__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCRotateBy* ret_val;

	ret_val = [CCRotateBy actionWithDuration:(ccTime)arg0 angle:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: CCRotateBy* (o)
JSBool JSPROXY_CCRotateBy_actionWithDuration_angleX_angleY__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCRotateBy* ret_val;

	ret_val = [CCRotateBy actionWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, float
// Ret value: None (None)
JSBool JSPROXY_CCRotateBy_initWithDuration_angle_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCRotateBy *real = [(CCRotateBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angle:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, float, float
// Ret value: None (None)
JSBool JSPROXY_CCRotateBy_initWithDuration_angleX_angleY_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCRotateBy *real = [(CCRotateBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 angleX:(float)arg1 angleY:(float)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCRotateBy* (o)
JSBool JSPROXY_CCRotateBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCRotateBy* ret_val;

	ret_val = [CCRotateBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCRotateBy* (o)
JSBool JSPROXY_CCRotateBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCRotateBy* ret_val;

	ret_val = [CCRotateBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCRotateBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCRotateBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCRotateBy_class->name = name;
	JSPROXY_CCRotateBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCRotateBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCRotateBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCRotateBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCRotateBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCRotateBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCRotateBy_class->convert = JS_ConvertStub;
	JSPROXY_CCRotateBy_class->finalize = JSPROXY_CCRotateBy_finalize;
//	JSPROXY_CCRotateBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationAngle", JSPROXY_CCRotateBy_initWithDuration_angle_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithDurationAngleXAngleY", JSPROXY_CCRotateBy_initWithDuration_angleX_angleY_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCRotateBy_actionWithDuration_angle__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDurationAngleXAngleY", JSPROXY_CCRotateBy_actionWithDuration_angleX_angleY__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCRotateBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCRotateBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCRotateBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCRotateBy_class, JSPROXY_CCRotateBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCRotateBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCRotateBy_class, JSPROXY_CCRotateBy_object, NULL);
	JSPROXY_CCRotateBy *proxy = [[JSPROXY_CCRotateBy alloc] initWithJSObject:jsobj class:[CCRotateBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseIn
 */
#pragma mark - CCEaseIn

JSClass* JSPROXY_CCEaseIn_class = NULL;
JSObject* JSPROXY_CCEaseIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseIn)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseIn *real = (CCEaseIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseIn* (o)
JSBool JSPROXY_CCEaseIn_actionWithAction_rate__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCEaseIn* ret_val;

	ret_val = [CCEaseIn actionWithAction:(CCActionInterval*)arg0 rate:(float)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseIn* (o)
JSBool JSPROXY_CCEaseIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseIn* ret_val;

	ret_val = [CCEaseIn actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseIn* (o)
JSBool JSPROXY_CCEaseIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseIn* ret_val;

	ret_val = [CCEaseIn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseIn* (o)
JSBool JSPROXY_CCEaseIn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseIn* ret_val;

	ret_val = [CCEaseIn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseIn_class->name = name;
	JSPROXY_CCEaseIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseIn_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseIn_class->finalize = JSPROXY_CCEaseIn_finalize;
//	JSPROXY_CCEaseIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseIn_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseIn_actionWithAction_rate__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithAction", JSPROXY_CCEaseIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseIn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseRateAction_object, JSPROXY_CCEaseIn_class, JSPROXY_CCEaseIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseIn_class, JSPROXY_CCEaseIn_object, NULL);
	JSPROXY_CCEaseIn *proxy = [[JSPROXY_CCEaseIn alloc] initWithJSObject:jsobj class:[CCEaseIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXMapInfo
 */
#pragma mark - CCTMXMapInfo

JSClass* JSPROXY_CCTMXMapInfo_class = NULL;
JSObject* JSPROXY_CCTMXMapInfo_object = NULL;
 // Constructor
JSBool JSPROXY_CCTMXMapInfo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTMXMapInfo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTMXMapInfo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTMXMapInfo)", obj);
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTMXMapInfo_filename(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real filename ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTMXMapInfo* (o)
JSBool JSPROXY_CCTMXMapInfo_formatWithTMXFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTMXMapInfo* ret_val;

	ret_val = [CCTMXMapInfo formatWithTMXFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: CCTMXMapInfo* (o)
JSBool JSPROXY_CCTMXMapInfo_formatWithXML_resourcePath__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTMXMapInfo* ret_val;

	ret_val = [CCTMXMapInfo formatWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCTMXMapInfo_initWithTMXFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = [(CCTMXMapInfo*)[proxy.klass alloc] initWithTMXFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSPROXY_CCTMXMapInfo_initWithXML_resourcePath_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = [(CCTMXMapInfo*)[proxy.klass alloc] initWithXML:(NSString*)arg0 resourcePath:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCTMXMapInfo_layers(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real layers ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXMapInfo_mapSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real mapSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCTMXMapInfo_objectGroups(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real objectGroups ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSPROXY_CCTMXMapInfo_orientation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	int ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real orientation ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTMXMapInfo_resources(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real resources ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setFilename:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setLayers_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setLayers:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setMapSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setMapSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setObjectGroups_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setObjectGroups:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setOrientation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setOrientation:(int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setResources_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setResources:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setTileSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setTileSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCTMXMapInfo_setTilesets_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	[real setTilesets:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXMapInfo_tileSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real tileSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCTMXMapInfo_tilesets(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCTMXMapInfo *real = (CCTMXMapInfo*) [proxy realObj];
	ret_val = [real tilesets ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

void JSPROXY_CCTMXMapInfo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTMXMapInfo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTMXMapInfo_class->name = name;
	JSPROXY_CCTMXMapInfo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTMXMapInfo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTMXMapInfo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTMXMapInfo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTMXMapInfo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTMXMapInfo_class->resolve = JS_ResolveStub;
	JSPROXY_CCTMXMapInfo_class->convert = JS_ConvertStub;
	JSPROXY_CCTMXMapInfo_class->finalize = JSPROXY_CCTMXMapInfo_finalize;
//	JSPROXY_CCTMXMapInfo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getFilename", JSPROXY_CCTMXMapInfo_filename, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTMXFile", JSPROXY_CCTMXMapInfo_initWithTMXFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithXMLResourcePath", JSPROXY_CCTMXMapInfo_initWithXML_resourcePath_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLayers", JSPROXY_CCTMXMapInfo_layers, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMapSize", JSPROXY_CCTMXMapInfo_mapSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getObjectGroups", JSPROXY_CCTMXMapInfo_objectGroups, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOrientation", JSPROXY_CCTMXMapInfo_orientation, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getResources", JSPROXY_CCTMXMapInfo_resources, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFilename", JSPROXY_CCTMXMapInfo_setFilename_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLayers", JSPROXY_CCTMXMapInfo_setLayers_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMapSize", JSPROXY_CCTMXMapInfo_setMapSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setObjectGroups", JSPROXY_CCTMXMapInfo_setObjectGroups_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOrientation", JSPROXY_CCTMXMapInfo_setOrientation_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setResources", JSPROXY_CCTMXMapInfo_setResources_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTileSize", JSPROXY_CCTMXMapInfo_setTileSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTilesets", JSPROXY_CCTMXMapInfo_setTilesets_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTileSize", JSPROXY_CCTMXMapInfo_tileSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTilesets", JSPROXY_CCTMXMapInfo_tilesets, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("formatWithTMXFile", JSPROXY_CCTMXMapInfo_formatWithTMXFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("formatWithXMLResourcePath", JSPROXY_CCTMXMapInfo_formatWithXML_resourcePath__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTMXMapInfo_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTMXMapInfo_class, JSPROXY_CCTMXMapInfo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTMXMapInfo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTMXMapInfo_class, JSPROXY_CCTMXMapInfo_object, NULL);
	JSPROXY_CCTMXMapInfo *proxy = [[JSPROXY_CCTMXMapInfo alloc] initWithJSObject:jsobj class:[CCTMXMapInfo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCParticleSmoke
 */
#pragma mark - CCParticleSmoke

JSClass* JSPROXY_CCParticleSmoke_class = NULL;
JSObject* JSPROXY_CCParticleSmoke_object = NULL;
 // Constructor
JSBool JSPROXY_CCParticleSmoke_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCParticleSmoke createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCParticleSmoke_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCParticleSmoke)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCParticleSmoke_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCParticleSmoke *real = [(CCParticleSmoke*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCParticleSmoke* (o)
JSBool JSPROXY_CCParticleSmoke_particleWithFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSmoke* ret_val;

	ret_val = [CCParticleSmoke particleWithFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCParticleSmoke* (o)
JSBool JSPROXY_CCParticleSmoke_particleWithTotalParticles__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCParticleSmoke* ret_val;

	ret_val = [CCParticleSmoke particleWithTotalParticles:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCParticleSmoke* (o)
JSBool JSPROXY_CCParticleSmoke_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCParticleSmoke* ret_val;

	ret_val = [CCParticleSmoke node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCParticleSmoke_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCParticleSmoke_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCParticleSmoke_class->name = name;
	JSPROXY_CCParticleSmoke_class->addProperty = JS_PropertyStub;
	JSPROXY_CCParticleSmoke_class->delProperty = JS_PropertyStub;
	JSPROXY_CCParticleSmoke_class->getProperty = JS_PropertyStub;
	JSPROXY_CCParticleSmoke_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCParticleSmoke_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCParticleSmoke_class->resolve = JS_ResolveStub;
	JSPROXY_CCParticleSmoke_class->convert = JS_ConvertStub;
	JSPROXY_CCParticleSmoke_class->finalize = JSPROXY_CCParticleSmoke_finalize;
//	JSPROXY_CCParticleSmoke_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCParticleSmoke_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("particleWithFile", JSPROXY_CCParticleSmoke_particleWithFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("particleWithTotalParticles", JSPROXY_CCParticleSmoke_particleWithTotalParticles__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCParticleSmoke_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCParticleSmoke_object = JS_InitClass(cx, globalObj, JSPROXY_CCParticleSystemQuad_object, JSPROXY_CCParticleSmoke_class, JSPROXY_CCParticleSmoke_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCParticleSmoke

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCParticleSmoke_class, JSPROXY_CCParticleSmoke_object, NULL);
	JSPROXY_CCParticleSmoke *proxy = [[JSPROXY_CCParticleSmoke alloc] initWithJSObject:jsobj class:[CCParticleSmoke class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTMXLayerInfo
 */
#pragma mark - CCTMXLayerInfo

JSClass* JSPROXY_CCTMXLayerInfo_class = NULL;
JSObject* JSPROXY_CCTMXLayerInfo_object = NULL;
 // Constructor
JSBool JSPROXY_CCTMXLayerInfo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTMXLayerInfo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTMXLayerInfo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTMXLayerInfo)", obj);
}

// Arguments: 
// Ret value: CGSize ({CGSize=ff})
JSBool JSPROXY_CCTMXLayerInfo_layerSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGSize ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real layerSize ];

	jsval ret_jsval = CGSize_to_jsval( cx, (CGSize)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSPROXY_CCTMXLayerInfo_maxGID(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	unsigned int ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real maxGID ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSPROXY_CCTMXLayerInfo_minGID(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	unsigned int ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real minGID ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCTMXLayerInfo_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real name ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCTMXLayerInfo_offset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real offset ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: unsigned char (c)
JSBool JSPROXY_CCTMXLayerInfo_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	unsigned char ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCTMXLayerInfo_ownTiles(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real ownTiles ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CGSize
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setLayerSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGSize arg0; 

	ok &= jsval_to_CGSize( cx, *argvp++, (CGSize*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setLayerSize:(CGSize)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setMaxGID_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setMaxGID:(unsigned int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: unsigned int
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setMinGID_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setMinGID:(unsigned int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setOffset_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setOffset:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: unsigned char
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setOpacity:(unsigned char)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setOwnTiles_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setOwnTiles:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCTMXLayerInfo_setVisible_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	[real setVisible:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCTMXLayerInfo_visible(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCTMXLayerInfo *real = (CCTMXLayerInfo*) [proxy realObj];
	ret_val = [real visible ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSPROXY_CCTMXLayerInfo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTMXLayerInfo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTMXLayerInfo_class->name = name;
	JSPROXY_CCTMXLayerInfo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTMXLayerInfo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTMXLayerInfo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTMXLayerInfo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTMXLayerInfo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTMXLayerInfo_class->resolve = JS_ResolveStub;
	JSPROXY_CCTMXLayerInfo_class->convert = JS_ConvertStub;
	JSPROXY_CCTMXLayerInfo_class->finalize = JSPROXY_CCTMXLayerInfo_finalize;
//	JSPROXY_CCTMXLayerInfo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getLayerSize", JSPROXY_CCTMXLayerInfo_layerSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMaxGID", JSPROXY_CCTMXLayerInfo_maxGID, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMinGID", JSPROXY_CCTMXLayerInfo_minGID, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getName", JSPROXY_CCTMXLayerInfo_name, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOffset", JSPROXY_CCTMXLayerInfo_offset, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSPROXY_CCTMXLayerInfo_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOwnTiles", JSPROXY_CCTMXLayerInfo_ownTiles, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLayerSize", JSPROXY_CCTMXLayerInfo_setLayerSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMaxGID", JSPROXY_CCTMXLayerInfo_setMaxGID_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMinGID", JSPROXY_CCTMXLayerInfo_setMinGID_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setName", JSPROXY_CCTMXLayerInfo_setName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOffset", JSPROXY_CCTMXLayerInfo_setOffset_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCTMXLayerInfo_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOwnTiles", JSPROXY_CCTMXLayerInfo_setOwnTiles_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setVisible", JSPROXY_CCTMXLayerInfo_setVisible_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getVisible", JSPROXY_CCTMXLayerInfo_visible, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCTMXLayerInfo_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTMXLayerInfo_class, JSPROXY_CCTMXLayerInfo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTMXLayerInfo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTMXLayerInfo_class, JSPROXY_CCTMXLayerInfo_object, NULL);
	JSPROXY_CCTMXLayerInfo *proxy = [[JSPROXY_CCTMXLayerInfo alloc] initWithJSObject:jsobj class:[CCTMXLayerInfo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionZoomFlipY
 */
#pragma mark - CCTransitionZoomFlipY

JSClass* JSPROXY_CCTransitionZoomFlipY_class = NULL;
JSObject* JSPROXY_CCTransitionZoomFlipY_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionZoomFlipY_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionZoomFlipY createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionZoomFlipY_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionZoomFlipY)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionZoomFlipY_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionZoomFlipY *real = [(CCTransitionZoomFlipY*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionZoomFlipY* (o)
JSBool JSPROXY_CCTransitionZoomFlipY_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTransitionZoomFlipY* ret_val;

	ret_val = [CCTransitionZoomFlipY transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionZoomFlipY* (o)
JSBool JSPROXY_CCTransitionZoomFlipY_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionZoomFlipY* ret_val;

	ret_val = [CCTransitionZoomFlipY transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionZoomFlipY* (o)
JSBool JSPROXY_CCTransitionZoomFlipY_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionZoomFlipY* ret_val;

	ret_val = [CCTransitionZoomFlipY node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionZoomFlipY_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionZoomFlipY_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionZoomFlipY_class->name = name;
	JSPROXY_CCTransitionZoomFlipY_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipY_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipY_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipY_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionZoomFlipY_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionZoomFlipY_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionZoomFlipY_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionZoomFlipY_class->finalize = JSPROXY_CCTransitionZoomFlipY_finalize;
//	JSPROXY_CCTransitionZoomFlipY_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionZoomFlipY_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSPROXY_CCTransitionZoomFlipY_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTransitionZoomFlipY_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionZoomFlipY_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionZoomFlipY_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSceneOriented_object, JSPROXY_CCTransitionZoomFlipY_class, JSPROXY_CCTransitionZoomFlipY_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionZoomFlipY

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionZoomFlipY_class, JSPROXY_CCTransitionZoomFlipY_object, NULL);
	JSPROXY_CCTransitionZoomFlipY *proxy = [[JSPROXY_CCTransitionZoomFlipY alloc] initWithJSObject:jsobj class:[CCTransitionZoomFlipY class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCReuseGrid
 */
#pragma mark - CCReuseGrid

JSClass* JSPROXY_CCReuseGrid_class = NULL;
JSObject* JSPROXY_CCReuseGrid_object = NULL;
 // Constructor
JSBool JSPROXY_CCReuseGrid_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCReuseGrid createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCReuseGrid_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCReuseGrid)", obj);
}

// Arguments: int
// Ret value: CCReuseGrid* (o)
JSBool JSPROXY_CCReuseGrid_actionWithTimes__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCReuseGrid* ret_val;

	ret_val = [CCReuseGrid actionWithTimes:(int)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int
// Ret value: None (None)
JSBool JSPROXY_CCReuseGrid_initWithTimes_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCReuseGrid *real = [(CCReuseGrid*)[proxy.klass alloc] initWithTimes:(int)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCReuseGrid* (o)
JSBool JSPROXY_CCReuseGrid_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCReuseGrid* ret_val;

	ret_val = [CCReuseGrid action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCReuseGrid_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCReuseGrid_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCReuseGrid_class->name = name;
	JSPROXY_CCReuseGrid_class->addProperty = JS_PropertyStub;
	JSPROXY_CCReuseGrid_class->delProperty = JS_PropertyStub;
	JSPROXY_CCReuseGrid_class->getProperty = JS_PropertyStub;
	JSPROXY_CCReuseGrid_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCReuseGrid_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCReuseGrid_class->resolve = JS_ResolveStub;
	JSPROXY_CCReuseGrid_class->convert = JS_ConvertStub;
	JSPROXY_CCReuseGrid_class->finalize = JSPROXY_CCReuseGrid_finalize;
//	JSPROXY_CCReuseGrid_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithTimes", JSPROXY_CCReuseGrid_initWithTimes_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithTimes", JSPROXY_CCReuseGrid_actionWithTimes__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCReuseGrid_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCReuseGrid_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCReuseGrid_class, JSPROXY_CCReuseGrid_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCReuseGrid

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCReuseGrid_class, JSPROXY_CCReuseGrid_object, NULL);
	JSPROXY_CCReuseGrid *proxy = [[JSPROXY_CCReuseGrid alloc] initWithJSObject:jsobj class:[CCReuseGrid class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShuffleTiles
 */
#pragma mark - CCShuffleTiles

JSClass* JSPROXY_CCShuffleTiles_class = NULL;
JSObject* JSPROXY_CCShuffleTiles_object = NULL;
 // Constructor
JSBool JSPROXY_CCShuffleTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCShuffleTiles createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCShuffleTiles_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCShuffleTiles)", obj);
}

// Arguments: int, ccGridSize, ccTime
// Ret value: CCShuffleTiles* (o)
JSBool JSPROXY_CCShuffleTiles_actionWithSeed_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; ccGridSize arg1; double arg2; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCShuffleTiles* ret_val;

	ret_val = [CCShuffleTiles actionWithSeed:(int)arg0 grid:(ccGridSize)arg1 duration:(ccTime)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCShuffleTiles_initWithSeed_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; ccGridSize arg1; double arg2; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCShuffleTiles *real = [(CCShuffleTiles*)[proxy.klass alloc] initWithSeed:(int)arg0 grid:(ccGridSize)arg1 duration:(ccTime)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCShuffleTiles* (o)
JSBool JSPROXY_CCShuffleTiles_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCShuffleTiles* ret_val;

	ret_val = [CCShuffleTiles actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCShuffleTiles* (o)
JSBool JSPROXY_CCShuffleTiles_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCShuffleTiles* ret_val;

	ret_val = [CCShuffleTiles actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShuffleTiles* (o)
JSBool JSPROXY_CCShuffleTiles_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCShuffleTiles* ret_val;

	ret_val = [CCShuffleTiles action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCShuffleTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCShuffleTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCShuffleTiles_class->name = name;
	JSPROXY_CCShuffleTiles_class->addProperty = JS_PropertyStub;
	JSPROXY_CCShuffleTiles_class->delProperty = JS_PropertyStub;
	JSPROXY_CCShuffleTiles_class->getProperty = JS_PropertyStub;
	JSPROXY_CCShuffleTiles_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCShuffleTiles_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCShuffleTiles_class->resolve = JS_ResolveStub;
	JSPROXY_CCShuffleTiles_class->convert = JS_ConvertStub;
	JSPROXY_CCShuffleTiles_class->finalize = JSPROXY_CCShuffleTiles_finalize;
//	JSPROXY_CCShuffleTiles_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithSeedGridDuration", JSPROXY_CCShuffleTiles_initWithSeed_grid_duration_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithSeedGridDuration", JSPROXY_CCShuffleTiles_actionWithSeed_grid_duration__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCShuffleTiles_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCShuffleTiles_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCShuffleTiles_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCShuffleTiles_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCShuffleTiles_class, JSPROXY_CCShuffleTiles_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCShuffleTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCShuffleTiles_class, JSPROXY_CCShuffleTiles_object, NULL);
	JSPROXY_CCShuffleTiles *proxy = [[JSPROXY_CCShuffleTiles alloc] initWithJSObject:jsobj class:[CCShuffleTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCConfiguration
 */
#pragma mark - CCConfiguration

JSClass* JSPROXY_CCConfiguration_class = NULL;
JSObject* JSPROXY_CCConfiguration_object = NULL;
 // Constructor
JSBool JSPROXY_CCConfiguration_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCConfiguration createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCConfiguration_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCConfiguration)", obj);
}

// Arguments: 
// Ret value: unsigned int (u)
JSBool JSPROXY_CCConfiguration_OSVersion(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	unsigned int ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real OSVersion ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: BOOL (b)
JSBool JSPROXY_CCConfiguration_checkForGLExtension_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real checkForGLExtension:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLint (i)
JSBool JSPROXY_CCConfiguration_maxModelviewStackDepth(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLint ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real maxModelviewStackDepth ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLint (i)
JSBool JSPROXY_CCConfiguration_maxTextureSize(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLint ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real maxTextureSize ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLint (i)
JSBool JSPROXY_CCConfiguration_maxTextureUnits(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLint ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real maxTextureUnits ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCConfiguration* (o)
JSBool JSPROXY_CCConfiguration_sharedConfiguration_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCConfiguration* ret_val;

	ret_val = [CCConfiguration sharedConfiguration ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCConfiguration_supportsBGRA8888(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsBGRA8888 ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCConfiguration_supportsDiscardFramebuffer(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsDiscardFramebuffer ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCConfiguration_supportsNPOT(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsNPOT ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCConfiguration_supportsPVRTC(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsPVRTC ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCConfiguration_supportsShareableVAO(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCConfiguration *real = (CCConfiguration*) [proxy realObj];
	ret_val = [real supportsShareableVAO ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSPROXY_CCConfiguration_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCConfiguration_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCConfiguration_class->name = name;
	JSPROXY_CCConfiguration_class->addProperty = JS_PropertyStub;
	JSPROXY_CCConfiguration_class->delProperty = JS_PropertyStub;
	JSPROXY_CCConfiguration_class->getProperty = JS_PropertyStub;
	JSPROXY_CCConfiguration_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCConfiguration_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCConfiguration_class->resolve = JS_ResolveStub;
	JSPROXY_CCConfiguration_class->convert = JS_ConvertStub;
	JSPROXY_CCConfiguration_class->finalize = JSPROXY_CCConfiguration_finalize;
//	JSPROXY_CCConfiguration_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getOSVersion", JSPROXY_CCConfiguration_OSVersion, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("checkForGLExtension", JSPROXY_CCConfiguration_checkForGLExtension_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMaxModelviewStackDepth", JSPROXY_CCConfiguration_maxModelviewStackDepth, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMaxTextureSize", JSPROXY_CCConfiguration_maxTextureSize, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMaxTextureUnits", JSPROXY_CCConfiguration_maxTextureUnits, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSupportsBGRA8888", JSPROXY_CCConfiguration_supportsBGRA8888, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSupportsDiscardFramebuffer", JSPROXY_CCConfiguration_supportsDiscardFramebuffer, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSupportsNPOT", JSPROXY_CCConfiguration_supportsNPOT, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSupportsPVRTC", JSPROXY_CCConfiguration_supportsPVRTC, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSupportsShareableVAO", JSPROXY_CCConfiguration_supportsShareableVAO, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("sharedConfiguration", JSPROXY_CCConfiguration_sharedConfiguration_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCConfiguration_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCConfiguration_class, JSPROXY_CCConfiguration_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCConfiguration

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCConfiguration_class, JSPROXY_CCConfiguration_object, NULL);
	JSPROXY_CCConfiguration *proxy = [[JSPROXY_CCConfiguration alloc] initWithJSObject:jsobj class:[CCConfiguration class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseSineIn
 */
#pragma mark - CCEaseSineIn

JSClass* JSPROXY_CCEaseSineIn_class = NULL;
JSObject* JSPROXY_CCEaseSineIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseSineIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseSineIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseSineIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseSineIn)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseSineIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseSineIn *real = (CCEaseSineIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseSineIn* (o)
JSBool JSPROXY_CCEaseSineIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseSineIn* ret_val;

	ret_val = [CCEaseSineIn actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseSineIn* (o)
JSBool JSPROXY_CCEaseSineIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseSineIn* ret_val;

	ret_val = [CCEaseSineIn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseSineIn* (o)
JSBool JSPROXY_CCEaseSineIn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseSineIn* ret_val;

	ret_val = [CCEaseSineIn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseSineIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseSineIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseSineIn_class->name = name;
	JSPROXY_CCEaseSineIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseSineIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseSineIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseSineIn_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseSineIn_class->finalize = JSPROXY_CCEaseSineIn_finalize;
//	JSPROXY_CCEaseSineIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseSineIn_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseSineIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseSineIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseSineIn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseSineIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseSineIn_class, JSPROXY_CCEaseSineIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseSineIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseSineIn_class, JSPROXY_CCEaseSineIn_object, NULL);
	JSPROXY_CCEaseSineIn *proxy = [[JSPROXY_CCEaseSineIn alloc] initWithJSObject:jsobj class:[CCEaseSineIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeBL
 */
#pragma mark - CCTransitionFadeBL

JSClass* JSPROXY_CCTransitionFadeBL_class = NULL;
JSObject* JSPROXY_CCTransitionFadeBL_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFadeBL_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFadeBL createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFadeBL_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFadeBL)", obj);
}

// Arguments: ccGridSize
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionFadeBL_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionFadeBL *real = (CCTransitionFadeBL*) [proxy realObj];
	ret_val = [real actionWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeBL* (o)
JSBool JSPROXY_CCTransitionFadeBL_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionFadeBL* ret_val;

	ret_val = [CCTransitionFadeBL transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeBL* (o)
JSBool JSPROXY_CCTransitionFadeBL_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFadeBL* ret_val;

	ret_val = [CCTransitionFadeBL node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFadeBL_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFadeBL_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFadeBL_class->name = name;
	JSPROXY_CCTransitionFadeBL_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeBL_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeBL_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeBL_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFadeBL_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFadeBL_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFadeBL_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFadeBL_class->finalize = JSPROXY_CCTransitionFadeBL_finalize;
//	JSPROXY_CCTransitionFadeBL_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSPROXY_CCTransitionFadeBL_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionFadeBL_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFadeBL_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFadeBL_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionFadeTR_object, JSPROXY_CCTransitionFadeBL_class, JSPROXY_CCTransitionFadeBL_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFadeBL

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFadeBL_class, JSPROXY_CCTransitionFadeBL_object, NULL);
	JSPROXY_CCTransitionFadeBL *proxy = [[JSPROXY_CCTransitionFadeBL alloc] initWithJSObject:jsobj class:[CCTransitionFadeBL class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimate
 */
#pragma mark - CCAnimate

JSClass* JSPROXY_CCAnimate_class = NULL;
JSObject* JSPROXY_CCAnimate_object = NULL;
 // Constructor
JSBool JSPROXY_CCAnimate_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAnimate createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAnimate_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAnimate)", obj);
}

// Arguments: CCAnimation*
// Ret value: CCAnimate* (o)
JSBool JSPROXY_CCAnimate_actionWithAnimation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCAnimate* ret_val;

	ret_val = [CCAnimate actionWithAnimation:(CCAnimation*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAnimation* (o)
JSBool JSPROXY_CCAnimate_animation(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCAnimation* ret_val;

	CCAnimate *real = (CCAnimate*) [proxy realObj];
	ret_val = [real animation ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCAnimation*
// Ret value: None (None)
JSBool JSPROXY_CCAnimate_initWithAnimation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCAnimate *real = [(CCAnimate*)[proxy.klass alloc] initWithAnimation:(CCAnimation*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCAnimation*
// Ret value: void (None)
JSBool JSPROXY_CCAnimate_setAnimation_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCAnimate *real = (CCAnimate*) [proxy realObj];
	[real setAnimation:(CCAnimation*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCAnimate* (o)
JSBool JSPROXY_CCAnimate_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCAnimate* ret_val;

	ret_val = [CCAnimate actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCAnimate* (o)
JSBool JSPROXY_CCAnimate_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCAnimate* ret_val;

	ret_val = [CCAnimate action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCAnimate_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAnimate_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAnimate_class->name = name;
	JSPROXY_CCAnimate_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAnimate_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAnimate_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAnimate_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAnimate_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAnimate_class->resolve = JS_ResolveStub;
	JSPROXY_CCAnimate_class->convert = JS_ConvertStub;
	JSPROXY_CCAnimate_class->finalize = JSPROXY_CCAnimate_finalize;
//	JSPROXY_CCAnimate_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAnimation", JSPROXY_CCAnimate_animation, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithAnimation", JSPROXY_CCAnimate_initWithAnimation_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAnimation", JSPROXY_CCAnimate_setAnimation_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCAnimate_actionWithAnimation__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCAnimate_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCAnimate_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCAnimate_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCAnimate_class, JSPROXY_CCAnimate_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAnimate

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAnimate_class, JSPROXY_CCAnimate_object, NULL);
	JSPROXY_CCAnimate *proxy = [[JSPROXY_CCAnimate alloc] initWithJSObject:jsobj class:[CCAnimate class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCCallBlockN
 */
#pragma mark - CCCallBlockN

JSClass* JSPROXY_CCCallBlockN_class = NULL;
JSObject* JSPROXY_CCCallBlockN_object = NULL;
 // Constructor
JSBool JSPROXY_CCCallBlockN_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCCallBlockN createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCCallBlockN_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCCallBlockN)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCCallBlockN_execute(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCCallBlockN *real = (CCCallBlockN*) [proxy realObj];
	[real execute ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: void (^)(CCNode *)
// Ret value: None (None)
JSBool JSPROXY_CCCallBlockN_initWithBlock_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	js_block arg0; 

	ok &= jsval_to_block_1( cx, *argvp++, JS_THIS_OBJECT(cx, vp), &arg0 );
	if( ! ok ) return JS_FALSE;

	CCCallBlockN *real = [(CCCallBlockN*)[proxy.klass alloc] initWithBlock:(void (^)(CCNode *))arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCCallBlockN* (o)
JSBool JSPROXY_CCCallBlockN_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCCallBlockN* ret_val;

	ret_val = [CCCallBlockN action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCCallBlockN_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCCallBlockN_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCCallBlockN_class->name = name;
	JSPROXY_CCCallBlockN_class->addProperty = JS_PropertyStub;
	JSPROXY_CCCallBlockN_class->delProperty = JS_PropertyStub;
	JSPROXY_CCCallBlockN_class->getProperty = JS_PropertyStub;
	JSPROXY_CCCallBlockN_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCCallBlockN_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCCallBlockN_class->resolve = JS_ResolveStub;
	JSPROXY_CCCallBlockN_class->convert = JS_ConvertStub;
	JSPROXY_CCCallBlockN_class->finalize = JSPROXY_CCCallBlockN_finalize;
//	JSPROXY_CCCallBlockN_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("execute", JSPROXY_CCCallBlockN_execute, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithBlock", JSPROXY_CCCallBlockN_initWithBlock_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCCallBlockN_actionWithBlock__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCCallBlockN_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCCallBlockN_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInstant_object, JSPROXY_CCCallBlockN_class, JSPROXY_CCCallBlockN_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCCallBlockN

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCCallBlockN_class, JSPROXY_CCCallBlockN_object, NULL);
	JSPROXY_CCCallBlockN *proxy = [[JSPROXY_CCCallBlockN alloc] initWithJSObject:jsobj class:[CCCallBlockN class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBezierBy
 */
#pragma mark - CCBezierBy

JSClass* JSPROXY_CCBezierBy_class = NULL;
JSObject* JSPROXY_CCBezierBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCBezierBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCBezierBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCBezierBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCBezierBy)", obj);
}

// Arguments: ccTime
// Ret value: CCBezierBy* (o)
JSBool JSPROXY_CCBezierBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCBezierBy* ret_val;

	ret_val = [CCBezierBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCBezierBy* (o)
JSBool JSPROXY_CCBezierBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCBezierBy* ret_val;

	ret_val = [CCBezierBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCBezierBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCBezierBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCBezierBy_class->name = name;
	JSPROXY_CCBezierBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCBezierBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCBezierBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCBezierBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCBezierBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCBezierBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCBezierBy_class->convert = JS_ConvertStub;
	JSPROXY_CCBezierBy_class->finalize = JSPROXY_CCBezierBy_finalize;
//	JSPROXY_CCBezierBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDuration", JSPROXY_CCBezierBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCBezierBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCBezierBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCBezierBy_class, JSPROXY_CCBezierBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCBezierBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCBezierBy_class, JSPROXY_CCBezierBy_object, NULL);
	JSPROXY_CCBezierBy *proxy = [[JSPROXY_CCBezierBy alloc] initWithJSObject:jsobj class:[CCBezierBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCAnimation
 */
#pragma mark - CCAnimation

JSClass* JSPROXY_CCAnimation_class = NULL;
JSObject* JSPROXY_CCAnimation_object = NULL;
 // Constructor
JSBool JSPROXY_CCAnimation_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCAnimation createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCAnimation_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCAnimation)", obj);
}

// Arguments: CCSpriteFrame*
// Ret value: void (None)
JSBool JSPROXY_CCAnimation_addSpriteFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real addSpriteFrame:(CCSpriteFrame*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCAnimation_addSpriteFrameWithFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real addSpriteFrameWithFilename:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, CGRect
// Ret value: void (None)
JSBool JSPROXY_CCAnimation_addSpriteFrameWithTexture_rect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; CGRect arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_CGRect( cx, *argvp++, (CGRect*) &arg1 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real addSpriteFrameWithTexture:(CCTexture2D*)arg0 rect:(CGRect)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSArray*, float, NSUInteger
// Ret value: CCAnimation* (o)
JSBool JSPROXY_CCAnimation_animationWithAnimationFrames_delayPerUnit_loops__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 0 && argc <= 3 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; double arg1; uint32_t arg2; 

	if (argc >= 1) {
		ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	}
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if (argc >= 3) {
		ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	}
	if( ! ok ) return JS_FALSE;
	CCAnimation* ret_val;

	if( argc == 0 ) {
		ret_val = [CCAnimation animation ];
	}
	else if( argc == 1 ) {
		ret_val = [CCAnimation animationWithSpriteFrames:(NSArray*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCAnimation animationWithSpriteFrames:(NSArray*)arg0 delay:(float)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCAnimation animationWithAnimationFrames:(NSArray*)arg0 delayPerUnit:(float)arg1 loops:(NSUInteger)arg2  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCAnimation_delayPerUnit(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real delayPerUnit ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCAnimation_duration(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real duration ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCAnimation_frames(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real frames ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: NSArray*, float, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCAnimation_initWithAnimationFrames_delayPerUnit_loops_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; double arg1; uint32_t arg2; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = [(CCAnimation*)[proxy.klass alloc] initWithAnimationFrames:(NSArray*)arg0 delayPerUnit:(float)arg1 loops:(NSUInteger)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: None (None)
JSBool JSPROXY_CCAnimation_initWithSpriteFrames_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = [(CCAnimation*)[proxy.klass alloc] initWithSpriteFrames:(NSArray*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSArray*, float
// Ret value: None (None)
JSBool JSPROXY_CCAnimation_initWithSpriteFrames_delay_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; double arg1; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = [(CCAnimation*)[proxy.klass alloc] initWithSpriteFrames:(NSArray*)arg0 delay:(float)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCAnimation_loops(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real loops ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCAnimation_restoreOriginalFrame(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real restoreOriginalFrame ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCAnimation_setDelayPerUnit_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setDelayPerUnit:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCAnimation_setFrames_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setFrames:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCAnimation_setLoops_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setLoops:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCAnimation_setRestoreOriginalFrame_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	[real setRestoreOriginalFrame:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCAnimation_totalDelayUnits(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCAnimation *real = (CCAnimation*) [proxy realObj];
	ret_val = [real totalDelayUnits ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSPROXY_CCAnimation_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCAnimation_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCAnimation_class->name = name;
	JSPROXY_CCAnimation_class->addProperty = JS_PropertyStub;
	JSPROXY_CCAnimation_class->delProperty = JS_PropertyStub;
	JSPROXY_CCAnimation_class->getProperty = JS_PropertyStub;
	JSPROXY_CCAnimation_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCAnimation_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCAnimation_class->resolve = JS_ResolveStub;
	JSPROXY_CCAnimation_class->convert = JS_ConvertStub;
	JSPROXY_CCAnimation_class->finalize = JSPROXY_CCAnimation_finalize;
//	JSPROXY_CCAnimation_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addSpriteFrame", JSPROXY_CCAnimation_addSpriteFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("addSpriteFrameWithFilename", JSPROXY_CCAnimation_addSpriteFrameWithFilename_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("addSpriteFrameWithTextureRect", JSPROXY_CCAnimation_addSpriteFrameWithTexture_rect_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getDelayPerUnit", JSPROXY_CCAnimation_delayPerUnit, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getDuration", JSPROXY_CCAnimation_duration, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getFrames", JSPROXY_CCAnimation_frames, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithAnimationFramesDelayPerUnitLoops", JSPROXY_CCAnimation_initWithAnimationFrames_delayPerUnit_loops_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFrames", JSPROXY_CCAnimation_initWithSpriteFrames_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSpriteFramesDelay", JSPROXY_CCAnimation_initWithSpriteFrames_delay_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLoops", JSPROXY_CCAnimation_loops, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRestoreOriginalFrame", JSPROXY_CCAnimation_restoreOriginalFrame, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setDelayPerUnit", JSPROXY_CCAnimation_setDelayPerUnit_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setFrames", JSPROXY_CCAnimation_setFrames_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLoops", JSPROXY_CCAnimation_setLoops_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRestoreOriginalFrame", JSPROXY_CCAnimation_setRestoreOriginalFrame_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTotalDelayUnits", JSPROXY_CCAnimation_totalDelayUnits, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCAnimation_animationWithAnimationFrames_delayPerUnit_loops__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCAnimation_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCAnimation_class, JSPROXY_CCAnimation_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCAnimation

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCAnimation_class, JSPROXY_CCAnimation_object, NULL);
	JSPROXY_CCAnimation *proxy = [[JSPROXY_CCAnimation alloc] initWithJSObject:jsobj class:[CCAnimation class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseSineInOut
 */
#pragma mark - CCEaseSineInOut

JSClass* JSPROXY_CCEaseSineInOut_class = NULL;
JSObject* JSPROXY_CCEaseSineInOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseSineInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseSineInOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseSineInOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseSineInOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseSineInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseSineInOut *real = (CCEaseSineInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseSineInOut* (o)
JSBool JSPROXY_CCEaseSineInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseSineInOut* ret_val;

	ret_val = [CCEaseSineInOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseSineInOut* (o)
JSBool JSPROXY_CCEaseSineInOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseSineInOut* ret_val;

	ret_val = [CCEaseSineInOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseSineInOut* (o)
JSBool JSPROXY_CCEaseSineInOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseSineInOut* ret_val;

	ret_val = [CCEaseSineInOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseSineInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseSineInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseSineInOut_class->name = name;
	JSPROXY_CCEaseSineInOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineInOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineInOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineInOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseSineInOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseSineInOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseSineInOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseSineInOut_class->finalize = JSPROXY_CCEaseSineInOut_finalize;
//	JSPROXY_CCEaseSineInOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseSineInOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseSineInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseSineInOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseSineInOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseSineInOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseSineInOut_class, JSPROXY_CCEaseSineInOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseSineInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseSineInOut_class, JSPROXY_CCEaseSineInOut_object, NULL);
	JSPROXY_CCEaseSineInOut *proxy = [[JSPROXY_CCEaseSineInOut alloc] initWithJSObject:jsobj class:[CCEaseSineInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCShaky3D
 */
#pragma mark - CCShaky3D

JSClass* JSPROXY_CCShaky3D_class = NULL;
JSObject* JSPROXY_CCShaky3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCShaky3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCShaky3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCShaky3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCShaky3D)", obj);
}

// Arguments: int, BOOL, ccGridSize, ccTime
// Ret value: CCShaky3D* (o)
JSBool JSPROXY_CCShaky3D_actionWithRange_shakeZ_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCShaky3D* ret_val;

	ret_val = [CCShaky3D actionWithRange:(int)arg0 shakeZ:(BOOL)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int, BOOL, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCShaky3D_initWithRange_shakeZ_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; JSBool arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCShaky3D *real = [(CCShaky3D*)[proxy.klass alloc] initWithRange:(int)arg0 shakeZ:(BOOL)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCShaky3D* (o)
JSBool JSPROXY_CCShaky3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCShaky3D* ret_val;

	ret_val = [CCShaky3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCShaky3D* (o)
JSBool JSPROXY_CCShaky3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCShaky3D* ret_val;

	ret_val = [CCShaky3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCShaky3D* (o)
JSBool JSPROXY_CCShaky3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCShaky3D* ret_val;

	ret_val = [CCShaky3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCShaky3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCShaky3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCShaky3D_class->name = name;
	JSPROXY_CCShaky3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCShaky3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCShaky3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCShaky3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCShaky3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCShaky3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCShaky3D_class->convert = JS_ConvertStub;
	JSPROXY_CCShaky3D_class->finalize = JSPROXY_CCShaky3D_finalize;
//	JSPROXY_CCShaky3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithRangeShakeZGridDuration", JSPROXY_CCShaky3D_initWithRange_shakeZ_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCShaky3D_actionWithRange_shakeZ_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCShaky3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCShaky3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCShaky3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCShaky3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCShaky3D_class, JSPROXY_CCShaky3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCShaky3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCShaky3D_class, JSPROXY_CCShaky3D_object, NULL);
	JSPROXY_CCShaky3D *proxy = [[JSPROXY_CCShaky3D alloc] initWithJSObject:jsobj class:[CCShaky3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressRadialCW
 */
#pragma mark - CCTransitionProgressRadialCW

JSClass* JSPROXY_CCTransitionProgressRadialCW_class = NULL;
JSObject* JSPROXY_CCTransitionProgressRadialCW_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionProgressRadialCW_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionProgressRadialCW createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionProgressRadialCW_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionProgressRadialCW)", obj);
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCTransitionProgressRadialCW_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	CCTransitionProgressRadialCW *real = (CCTransitionProgressRadialCW*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:(CCRenderTexture*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressRadialCW* (o)
JSBool JSPROXY_CCTransitionProgressRadialCW_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionProgressRadialCW* ret_val;

	ret_val = [CCTransitionProgressRadialCW transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressRadialCW* (o)
JSBool JSPROXY_CCTransitionProgressRadialCW_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionProgressRadialCW* ret_val;

	ret_val = [CCTransitionProgressRadialCW node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionProgressRadialCW_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionProgressRadialCW_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionProgressRadialCW_class->name = name;
	JSPROXY_CCTransitionProgressRadialCW_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressRadialCW_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressRadialCW_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressRadialCW_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionProgressRadialCW_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionProgressRadialCW_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionProgressRadialCW_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionProgressRadialCW_class->finalize = JSPROXY_CCTransitionProgressRadialCW_finalize;
//	JSPROXY_CCTransitionProgressRadialCW_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSPROXY_CCTransitionProgressRadialCW_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionProgressRadialCW_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionProgressRadialCW_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionProgressRadialCW_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionProgress_object, JSPROXY_CCTransitionProgressRadialCW_class, JSPROXY_CCTransitionProgressRadialCW_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionProgressRadialCW

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionProgressRadialCW_class, JSPROXY_CCTransitionProgressRadialCW_object, NULL);
	JSPROXY_CCTransitionProgressRadialCW *proxy = [[JSPROXY_CCTransitionProgressRadialCW alloc] initWithJSObject:jsobj class:[CCTransitionProgressRadialCW class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTintTo
 */
#pragma mark - CCTintTo

JSClass* JSPROXY_CCTintTo_class = NULL;
JSObject* JSPROXY_CCTintTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCTintTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTintTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTintTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTintTo)", obj);
}

// Arguments: ccTime, GLubyte, GLubyte, GLubyte
// Ret value: CCTintTo* (o)
JSBool JSPROXY_CCTintTo_actionWithDuration_red_green_blue__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg1 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg2 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCTintTo* ret_val;

	ret_val = [CCTintTo actionWithDuration:(ccTime)arg0 red:(GLubyte)arg1 green:(GLubyte)arg2 blue:(GLubyte)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, GLubyte, GLubyte, GLubyte
// Ret value: None (None)
JSBool JSPROXY_CCTintTo_initWithDuration_red_green_blue_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg1 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg2 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCTintTo *real = [(CCTintTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 red:(GLubyte)arg1 green:(GLubyte)arg2 blue:(GLubyte)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCTintTo* (o)
JSBool JSPROXY_CCTintTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTintTo* ret_val;

	ret_val = [CCTintTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTintTo* (o)
JSBool JSPROXY_CCTintTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTintTo* ret_val;

	ret_val = [CCTintTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTintTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTintTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTintTo_class->name = name;
	JSPROXY_CCTintTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTintTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTintTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTintTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTintTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTintTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCTintTo_class->convert = JS_ConvertStub;
	JSPROXY_CCTintTo_class->finalize = JSPROXY_CCTintTo_finalize;
//	JSPROXY_CCTintTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationRedGreenBlue", JSPROXY_CCTintTo_initWithDuration_red_green_blue_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTintTo_actionWithDuration_red_green_blue__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCTintTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCTintTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTintTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCTintTo_class, JSPROXY_CCTintTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTintTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTintTo_class, JSPROXY_CCTintTo_object, NULL);
	JSPROXY_CCTintTo *proxy = [[JSPROXY_CCTintTo alloc] initWithJSObject:jsobj class:[CCTintTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionTurnOffTiles
 */
#pragma mark - CCTransitionTurnOffTiles

JSClass* JSPROXY_CCTransitionTurnOffTiles_class = NULL;
JSObject* JSPROXY_CCTransitionTurnOffTiles_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionTurnOffTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionTurnOffTiles createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionTurnOffTiles_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionTurnOffTiles)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionTurnOffTiles_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionTurnOffTiles *real = [(CCTransitionTurnOffTiles*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionTurnOffTiles_easeActionWithAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionTurnOffTiles *real = (CCTransitionTurnOffTiles*) [proxy realObj];
	ret_val = [real easeActionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionTurnOffTiles* (o)
JSBool JSPROXY_CCTransitionTurnOffTiles_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionTurnOffTiles* ret_val;

	ret_val = [CCTransitionTurnOffTiles transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionTurnOffTiles* (o)
JSBool JSPROXY_CCTransitionTurnOffTiles_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionTurnOffTiles* ret_val;

	ret_val = [CCTransitionTurnOffTiles node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionTurnOffTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionTurnOffTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionTurnOffTiles_class->name = name;
	JSPROXY_CCTransitionTurnOffTiles_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionTurnOffTiles_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionTurnOffTiles_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionTurnOffTiles_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionTurnOffTiles_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionTurnOffTiles_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionTurnOffTiles_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionTurnOffTiles_class->finalize = JSPROXY_CCTransitionTurnOffTiles_finalize;
//	JSPROXY_CCTransitionTurnOffTiles_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionTurnOffTiles_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("easeActionWithAction", JSPROXY_CCTransitionTurnOffTiles_easeActionWithAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionTurnOffTiles_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionTurnOffTiles_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionTurnOffTiles_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionTurnOffTiles_class, JSPROXY_CCTransitionTurnOffTiles_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionTurnOffTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionTurnOffTiles_class, JSPROXY_CCTransitionTurnOffTiles_object, NULL);
	JSPROXY_CCTransitionTurnOffTiles *proxy = [[JSPROXY_CCTransitionTurnOffTiles alloc] initWithJSObject:jsobj class:[CCTransitionTurnOffTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInT
 */
#pragma mark - CCTransitionSlideInT

JSClass* JSPROXY_CCTransitionSlideInT_class = NULL;
JSObject* JSPROXY_CCTransitionSlideInT_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionSlideInT_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionSlideInT createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionSlideInT_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionSlideInT)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionSlideInT_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionSlideInT *real = (CCTransitionSlideInT*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInT* (o)
JSBool JSPROXY_CCTransitionSlideInT_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionSlideInT* ret_val;

	ret_val = [CCTransitionSlideInT transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInT* (o)
JSBool JSPROXY_CCTransitionSlideInT_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionSlideInT* ret_val;

	ret_val = [CCTransitionSlideInT node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionSlideInT_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionSlideInT_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionSlideInT_class->name = name;
	JSPROXY_CCTransitionSlideInT_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInT_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInT_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInT_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionSlideInT_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionSlideInT_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionSlideInT_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionSlideInT_class->finalize = JSPROXY_CCTransitionSlideInT_finalize;
//	JSPROXY_CCTransitionSlideInT_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSPROXY_CCTransitionSlideInT_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionSlideInT_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionSlideInT_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionSlideInT_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSlideInL_object, JSPROXY_CCTransitionSlideInT_class, JSPROXY_CCTransitionSlideInT_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionSlideInT

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionSlideInT_class, JSPROXY_CCTransitionSlideInT_object, NULL);
	JSPROXY_CCTransitionSlideInT *proxy = [[JSPROXY_CCTransitionSlideInT alloc] initWithJSObject:jsobj class:[CCTransitionSlideInT class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBlink
 */
#pragma mark - CCBlink

JSClass* JSPROXY_CCBlink_class = NULL;
JSObject* JSPROXY_CCBlink_object = NULL;
 // Constructor
JSBool JSPROXY_CCBlink_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCBlink createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCBlink_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCBlink)", obj);
}

// Arguments: ccTime, NSUInteger
// Ret value: CCBlink* (o)
JSBool JSPROXY_CCBlink_actionWithDuration_blinks__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCBlink* ret_val;

	ret_val = [CCBlink actionWithDuration:(ccTime)arg0 blinks:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCBlink_initWithDuration_blinks_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint32_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCBlink *real = [(CCBlink*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 blinks:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCBlink* (o)
JSBool JSPROXY_CCBlink_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCBlink* ret_val;

	ret_val = [CCBlink actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCBlink* (o)
JSBool JSPROXY_CCBlink_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCBlink* ret_val;

	ret_val = [CCBlink action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCBlink_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCBlink_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCBlink_class->name = name;
	JSPROXY_CCBlink_class->addProperty = JS_PropertyStub;
	JSPROXY_CCBlink_class->delProperty = JS_PropertyStub;
	JSPROXY_CCBlink_class->getProperty = JS_PropertyStub;
	JSPROXY_CCBlink_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCBlink_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCBlink_class->resolve = JS_ResolveStub;
	JSPROXY_CCBlink_class->convert = JS_ConvertStub;
	JSPROXY_CCBlink_class->finalize = JSPROXY_CCBlink_finalize;
//	JSPROXY_CCBlink_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationBlinks", JSPROXY_CCBlink_initWithDuration_blinks_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCBlink_actionWithDuration_blinks__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCBlink_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCBlink_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCBlink_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCBlink_class, JSPROXY_CCBlink_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCBlink

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCBlink_class, JSPROXY_CCBlink_object, NULL);
	JSPROXY_CCBlink *proxy = [[JSPROXY_CCBlink alloc] initWithJSObject:jsobj class:[CCBlink class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTextureAtlas
 */
#pragma mark - CCTextureAtlas

JSClass* JSPROXY_CCTextureAtlas_class = NULL;
JSObject* JSPROXY_CCTextureAtlas_object = NULL;
 // Constructor
JSBool JSPROXY_CCTextureAtlas_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTextureAtlas createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTextureAtlas_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTextureAtlas)", obj);
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTextureAtlas_capacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real capacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_drawNumberOfQuads_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real drawNumberOfQuads:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_drawNumberOfQuads_fromIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real drawNumberOfQuads:(NSUInteger)arg0 fromIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_drawQuads(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real drawQuads ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_fillWithEmptyQuadsFromIndex_amount_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real fillWithEmptyQuadsFromIndex:(NSUInteger)arg0 amount:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_increaseTotalQuadsWith_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real increaseTotalQuadsWith:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCTextureAtlas_initWithFile_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = [(CCTextureAtlas*)[proxy.klass alloc] initWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCTextureAtlas_initWithTexture_capacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = [(CCTextureAtlas*)[proxy.klass alloc] initWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_insertQuadFromIndex_atIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real insertQuadFromIndex:(NSUInteger)arg0 atIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_moveQuadsFromIndex_amount_atIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; uint32_t arg2; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real moveQuadsFromIndex:(NSUInteger)arg0 amount:(NSUInteger)arg1 atIndex:(NSUInteger)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_moveQuadsFromIndex_to_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real moveQuadsFromIndex:(NSUInteger)arg0 to:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_removeAllQuads(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real removeAllQuads ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_removeQuadAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real removeQuadAtIndex:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_removeQuadsAtIndex_amount_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real removeQuadsAtIndex:(NSUInteger)arg0 amount:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: BOOL (b)
JSBool JSPROXY_CCTextureAtlas_resizeCapacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	BOOL ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real resizeCapacity:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCTextureAtlas_setTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	[real setTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTexture2D* (o)
JSBool JSPROXY_CCTextureAtlas_texture(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2D* ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real texture ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, NSUInteger
// Ret value: CCTextureAtlas* (o)
JSBool JSPROXY_CCTextureAtlas_textureAtlasWithFile_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTextureAtlas* ret_val;

	ret_val = [CCTextureAtlas textureAtlasWithFile:(NSString*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCTexture2D*, NSUInteger
// Ret value: CCTextureAtlas* (o)
JSBool JSPROXY_CCTextureAtlas_textureAtlasWithTexture_capacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; uint32_t arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTextureAtlas* ret_val;

	ret_val = [CCTextureAtlas textureAtlasWithTexture:(CCTexture2D*)arg0 capacity:(NSUInteger)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTextureAtlas_totalQuads(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTextureAtlas *real = (CCTextureAtlas*) [proxy realObj];
	ret_val = [real totalQuads ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSPROXY_CCTextureAtlas_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTextureAtlas_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTextureAtlas_class->name = name;
	JSPROXY_CCTextureAtlas_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTextureAtlas_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTextureAtlas_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTextureAtlas_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTextureAtlas_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTextureAtlas_class->resolve = JS_ResolveStub;
	JSPROXY_CCTextureAtlas_class->convert = JS_ConvertStub;
	JSPROXY_CCTextureAtlas_class->finalize = JSPROXY_CCTextureAtlas_finalize;
//	JSPROXY_CCTextureAtlas_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getCapacity", JSPROXY_CCTextureAtlas_capacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawNumberOfQuads", JSPROXY_CCTextureAtlas_drawNumberOfQuads_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawNumberOfQuadsFromIndex", JSPROXY_CCTextureAtlas_drawNumberOfQuads_fromIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawQuads", JSPROXY_CCTextureAtlas_drawQuads, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("fillWithEmptyQuadsFromIndexAmount", JSPROXY_CCTextureAtlas_fillWithEmptyQuadsFromIndex_amount_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("increaseTotalQuadsWith", JSPROXY_CCTextureAtlas_increaseTotalQuadsWith_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithFileCapacity", JSPROXY_CCTextureAtlas_initWithFile_capacity_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithTextureCapacity", JSPROXY_CCTextureAtlas_initWithTexture_capacity_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("insertQuadFromIndexAtIndex", JSPROXY_CCTextureAtlas_insertQuadFromIndex_atIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("moveQuadsFromIndexAmountAtIndex", JSPROXY_CCTextureAtlas_moveQuadsFromIndex_amount_atIndex_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("moveQuadsFromIndexTo", JSPROXY_CCTextureAtlas_moveQuadsFromIndex_to_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeAllQuads", JSPROXY_CCTextureAtlas_removeAllQuads, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeQuadAtIndex", JSPROXY_CCTextureAtlas_removeQuadAtIndex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeQuadsAtIndexAmount", JSPROXY_CCTextureAtlas_removeQuadsAtIndex_amount_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("resizeCapacity", JSPROXY_CCTextureAtlas_resizeCapacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setTexture", JSPROXY_CCTextureAtlas_setTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTexture", JSPROXY_CCTextureAtlas_texture, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getTotalQuads", JSPROXY_CCTextureAtlas_totalQuads, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("textureAtlasWithFileCapacity", JSPROXY_CCTextureAtlas_textureAtlasWithFile_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("textureAtlasWithTextureCapacity", JSPROXY_CCTextureAtlas_textureAtlasWithTexture_capacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTextureAtlas_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTextureAtlas_class, JSPROXY_CCTextureAtlas_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTextureAtlas

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTextureAtlas_class, JSPROXY_CCTextureAtlas_object, NULL);
	JSPROXY_CCTextureAtlas *proxy = [[JSPROXY_CCTextureAtlas alloc] initWithJSObject:jsobj class:[CCTextureAtlas class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSlideInR
 */
#pragma mark - CCTransitionSlideInR

JSClass* JSPROXY_CCTransitionSlideInR_class = NULL;
JSObject* JSPROXY_CCTransitionSlideInR_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionSlideInR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionSlideInR createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionSlideInR_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionSlideInR)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCTransitionSlideInR_initScenes(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionSlideInR *real = (CCTransitionSlideInR*) [proxy realObj];
	[real initScenes ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSlideInR* (o)
JSBool JSPROXY_CCTransitionSlideInR_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionSlideInR* ret_val;

	ret_val = [CCTransitionSlideInR transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSlideInR* (o)
JSBool JSPROXY_CCTransitionSlideInR_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionSlideInR* ret_val;

	ret_val = [CCTransitionSlideInR node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionSlideInR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionSlideInR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionSlideInR_class->name = name;
	JSPROXY_CCTransitionSlideInR_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInR_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInR_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSlideInR_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionSlideInR_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionSlideInR_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionSlideInR_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionSlideInR_class->finalize = JSPROXY_CCTransitionSlideInR_finalize;
//	JSPROXY_CCTransitionSlideInR_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initScenes", JSPROXY_CCTransitionSlideInR_initScenes, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionSlideInR_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionSlideInR_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionSlideInR_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSlideInL_object, JSPROXY_CCTransitionSlideInR_class, JSPROXY_CCTransitionSlideInR_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionSlideInR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionSlideInR_class, JSPROXY_CCTransitionSlideInR_object, NULL);
	JSPROXY_CCTransitionSlideInR *proxy = [[JSPROXY_CCTransitionSlideInR alloc] initWithJSObject:jsobj class:[CCTransitionSlideInR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCPointArray
 */
#pragma mark - CCPointArray

JSClass* JSPROXY_CCPointArray_class = NULL;
JSObject* JSPROXY_CCPointArray_object = NULL;
 // Constructor
JSBool JSPROXY_CCPointArray_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCPointArray createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCPointArray_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCPointArray)", obj);
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCPointArray_addControlPoint_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	[real addControlPoint:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: CCPointArray* (o)
JSBool JSPROXY_CCPointArray_arrayWithCapacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCPointArray* ret_val;

	ret_val = [CCPointArray arrayWithCapacity:(NSUInteger)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSMutableArray* (array)
JSBool JSPROXY_CCPointArray_controlPoints(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSMutableArray* ret_val;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	ret_val = [real controlPoints ];

	jsval ret_jsval = NSArray_to_jsval( cx, (NSArray*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCPointArray_count(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	ret_val = [real count ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSInteger
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCPointArray_getControlPointAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CGPoint ret_val;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	ret_val = [real getControlPointAtIndex:(NSInteger)arg0  ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: None (None)
JSBool JSPROXY_CCPointArray_initWithCapacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCPointArray *real = [(CCPointArray*)[proxy.klass alloc] initWithCapacity:(NSUInteger)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCPointArray_insertControlPoint_atIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; uint32_t arg1; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	[real insertControlPoint:(CGPoint)arg0 atIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCPointArray_removeControlPointAtIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	[real removeControlPointAtIndex:(NSUInteger)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint, NSUInteger
// Ret value: void (None)
JSBool JSPROXY_CCPointArray_replaceControlPoint_atIndex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; uint32_t arg1; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	[real replaceControlPoint:(CGPoint)arg0 atIndex:(NSUInteger)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCPointArray* (o)
JSBool JSPROXY_CCPointArray_reverse(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCPointArray* ret_val;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	ret_val = [real reverse ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCPointArray_reverseInline(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	[real reverseInline ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSMutableArray*
// Ret value: void (None)
JSBool JSPROXY_CCPointArray_setControlPoints_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsval_to_nsarray( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCPointArray *real = (CCPointArray*) [proxy realObj];
	[real setControlPoints:(NSMutableArray*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCPointArray_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCPointArray_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCPointArray_class->name = name;
	JSPROXY_CCPointArray_class->addProperty = JS_PropertyStub;
	JSPROXY_CCPointArray_class->delProperty = JS_PropertyStub;
	JSPROXY_CCPointArray_class->getProperty = JS_PropertyStub;
	JSPROXY_CCPointArray_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCPointArray_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCPointArray_class->resolve = JS_ResolveStub;
	JSPROXY_CCPointArray_class->convert = JS_ConvertStub;
	JSPROXY_CCPointArray_class->finalize = JSPROXY_CCPointArray_finalize;
//	JSPROXY_CCPointArray_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addControlPoint", JSPROXY_CCPointArray_addControlPoint_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getControlPoints", JSPROXY_CCPointArray_controlPoints, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("count", JSPROXY_CCPointArray_count, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getControlPointAtIndex", JSPROXY_CCPointArray_getControlPointAtIndex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithCapacity", JSPROXY_CCPointArray_initWithCapacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("insertControlPointAtIndex", JSPROXY_CCPointArray_insertControlPoint_atIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeControlPointAtIndex", JSPROXY_CCPointArray_removeControlPointAtIndex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("replaceControlPointAtIndex", JSPROXY_CCPointArray_replaceControlPoint_atIndex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reverse", JSPROXY_CCPointArray_reverse, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("reverseInline", JSPROXY_CCPointArray_reverseInline, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setControlPoints", JSPROXY_CCPointArray_setControlPoints_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCPointArray_arrayWithCapacity__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCPointArray_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCPointArray_class, JSPROXY_CCPointArray_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCPointArray

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCPointArray_class, JSPROXY_CCPointArray_object, NULL);
	JSPROXY_CCPointArray *proxy = [[JSPROXY_CCPointArray alloc] initWithJSObject:jsobj class:[CCPointArray class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressInOut
 */
#pragma mark - CCTransitionProgressInOut

JSClass* JSPROXY_CCTransitionProgressInOut_class = NULL;
JSObject* JSPROXY_CCTransitionProgressInOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionProgressInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionProgressInOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionProgressInOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionProgressInOut)", obj);
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCTransitionProgressInOut_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	CCTransitionProgressInOut *real = (CCTransitionProgressInOut*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:(CCRenderTexture*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressInOut* (o)
JSBool JSPROXY_CCTransitionProgressInOut_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionProgressInOut* ret_val;

	ret_val = [CCTransitionProgressInOut transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressInOut* (o)
JSBool JSPROXY_CCTransitionProgressInOut_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionProgressInOut* ret_val;

	ret_val = [CCTransitionProgressInOut node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionProgressInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionProgressInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionProgressInOut_class->name = name;
	JSPROXY_CCTransitionProgressInOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressInOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressInOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressInOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionProgressInOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionProgressInOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionProgressInOut_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionProgressInOut_class->finalize = JSPROXY_CCTransitionProgressInOut_finalize;
//	JSPROXY_CCTransitionProgressInOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSPROXY_CCTransitionProgressInOut_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionProgressInOut_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionProgressInOut_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionProgressInOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionProgress_object, JSPROXY_CCTransitionProgressInOut_class, JSPROXY_CCTransitionProgressInOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionProgressInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionProgressInOut_class, JSPROXY_CCTransitionProgressInOut_object, NULL);
	JSPROXY_CCTransitionProgressInOut *proxy = [[JSPROXY_CCTransitionProgressInOut alloc] initWithJSObject:jsobj class:[CCTransitionProgressInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounceIn
 */
#pragma mark - CCEaseBounceIn

JSClass* JSPROXY_CCEaseBounceIn_class = NULL;
JSObject* JSPROXY_CCEaseBounceIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseBounceIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseBounceIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseBounceIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseBounceIn)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseBounceIn_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseBounceIn *real = (CCEaseBounceIn*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounceIn* (o)
JSBool JSPROXY_CCEaseBounceIn_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseBounceIn* ret_val;

	ret_val = [CCEaseBounceIn actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseBounceIn* (o)
JSBool JSPROXY_CCEaseBounceIn_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseBounceIn* ret_val;

	ret_val = [CCEaseBounceIn actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseBounceIn* (o)
JSBool JSPROXY_CCEaseBounceIn_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseBounceIn* ret_val;

	ret_val = [CCEaseBounceIn action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseBounceIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseBounceIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseBounceIn_class->name = name;
	JSPROXY_CCEaseBounceIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseBounceIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseBounceIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseBounceIn_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseBounceIn_class->finalize = JSPROXY_CCEaseBounceIn_finalize;
//	JSPROXY_CCEaseBounceIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseBounceIn_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseBounceIn_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseBounceIn_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseBounceIn_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseBounceIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseBounce_object, JSPROXY_CCEaseBounceIn_class, JSPROXY_CCEaseBounceIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseBounceIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseBounceIn_class, JSPROXY_CCEaseBounceIn_object, NULL);
	JSPROXY_CCEaseBounceIn *proxy = [[JSPROXY_CCEaseBounceIn alloc] initWithJSObject:jsobj class:[CCEaseBounceIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLiquid
 */
#pragma mark - CCLiquid

JSClass* JSPROXY_CCLiquid_class = NULL;
JSObject* JSPROXY_CCLiquid_object = NULL;
 // Constructor
JSBool JSPROXY_CCLiquid_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCLiquid createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCLiquid_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCLiquid)", obj);
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: CCLiquid* (o)
JSBool JSPROXY_CCLiquid_actionWithWaves_amplitude_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCLiquid* ret_val;

	ret_val = [CCLiquid actionWithWaves:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCLiquid_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	ret_val = [real amplitude ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCLiquid_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	ret_val = [real amplitudeRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCLiquid_initWithWaves_amplitude_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCLiquid *real = [(CCLiquid*)[proxy.klass alloc] initWithWaves:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCLiquid_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCLiquid_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLiquid *real = (CCLiquid*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCLiquid* (o)
JSBool JSPROXY_CCLiquid_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLiquid* ret_val;

	ret_val = [CCLiquid actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCLiquid* (o)
JSBool JSPROXY_CCLiquid_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCLiquid* ret_val;

	ret_val = [CCLiquid actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLiquid* (o)
JSBool JSPROXY_CCLiquid_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCLiquid* ret_val;

	ret_val = [CCLiquid action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCLiquid_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCLiquid_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCLiquid_class->name = name;
	JSPROXY_CCLiquid_class->addProperty = JS_PropertyStub;
	JSPROXY_CCLiquid_class->delProperty = JS_PropertyStub;
	JSPROXY_CCLiquid_class->getProperty = JS_PropertyStub;
	JSPROXY_CCLiquid_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCLiquid_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCLiquid_class->resolve = JS_ResolveStub;
	JSPROXY_CCLiquid_class->convert = JS_ConvertStub;
	JSPROXY_CCLiquid_class->finalize = JSPROXY_CCLiquid_finalize;
//	JSPROXY_CCLiquid_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSPROXY_CCLiquid_amplitude, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSPROXY_CCLiquid_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithWavesAmplitudeGridDuration", JSPROXY_CCLiquid_initWithWaves_amplitude_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSPROXY_CCLiquid_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSPROXY_CCLiquid_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithWavesAmplitudeGridDuration", JSPROXY_CCLiquid_actionWithWaves_amplitude_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCLiquid_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCLiquid_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCLiquid_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCLiquid_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCLiquid_class, JSPROXY_CCLiquid_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCLiquid

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCLiquid_class, JSPROXY_CCLiquid_object, NULL);
	JSPROXY_CCLiquid *proxy = [[JSPROXY_CCLiquid alloc] initWithJSObject:jsobj class:[CCLiquid class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProgressTimer
 */
#pragma mark - CCProgressTimer

JSClass* JSPROXY_CCProgressTimer_class = NULL;
JSObject* JSPROXY_CCProgressTimer_object = NULL;
 // Constructor
JSBool JSPROXY_CCProgressTimer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCProgressTimer createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCProgressTimer_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCProgressTimer)", obj);
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCProgressTimer_barChangeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real barChangeRate ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: ccColor3B ({_ccColor3B=CCC})
JSBool JSPROXY_CCProgressTimer_color(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccColor3B ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real color ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT8, 3 );
	ccColor3B* buffer = (ccColor3B*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: None (None)
JSBool JSPROXY_CCProgressTimer_initWithSprite_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = [(CCProgressTimer*)[proxy.klass alloc] initWithSprite:(CCSprite*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCProgressTimer_midpoint(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real midpoint ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: GLubyte (c)
JSBool JSPROXY_CCProgressTimer_opacity(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLubyte ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real opacity ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCProgressTimer_percentage(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real percentage ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCProgressTimer_progressWithSprite__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	ret_val = [CCProgressTimer progressWithSprite:(CCSprite*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCProgressTimer_reverseDirection(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real reverseDirection ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setBarChangeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setBarChangeRate:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccColor3B
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setColor_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccColor3B arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccColor3B*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setColor:(ccColor3B)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setMidpoint_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setMidpoint:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLubyte
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setOpacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= JS_ValueToUint16( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setOpacity:(GLubyte)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setPercentage_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setPercentage:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setReverseDirection_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setReverseDirection:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setSprite_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setSprite:(CCSprite*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCProgressTimerType
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setType_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setType:(CCProgressTimerType)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSprite* (o)
JSBool JSPROXY_CCProgressTimer_sprite(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSprite* ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real sprite ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCProgressTimerType (i)
JSBool JSPROXY_CCProgressTimer_type(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCProgressTimerType ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real type ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: int (i)
JSBool JSPROXY_CCProgressTimer_vertexDataCount(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	int ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real vertexDataCount ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCProgressTimer_doesOpacityModifyRGB(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	ret_val = [real doesOpacityModifyRGB ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCProgressTimer_setOpacityModifyRGB_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCProgressTimer *real = (CCProgressTimer*) [proxy realObj];
	[real setOpacityModifyRGB:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCProgressTimer_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCProgressTimer* ret_val;

	ret_val = [CCProgressTimer node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCProgressTimer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCProgressTimer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCProgressTimer_class->name = name;
	JSPROXY_CCProgressTimer_class->addProperty = JS_PropertyStub;
	JSPROXY_CCProgressTimer_class->delProperty = JS_PropertyStub;
	JSPROXY_CCProgressTimer_class->getProperty = JS_PropertyStub;
	JSPROXY_CCProgressTimer_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCProgressTimer_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCProgressTimer_class->resolve = JS_ResolveStub;
	JSPROXY_CCProgressTimer_class->convert = JS_ConvertStub;
	JSPROXY_CCProgressTimer_class->finalize = JSPROXY_CCProgressTimer_finalize;
//	JSPROXY_CCProgressTimer_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBarChangeRate", JSPROXY_CCProgressTimer_barChangeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getColor", JSPROXY_CCProgressTimer_color, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithSprite", JSPROXY_CCProgressTimer_initWithSprite_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getMidpoint", JSPROXY_CCProgressTimer_midpoint, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getOpacity", JSPROXY_CCProgressTimer_opacity, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPercentage", JSPROXY_CCProgressTimer_percentage, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getReverseDirection", JSPROXY_CCProgressTimer_reverseDirection, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBarChangeRate", JSPROXY_CCProgressTimer_setBarChangeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setColor", JSPROXY_CCProgressTimer_setColor_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setMidpoint", JSPROXY_CCProgressTimer_setMidpoint_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacity", JSPROXY_CCProgressTimer_setOpacity_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPercentage", JSPROXY_CCProgressTimer_setPercentage_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setReverseDirection", JSPROXY_CCProgressTimer_setReverseDirection_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSprite", JSPROXY_CCProgressTimer_setSprite_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setType", JSPROXY_CCProgressTimer_setType_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSprite", JSPROXY_CCProgressTimer_sprite, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getType", JSPROXY_CCProgressTimer_type, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getVertexDataCount", JSPROXY_CCProgressTimer_vertexDataCount, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("doesOpacityModifyRGB", JSPROXY_CCProgressTimer_doesOpacityModifyRGB, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setOpacityModifyRGB", JSPROXY_CCProgressTimer_setOpacityModifyRGB_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCProgressTimer_progressWithSprite__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCProgressTimer_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCProgressTimer_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCProgressTimer_class, JSPROXY_CCProgressTimer_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCProgressTimer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCProgressTimer_class, JSPROXY_CCProgressTimer_object, NULL);
	JSPROXY_CCProgressTimer *proxy = [[JSPROXY_CCProgressTimer alloc] initWithJSObject:jsobj class:[CCProgressTimer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBounceInOut
 */
#pragma mark - CCEaseBounceInOut

JSClass* JSPROXY_CCEaseBounceInOut_class = NULL;
JSObject* JSPROXY_CCEaseBounceInOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseBounceInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseBounceInOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseBounceInOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseBounceInOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseBounceInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseBounceInOut *real = (CCEaseBounceInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBounceInOut* (o)
JSBool JSPROXY_CCEaseBounceInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseBounceInOut* ret_val;

	ret_val = [CCEaseBounceInOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseBounceInOut* (o)
JSBool JSPROXY_CCEaseBounceInOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseBounceInOut* ret_val;

	ret_val = [CCEaseBounceInOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseBounceInOut* (o)
JSBool JSPROXY_CCEaseBounceInOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseBounceInOut* ret_val;

	ret_val = [CCEaseBounceInOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseBounceInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseBounceInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseBounceInOut_class->name = name;
	JSPROXY_CCEaseBounceInOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceInOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceInOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseBounceInOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseBounceInOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseBounceInOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseBounceInOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseBounceInOut_class->finalize = JSPROXY_CCEaseBounceInOut_finalize;
//	JSPROXY_CCEaseBounceInOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseBounceInOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseBounceInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseBounceInOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseBounceInOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseBounceInOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseBounce_object, JSPROXY_CCEaseBounceInOut_class, JSPROXY_CCEaseBounceInOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseBounceInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseBounceInOut_class, JSPROXY_CCEaseBounceInOut_object, NULL);
	JSPROXY_CCEaseBounceInOut *proxy = [[JSPROXY_CCEaseBounceInOut alloc] initWithJSObject:jsobj class:[CCEaseBounceInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionTween
 */
#pragma mark - CCActionTween

JSClass* JSPROXY_CCActionTween_class = NULL;
JSObject* JSPROXY_CCActionTween_object = NULL;
 // Constructor
JSBool JSPROXY_CCActionTween_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCActionTween createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCActionTween_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCActionTween)", obj);
}

// Arguments: ccTime, NSString*, float, float
// Ret value: CCActionTween* (o)
JSBool JSPROXY_CCActionTween_actionWithDuration_key_from_to__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; NSString* arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCActionTween* ret_val;

	ret_val = [CCActionTween actionWithDuration:(ccTime)arg0 key:(NSString*)arg1 from:(float)arg2 to:(float)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, NSString*, float, float
// Ret value: None (None)
JSBool JSPROXY_CCActionTween_initWithDuration_key_from_to_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; NSString* arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCActionTween *real = [(CCActionTween*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 key:(NSString*)arg1 from:(float)arg2 to:(float)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCActionTween* (o)
JSBool JSPROXY_CCActionTween_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionTween* ret_val;

	ret_val = [CCActionTween actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCActionTween* (o)
JSBool JSPROXY_CCActionTween_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionTween* ret_val;

	ret_val = [CCActionTween action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCActionTween_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCActionTween_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCActionTween_class->name = name;
	JSPROXY_CCActionTween_class->addProperty = JS_PropertyStub;
	JSPROXY_CCActionTween_class->delProperty = JS_PropertyStub;
	JSPROXY_CCActionTween_class->getProperty = JS_PropertyStub;
	JSPROXY_CCActionTween_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCActionTween_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCActionTween_class->resolve = JS_ResolveStub;
	JSPROXY_CCActionTween_class->convert = JS_ConvertStub;
	JSPROXY_CCActionTween_class->finalize = JSPROXY_CCActionTween_finalize;
//	JSPROXY_CCActionTween_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationKeyFromTo", JSPROXY_CCActionTween_initWithDuration_key_from_to_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDurationKeyFromTo", JSPROXY_CCActionTween_actionWithDuration_key_from_to__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCActionTween_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCActionTween_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCActionTween_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCActionTween_class, JSPROXY_CCActionTween_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCActionTween

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCActionTween_class, JSPROXY_CCActionTween_object, NULL);
	JSPROXY_CCActionTween *proxy = [[JSPROXY_CCActionTween alloc] initWithJSObject:jsobj class:[CCActionTween class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGrabber
 */
#pragma mark - CCGrabber

JSClass* JSPROXY_CCGrabber_class = NULL;
JSObject* JSPROXY_CCGrabber_object = NULL;
 // Constructor
JSBool JSPROXY_CCGrabber_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCGrabber createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCGrabber_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCGrabber)", obj);
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCGrabber_afterRender_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCGrabber *real = (CCGrabber*) [proxy realObj];
	[real afterRender:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCGrabber_beforeRender_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCGrabber *real = (CCGrabber*) [proxy realObj];
	[real beforeRender:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCGrabber_grab_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCGrabber *real = (CCGrabber*) [proxy realObj];
	[real grab:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCGrabber_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCGrabber_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCGrabber_class->name = name;
	JSPROXY_CCGrabber_class->addProperty = JS_PropertyStub;
	JSPROXY_CCGrabber_class->delProperty = JS_PropertyStub;
	JSPROXY_CCGrabber_class->getProperty = JS_PropertyStub;
	JSPROXY_CCGrabber_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCGrabber_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCGrabber_class->resolve = JS_ResolveStub;
	JSPROXY_CCGrabber_class->convert = JS_ConvertStub;
	JSPROXY_CCGrabber_class->finalize = JSPROXY_CCGrabber_finalize;
//	JSPROXY_CCGrabber_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("afterRender", JSPROXY_CCGrabber_afterRender_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("beforeRender", JSPROXY_CCGrabber_beforeRender_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("grab", JSPROXY_CCGrabber_grab_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCGrabber_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCGrabber_class, JSPROXY_CCGrabber_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCGrabber

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCGrabber_class, JSPROXY_CCGrabber_object, NULL);
	JSPROXY_CCGrabber *proxy = [[JSPROXY_CCGrabber alloc] initWithJSObject:jsobj class:[CCGrabber class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionSplitRows
 */
#pragma mark - CCTransitionSplitRows

JSClass* JSPROXY_CCTransitionSplitRows_class = NULL;
JSObject* JSPROXY_CCTransitionSplitRows_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionSplitRows_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionSplitRows createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionSplitRows_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionSplitRows)", obj);
}

// Arguments: 
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionSplitRows_action(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCActionInterval* ret_val;

	CCTransitionSplitRows *real = (CCTransitionSplitRows*) [proxy realObj];
	ret_val = [real action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionSplitRows* (o)
JSBool JSPROXY_CCTransitionSplitRows_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionSplitRows* ret_val;

	ret_val = [CCTransitionSplitRows transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionSplitRows* (o)
JSBool JSPROXY_CCTransitionSplitRows_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionSplitRows* ret_val;

	ret_val = [CCTransitionSplitRows node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionSplitRows_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionSplitRows_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionSplitRows_class->name = name;
	JSPROXY_CCTransitionSplitRows_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSplitRows_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSplitRows_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionSplitRows_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionSplitRows_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionSplitRows_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionSplitRows_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionSplitRows_class->finalize = JSPROXY_CCTransitionSplitRows_finalize;
//	JSPROXY_CCTransitionSplitRows_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("action", JSPROXY_CCTransitionSplitRows_action, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionSplitRows_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionSplitRows_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionSplitRows_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSplitCols_object, JSPROXY_CCTransitionSplitRows_class, JSPROXY_CCTransitionSplitRows_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionSplitRows

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionSplitRows_class, JSPROXY_CCTransitionSplitRows_object, NULL);
	JSPROXY_CCTransitionSplitRows *proxy = [[JSPROXY_CCTransitionSplitRows alloc] initWithJSObject:jsobj class:[CCTransitionSplitRows class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipX3D
 */
#pragma mark - CCFlipX3D

JSClass* JSPROXY_CCFlipX3D_class = NULL;
JSObject* JSPROXY_CCFlipX3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCFlipX3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFlipX3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFlipX3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFlipX3D)", obj);
}

// Arguments: ccTime
// Ret value: CCFlipX3D* (o)
JSBool JSPROXY_CCFlipX3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCFlipX3D* ret_val;

	ret_val = [CCFlipX3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: None (None)
JSBool JSPROXY_CCFlipX3D_initWithDuration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFlipX3D *real = [(CCFlipX3D*)[proxy.klass alloc] initWithDuration:(ccTime)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCFlipX3D* (o)
JSBool JSPROXY_CCFlipX3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCFlipX3D* ret_val;

	ret_val = [CCFlipX3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFlipX3D* (o)
JSBool JSPROXY_CCFlipX3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFlipX3D* ret_val;

	ret_val = [CCFlipX3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFlipX3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFlipX3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFlipX3D_class->name = name;
	JSPROXY_CCFlipX3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFlipX3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFlipX3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFlipX3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFlipX3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFlipX3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCFlipX3D_class->convert = JS_ConvertStub;
	JSPROXY_CCFlipX3D_class->finalize = JSPROXY_CCFlipX3D_finalize;
//	JSPROXY_CCFlipX3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDuration", JSPROXY_CCFlipX3D_initWithDuration_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFlipX3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCFlipX3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFlipX3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFlipX3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCFlipX3D_class, JSPROXY_CCFlipX3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFlipX3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFlipX3D_class, JSPROXY_CCFlipX3D_object, NULL);
	JSPROXY_CCFlipX3D *proxy = [[JSPROXY_CCFlipX3D alloc] initWithJSObject:jsobj class:[CCFlipX3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFlipY3D
 */
#pragma mark - CCFlipY3D

JSClass* JSPROXY_CCFlipY3D_class = NULL;
JSObject* JSPROXY_CCFlipY3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCFlipY3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFlipY3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFlipY3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFlipY3D)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCFlipY3D_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCFlipY3D *real = (CCFlipY3D*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFlipY3D* (o)
JSBool JSPROXY_CCFlipY3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCFlipY3D* ret_val;

	ret_val = [CCFlipY3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCFlipY3D* (o)
JSBool JSPROXY_CCFlipY3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCFlipY3D* ret_val;

	ret_val = [CCFlipY3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFlipY3D* (o)
JSBool JSPROXY_CCFlipY3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFlipY3D* ret_val;

	ret_val = [CCFlipY3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFlipY3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFlipY3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFlipY3D_class->name = name;
	JSPROXY_CCFlipY3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFlipY3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFlipY3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFlipY3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFlipY3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFlipY3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCFlipY3D_class->convert = JS_ConvertStub;
	JSPROXY_CCFlipY3D_class->finalize = JSPROXY_CCFlipY3D_finalize;
//	JSPROXY_CCFlipY3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCFlipY3D_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFlipY3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCFlipY3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFlipY3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFlipY3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCFlipX3D_object, JSPROXY_CCFlipY3D_class, JSPROXY_CCFlipY3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFlipY3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFlipY3D_class, JSPROXY_CCFlipY3D_object, NULL);
	JSPROXY_CCFlipY3D *proxy = [[JSPROXY_CCFlipY3D alloc] initWithJSObject:jsobj class:[CCFlipY3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCFadeTo
 */
#pragma mark - CCFadeTo

JSClass* JSPROXY_CCFadeTo_class = NULL;
JSObject* JSPROXY_CCFadeTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCFadeTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCFadeTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCFadeTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCFadeTo)", obj);
}

// Arguments: ccTime, GLubyte
// Ret value: CCFadeTo* (o)
JSBool JSPROXY_CCFadeTo_actionWithDuration_opacity__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCFadeTo* ret_val;

	ret_val = [CCFadeTo actionWithDuration:(ccTime)arg0 opacity:(GLubyte)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, GLubyte
// Ret value: None (None)
JSBool JSPROXY_CCFadeTo_initWithDuration_opacity_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCFadeTo *real = [(CCFadeTo*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 opacity:(GLubyte)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCFadeTo* (o)
JSBool JSPROXY_CCFadeTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCFadeTo* ret_val;

	ret_val = [CCFadeTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCFadeTo* (o)
JSBool JSPROXY_CCFadeTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCFadeTo* ret_val;

	ret_val = [CCFadeTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCFadeTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCFadeTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCFadeTo_class->name = name;
	JSPROXY_CCFadeTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCFadeTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCFadeTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCFadeTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCFadeTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCFadeTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCFadeTo_class->convert = JS_ConvertStub;
	JSPROXY_CCFadeTo_class->finalize = JSPROXY_CCFadeTo_finalize;
//	JSPROXY_CCFadeTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationOpacity", JSPROXY_CCFadeTo_initWithDuration_opacity_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCFadeTo_actionWithDuration_opacity__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCFadeTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCFadeTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCFadeTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCFadeTo_class, JSPROXY_CCFadeTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCFadeTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCFadeTo_class, JSPROXY_CCFadeTo_object, NULL);
	JSPROXY_CCFadeTo *proxy = [[JSPROXY_CCFadeTo alloc] initWithJSObject:jsobj class:[CCFadeTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseBackInOut
 */
#pragma mark - CCEaseBackInOut

JSClass* JSPROXY_CCEaseBackInOut_class = NULL;
JSObject* JSPROXY_CCEaseBackInOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseBackInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseBackInOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseBackInOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseBackInOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseBackInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseBackInOut *real = (CCEaseBackInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseBackInOut* (o)
JSBool JSPROXY_CCEaseBackInOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseBackInOut* ret_val;

	ret_val = [CCEaseBackInOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseBackInOut* (o)
JSBool JSPROXY_CCEaseBackInOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseBackInOut* ret_val;

	ret_val = [CCEaseBackInOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseBackInOut* (o)
JSBool JSPROXY_CCEaseBackInOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseBackInOut* ret_val;

	ret_val = [CCEaseBackInOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseBackInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseBackInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseBackInOut_class->name = name;
	JSPROXY_CCEaseBackInOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackInOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackInOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseBackInOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseBackInOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseBackInOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseBackInOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseBackInOut_class->finalize = JSPROXY_CCEaseBackInOut_finalize;
//	JSPROXY_CCEaseBackInOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseBackInOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseBackInOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseBackInOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseBackInOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseBackInOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseBackInOut_class, JSPROXY_CCEaseBackInOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseBackInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseBackInOut_class, JSPROXY_CCEaseBackInOut_object, NULL);
	JSPROXY_CCEaseBackInOut *proxy = [[JSPROXY_CCEaseBackInOut alloc] initWithJSObject:jsobj class:[CCEaseBackInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseExponentialOut
 */
#pragma mark - CCEaseExponentialOut

JSClass* JSPROXY_CCEaseExponentialOut_class = NULL;
JSObject* JSPROXY_CCEaseExponentialOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseExponentialOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseExponentialOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseExponentialOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseExponentialOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseExponentialOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseExponentialOut *real = (CCEaseExponentialOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseExponentialOut* (o)
JSBool JSPROXY_CCEaseExponentialOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseExponentialOut* ret_val;

	ret_val = [CCEaseExponentialOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseExponentialOut* (o)
JSBool JSPROXY_CCEaseExponentialOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseExponentialOut* ret_val;

	ret_val = [CCEaseExponentialOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseExponentialOut* (o)
JSBool JSPROXY_CCEaseExponentialOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseExponentialOut* ret_val;

	ret_val = [CCEaseExponentialOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseExponentialOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseExponentialOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseExponentialOut_class->name = name;
	JSPROXY_CCEaseExponentialOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseExponentialOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseExponentialOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseExponentialOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseExponentialOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseExponentialOut_class->finalize = JSPROXY_CCEaseExponentialOut_finalize;
//	JSPROXY_CCEaseExponentialOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseExponentialOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseExponentialOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseExponentialOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseExponentialOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseExponentialOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseExponentialOut_class, JSPROXY_CCEaseExponentialOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseExponentialOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseExponentialOut_class, JSPROXY_CCEaseExponentialOut_object, NULL);
	JSPROXY_CCEaseExponentialOut *proxy = [[JSPROXY_CCEaseExponentialOut alloc] initWithJSObject:jsobj class:[CCEaseExponentialOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCProfilingTimer
 */
#pragma mark - CCProfilingTimer

JSClass* JSPROXY_CCProfilingTimer_class = NULL;
JSObject* JSPROXY_CCProfilingTimer_object = NULL;
 // Constructor
JSBool JSPROXY_CCProfilingTimer_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCProfilingTimer createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCProfilingTimer_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCProfilingTimer)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCProfilingTimer_reset(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCProfilingTimer *real = (CCProfilingTimer*) [proxy realObj];
	[real reset ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCProfilingTimer_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCProfilingTimer_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCProfilingTimer_class->name = name;
	JSPROXY_CCProfilingTimer_class->addProperty = JS_PropertyStub;
	JSPROXY_CCProfilingTimer_class->delProperty = JS_PropertyStub;
	JSPROXY_CCProfilingTimer_class->getProperty = JS_PropertyStub;
	JSPROXY_CCProfilingTimer_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCProfilingTimer_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCProfilingTimer_class->resolve = JS_ResolveStub;
	JSPROXY_CCProfilingTimer_class->convert = JS_ConvertStub;
	JSPROXY_CCProfilingTimer_class->finalize = JSPROXY_CCProfilingTimer_finalize;
//	JSPROXY_CCProfilingTimer_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("reset", JSPROXY_CCProfilingTimer_reset, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCProfilingTimer_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCProfilingTimer_class, JSPROXY_CCProfilingTimer_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCProfilingTimer

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCProfilingTimer_class, JSPROXY_CCProfilingTimer_object, NULL);
	JSPROXY_CCProfilingTimer *proxy = [[JSPROXY_CCProfilingTimer alloc] initWithJSObject:jsobj class:[CCProfilingTimer class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSequence
 */
#pragma mark - CCSequence

JSClass* JSPROXY_CCSequence_class = NULL;
JSObject* JSPROXY_CCSequence_object = NULL;
 // Constructor
JSBool JSPROXY_CCSequence_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSequence createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSequence_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSequence)", obj);
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: CCSequence* (o)
JSBool JSPROXY_CCSequence_actionOne_two__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCSequence* ret_val;

	ret_val = [CCSequence actionOne:(CCFiniteTimeAction*)arg0 two:(CCFiniteTimeAction*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSArray*
// Ret value: CCSequence* (o)
JSBool JSPROXY_CCSequence_actionWithArray__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 0, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSArray* arg0; 

	ok &= jsvals_variadic_to_nsarray( cx, argvp, argc, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSequence* ret_val;

	ret_val = [CCSequence actionWithArray:(NSArray*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCFiniteTimeAction*, CCFiniteTimeAction*
// Ret value: None (None)
JSBool JSPROXY_CCSequence_initOne_two_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCSequence *real = [(CCSequence*)[proxy.klass alloc] initOne:(CCFiniteTimeAction*)arg0 two:(CCFiniteTimeAction*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCSequence* (o)
JSBool JSPROXY_CCSequence_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSequence* ret_val;

	ret_val = [CCSequence actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSequence* (o)
JSBool JSPROXY_CCSequence_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSequence* ret_val;

	ret_val = [CCSequence action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSequence_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSequence_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSequence_class->name = name;
	JSPROXY_CCSequence_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSequence_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSequence_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSequence_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSequence_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSequence_class->resolve = JS_ResolveStub;
	JSPROXY_CCSequence_class->convert = JS_ConvertStub;
	JSPROXY_CCSequence_class->finalize = JSPROXY_CCSequence_finalize;
//	JSPROXY_CCSequence_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initOneTwo", JSPROXY_CCSequence_initOne_two_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionOneTwo", JSPROXY_CCSequence_actionOne_two__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCSequence_actionWithArray__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCSequence_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCSequence_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSequence_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCSequence_class, JSPROXY_CCSequence_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSequence

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSequence_class, JSPROXY_CCSequence_object, NULL);
	JSPROXY_CCSequence *proxy = [[JSPROXY_CCSequence alloc] initWithJSObject:jsobj class:[CCSequence class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseElasticInOut
 */
#pragma mark - CCEaseElasticInOut

JSClass* JSPROXY_CCEaseElasticInOut_class = NULL;
JSObject* JSPROXY_CCEaseElasticInOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseElasticInOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseElasticInOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseElasticInOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseElasticInOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseElasticInOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseElasticInOut *real = (CCEaseElasticInOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*, float
// Ret value: CCEaseElasticInOut* (o)
JSBool JSPROXY_CCEaseElasticInOut_actionWithAction_period__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if (argc >= 2) {
		ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	CCEaseElasticInOut* ret_val;

	if( argc == 1 ) {
		ret_val = [CCEaseElasticInOut actionWithAction:(CCActionInterval*)arg0  ];
	}
	else if( argc == 2 ) {
		ret_val = [CCEaseElasticInOut actionWithAction:(CCActionInterval*)arg0 period:(float)arg1  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseElasticInOut* (o)
JSBool JSPROXY_CCEaseElasticInOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseElasticInOut* ret_val;

	ret_val = [CCEaseElasticInOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseElasticInOut* (o)
JSBool JSPROXY_CCEaseElasticInOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseElasticInOut* ret_val;

	ret_val = [CCEaseElasticInOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseElasticInOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseElasticInOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseElasticInOut_class->name = name;
	JSPROXY_CCEaseElasticInOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticInOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticInOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseElasticInOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseElasticInOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseElasticInOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseElasticInOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseElasticInOut_class->finalize = JSPROXY_CCEaseElasticInOut_finalize;
//	JSPROXY_CCEaseElasticInOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseElasticInOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseElasticInOut_actionWithAction_period__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseElasticInOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseElasticInOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseElasticInOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCEaseElastic_object, JSPROXY_CCEaseElasticInOut_class, JSPROXY_CCEaseElasticInOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseElasticInOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseElasticInOut_class, JSPROXY_CCEaseElasticInOut_object, NULL);
	JSPROXY_CCEaseElasticInOut *proxy = [[JSPROXY_CCEaseElasticInOut alloc] initWithJSObject:jsobj class:[CCEaseElasticInOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCWaves
 */
#pragma mark - CCWaves

JSClass* JSPROXY_CCWaves_class = NULL;
JSObject* JSPROXY_CCWaves_object = NULL;
 // Constructor
JSBool JSPROXY_CCWaves_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCWaves createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCWaves_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCWaves)", obj);
}

// Arguments: int, float, BOOL, BOOL, ccGridSize, ccTime
// Ret value: CCWaves* (o)
JSBool JSPROXY_CCWaves_actionWithWaves_amplitude_horizontal_vertical_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; JSBool arg2; JSBool arg3; ccGridSize arg4; double arg5; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;
	CCWaves* ret_val;

	ret_val = [CCWaves actionWithWaves:(int)arg0 amplitude:(float)arg1 horizontal:(BOOL)arg2 vertical:(BOOL)arg3 grid:(ccGridSize)arg4 duration:(ccTime)arg5  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCWaves_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCWaves *real = (CCWaves*) [proxy realObj];
	ret_val = [real amplitude ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCWaves_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCWaves *real = (CCWaves*) [proxy realObj];
	ret_val = [real amplitudeRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: int, float, BOOL, BOOL, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCWaves_initWithWaves_amplitude_horizontal_vertical_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; JSBool arg2; JSBool arg3; ccGridSize arg4; double arg5; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg3 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;

	CCWaves *real = [(CCWaves*)[proxy.klass alloc] initWithWaves:(int)arg0 amplitude:(float)arg1 horizontal:(BOOL)arg2 vertical:(BOOL)arg3 grid:(ccGridSize)arg4 duration:(ccTime)arg5  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCWaves_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCWaves *real = (CCWaves*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCWaves_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCWaves *real = (CCWaves*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCWaves* (o)
JSBool JSPROXY_CCWaves_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCWaves* ret_val;

	ret_val = [CCWaves actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCWaves* (o)
JSBool JSPROXY_CCWaves_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCWaves* ret_val;

	ret_val = [CCWaves actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCWaves* (o)
JSBool JSPROXY_CCWaves_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCWaves* ret_val;

	ret_val = [CCWaves action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCWaves_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCWaves_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCWaves_class->name = name;
	JSPROXY_CCWaves_class->addProperty = JS_PropertyStub;
	JSPROXY_CCWaves_class->delProperty = JS_PropertyStub;
	JSPROXY_CCWaves_class->getProperty = JS_PropertyStub;
	JSPROXY_CCWaves_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCWaves_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCWaves_class->resolve = JS_ResolveStub;
	JSPROXY_CCWaves_class->convert = JS_ConvertStub;
	JSPROXY_CCWaves_class->finalize = JSPROXY_CCWaves_finalize;
//	JSPROXY_CCWaves_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSPROXY_CCWaves_amplitude, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSPROXY_CCWaves_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithWavesAmplitudeHorizontalVerticalGridDuration", JSPROXY_CCWaves_initWithWaves_amplitude_horizontal_vertical_grid_duration_, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSPROXY_CCWaves_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSPROXY_CCWaves_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithWavesAmplitudeHorizontalVerticalGridDuration", JSPROXY_CCWaves_actionWithWaves_amplitude_horizontal_vertical_grid_duration__static, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCWaves_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCWaves_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCWaves_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCWaves_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCWaves_class, JSPROXY_CCWaves_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCWaves

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCWaves_class, JSPROXY_CCWaves_object, NULL);
	JSPROXY_CCWaves *proxy = [[JSPROXY_CCWaves alloc] initWithJSObject:jsobj class:[CCWaves class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionZoomFlipAngular
 */
#pragma mark - CCTransitionZoomFlipAngular

JSClass* JSPROXY_CCTransitionZoomFlipAngular_class = NULL;
JSObject* JSPROXY_CCTransitionZoomFlipAngular_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionZoomFlipAngular_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionZoomFlipAngular createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionZoomFlipAngular_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionZoomFlipAngular)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionZoomFlipAngular_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionZoomFlipAngular *real = [(CCTransitionZoomFlipAngular*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*, tOrientation
// Ret value: CCTransitionZoomFlipAngular* (o)
JSBool JSPROXY_CCTransitionZoomFlipAngular_transitionWithDuration_scene_orientation__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTransitionZoomFlipAngular* ret_val;

	ret_val = [CCTransitionZoomFlipAngular transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1 orientation:(tOrientation)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionZoomFlipAngular* (o)
JSBool JSPROXY_CCTransitionZoomFlipAngular_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionZoomFlipAngular* ret_val;

	ret_val = [CCTransitionZoomFlipAngular transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionZoomFlipAngular* (o)
JSBool JSPROXY_CCTransitionZoomFlipAngular_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionZoomFlipAngular* ret_val;

	ret_val = [CCTransitionZoomFlipAngular node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionZoomFlipAngular_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionZoomFlipAngular_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionZoomFlipAngular_class->name = name;
	JSPROXY_CCTransitionZoomFlipAngular_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipAngular_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipAngular_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionZoomFlipAngular_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionZoomFlipAngular_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionZoomFlipAngular_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionZoomFlipAngular_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionZoomFlipAngular_class->finalize = JSPROXY_CCTransitionZoomFlipAngular_finalize;
//	JSPROXY_CCTransitionZoomFlipAngular_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionZoomFlipAngular_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("transitionWithDurationSceneOrientation", JSPROXY_CCTransitionZoomFlipAngular_transitionWithDuration_scene_orientation__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("create", JSPROXY_CCTransitionZoomFlipAngular_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionZoomFlipAngular_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionZoomFlipAngular_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionSceneOriented_object, JSPROXY_CCTransitionZoomFlipAngular_class, JSPROXY_CCTransitionZoomFlipAngular_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionZoomFlipAngular

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionZoomFlipAngular_class, JSPROXY_CCTransitionZoomFlipAngular_object, NULL);
	JSPROXY_CCTransitionZoomFlipAngular *proxy = [[JSPROXY_CCTransitionZoomFlipAngular alloc] initWithJSObject:jsobj class:[CCTransitionZoomFlipAngular class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTintBy
 */
#pragma mark - CCTintBy

JSClass* JSPROXY_CCTintBy_class = NULL;
JSObject* JSPROXY_CCTintBy_object = NULL;
 // Constructor
JSBool JSPROXY_CCTintBy_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTintBy createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTintBy_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTintBy)", obj);
}

// Arguments: ccTime, GLshort, GLshort, GLshort
// Ret value: CCTintBy* (o)
JSBool JSPROXY_CCTintBy_actionWithDuration_red_green_blue__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg1 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg2 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCTintBy* ret_val;

	ret_val = [CCTintBy actionWithDuration:(ccTime)arg0 red:(GLshort)arg1 green:(GLshort)arg2 blue:(GLshort)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, GLshort, GLshort, GLshort
// Ret value: None (None)
JSBool JSPROXY_CCTintBy_initWithDuration_red_green_blue_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg1 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg2 );
	ok &= JS_ValueToUint16( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCTintBy *real = [(CCTintBy*)[proxy.klass alloc] initWithDuration:(ccTime)arg0 red:(GLshort)arg1 green:(GLshort)arg2 blue:(GLshort)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCTintBy* (o)
JSBool JSPROXY_CCTintBy_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTintBy* ret_val;

	ret_val = [CCTintBy actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTintBy* (o)
JSBool JSPROXY_CCTintBy_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTintBy* ret_val;

	ret_val = [CCTintBy action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTintBy_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTintBy_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTintBy_class->name = name;
	JSPROXY_CCTintBy_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTintBy_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTintBy_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTintBy_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTintBy_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTintBy_class->resolve = JS_ResolveStub;
	JSPROXY_CCTintBy_class->convert = JS_ConvertStub;
	JSPROXY_CCTintBy_class->finalize = JSPROXY_CCTintBy_finalize;
//	JSPROXY_CCTintBy_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithDurationRedGreenBlue", JSPROXY_CCTintBy_initWithDuration_red_green_blue_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTintBy_actionWithDuration_red_green_blue__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCTintBy_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCTintBy_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTintBy_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCTintBy_class, JSPROXY_CCTintBy_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTintBy

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTintBy_class, JSPROXY_CCTintBy_object, NULL);
	JSPROXY_CCTintBy *proxy = [[JSPROXY_CCTintBy alloc] initWithJSObject:jsobj class:[CCTintBy class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCBezierTo
 */
#pragma mark - CCBezierTo

JSClass* JSPROXY_CCBezierTo_class = NULL;
JSObject* JSPROXY_CCBezierTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCBezierTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCBezierTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCBezierTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCBezierTo)", obj);
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCBezierTo_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCBezierTo *real = (CCBezierTo*) [proxy realObj];
	[real startWithTarget:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCBezierTo* (o)
JSBool JSPROXY_CCBezierTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCBezierTo* ret_val;

	ret_val = [CCBezierTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCBezierTo* (o)
JSBool JSPROXY_CCBezierTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCBezierTo* ret_val;

	ret_val = [CCBezierTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCBezierTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCBezierTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCBezierTo_class->name = name;
	JSPROXY_CCBezierTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCBezierTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCBezierTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCBezierTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCBezierTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCBezierTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCBezierTo_class->convert = JS_ConvertStub;
	JSPROXY_CCBezierTo_class->finalize = JSPROXY_CCBezierTo_finalize;
//	JSPROXY_CCBezierTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSPROXY_CCBezierTo_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithDuration", JSPROXY_CCBezierTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCBezierTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCBezierTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCBezierBy_object, JSPROXY_CCBezierTo_class, JSPROXY_CCBezierTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCBezierTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCBezierTo_class, JSPROXY_CCBezierTo_object, NULL);
	JSPROXY_CCBezierTo *proxy = [[JSPROXY_CCBezierTo alloc] initWithJSObject:jsobj class:[CCBezierTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDeccelAmplitude
 */
#pragma mark - CCDeccelAmplitude

JSClass* JSPROXY_CCDeccelAmplitude_class = NULL;
JSObject* JSPROXY_CCDeccelAmplitude_object = NULL;
 // Constructor
JSBool JSPROXY_CCDeccelAmplitude_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCDeccelAmplitude createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCDeccelAmplitude_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCDeccelAmplitude)", obj);
}

// Arguments: CCAction*, ccTime
// Ret value: CCDeccelAmplitude* (o)
JSBool JSPROXY_CCDeccelAmplitude_actionWithAction_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCDeccelAmplitude* ret_val;

	ret_val = [CCDeccelAmplitude actionWithAction:(CCAction*)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CCAction*, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCDeccelAmplitude_initWithAction_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; double arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCDeccelAmplitude *real = [(CCDeccelAmplitude*)[proxy.klass alloc] initWithAction:(CCAction*)arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCDeccelAmplitude_rate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCDeccelAmplitude *real = (CCDeccelAmplitude*) [proxy realObj];
	ret_val = [real rate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCDeccelAmplitude_setRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCDeccelAmplitude *real = (CCDeccelAmplitude*) [proxy realObj];
	[real setRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCDeccelAmplitude* (o)
JSBool JSPROXY_CCDeccelAmplitude_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCDeccelAmplitude* ret_val;

	ret_val = [CCDeccelAmplitude actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCDeccelAmplitude* (o)
JSBool JSPROXY_CCDeccelAmplitude_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCDeccelAmplitude* ret_val;

	ret_val = [CCDeccelAmplitude action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCDeccelAmplitude_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCDeccelAmplitude_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCDeccelAmplitude_class->name = name;
	JSPROXY_CCDeccelAmplitude_class->addProperty = JS_PropertyStub;
	JSPROXY_CCDeccelAmplitude_class->delProperty = JS_PropertyStub;
	JSPROXY_CCDeccelAmplitude_class->getProperty = JS_PropertyStub;
	JSPROXY_CCDeccelAmplitude_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCDeccelAmplitude_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCDeccelAmplitude_class->resolve = JS_ResolveStub;
	JSPROXY_CCDeccelAmplitude_class->convert = JS_ConvertStub;
	JSPROXY_CCDeccelAmplitude_class->finalize = JSPROXY_CCDeccelAmplitude_finalize;
//	JSPROXY_CCDeccelAmplitude_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithActionDuration", JSPROXY_CCDeccelAmplitude_initWithAction_duration_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRate", JSPROXY_CCDeccelAmplitude_rate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRate", JSPROXY_CCDeccelAmplitude_setRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithActionDuration", JSPROXY_CCDeccelAmplitude_actionWithAction_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCDeccelAmplitude_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCDeccelAmplitude_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCDeccelAmplitude_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionInterval_object, JSPROXY_CCDeccelAmplitude_class, JSPROXY_CCDeccelAmplitude_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCDeccelAmplitude

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCDeccelAmplitude_class, JSPROXY_CCDeccelAmplitude_object, NULL);
	JSPROXY_CCDeccelAmplitude *proxy = [[JSPROXY_CCDeccelAmplitude alloc] initWithJSObject:jsobj class:[CCDeccelAmplitude class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCLens3D
 */
#pragma mark - CCLens3D

JSClass* JSPROXY_CCLens3D_class = NULL;
JSObject* JSPROXY_CCLens3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCLens3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCLens3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCLens3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCLens3D)", obj);
}

// Arguments: CGPoint, float, ccGridSize, ccTime
// Ret value: CCLens3D* (o)
JSBool JSPROXY_CCLens3D_actionWithPosition_radius_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCLens3D* ret_val;

	ret_val = [CCLens3D actionWithPosition:(CGPoint)arg0 radius:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: CGPoint, float, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCLens3D_initWithPosition_radius_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCLens3D *real = [(CCLens3D*)[proxy.klass alloc] initWithPosition:(CGPoint)arg0 radius:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCLens3D_lensEffect(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCLens3D *real = (CCLens3D*) [proxy realObj];
	ret_val = [real lensEffect ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCLens3D_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCLens3D *real = (CCLens3D*) [proxy realObj];
	ret_val = [real position ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCLens3D_setLensEffect_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLens3D *real = (CCLens3D*) [proxy realObj];
	[real setLensEffect:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCLens3D_setPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCLens3D *real = (CCLens3D*) [proxy realObj];
	[real setPosition:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCLens3D* (o)
JSBool JSPROXY_CCLens3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCLens3D* ret_val;

	ret_val = [CCLens3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCLens3D* (o)
JSBool JSPROXY_CCLens3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCLens3D* ret_val;

	ret_val = [CCLens3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCLens3D* (o)
JSBool JSPROXY_CCLens3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCLens3D* ret_val;

	ret_val = [CCLens3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCLens3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCLens3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCLens3D_class->name = name;
	JSPROXY_CCLens3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCLens3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCLens3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCLens3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCLens3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCLens3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCLens3D_class->convert = JS_ConvertStub;
	JSPROXY_CCLens3D_class->finalize = JSPROXY_CCLens3D_finalize;
//	JSPROXY_CCLens3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithPositionRadiusGridDuration", JSPROXY_CCLens3D_initWithPosition_radius_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getLensEffect", JSPROXY_CCLens3D_lensEffect, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSPROXY_CCLens3D_position, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setLensEffect", JSPROXY_CCLens3D_setLensEffect_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSPROXY_CCLens3D_setPosition_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithPositionRadiusGridDuration", JSPROXY_CCLens3D_actionWithPosition_radius_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCLens3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCLens3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCLens3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCLens3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCLens3D_class, JSPROXY_CCLens3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCLens3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCLens3D_class, JSPROXY_CCLens3D_object, NULL);
	JSPROXY_CCLens3D *proxy = [[JSPROXY_CCLens3D alloc] initWithJSObject:jsobj class:[CCLens3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCWaves3D
 */
#pragma mark - CCWaves3D

JSClass* JSPROXY_CCWaves3D_class = NULL;
JSObject* JSPROXY_CCWaves3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCWaves3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCWaves3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCWaves3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCWaves3D)", obj);
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: CCWaves3D* (o)
JSBool JSPROXY_CCWaves3D_actionWithWaves_amplitude_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCWaves3D* ret_val;

	ret_val = [CCWaves3D actionWithWaves:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCWaves3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	ret_val = [real amplitude ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCWaves3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCWaves3D_initWithWaves_amplitude_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCWaves3D *real = [(CCWaves3D*)[proxy.klass alloc] initWithWaves:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCWaves3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCWaves3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCWaves3D *real = (CCWaves3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCWaves3D* (o)
JSBool JSPROXY_CCWaves3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCWaves3D* ret_val;

	ret_val = [CCWaves3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCWaves3D* (o)
JSBool JSPROXY_CCWaves3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCWaves3D* ret_val;

	ret_val = [CCWaves3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCWaves3D* (o)
JSBool JSPROXY_CCWaves3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCWaves3D* ret_val;

	ret_val = [CCWaves3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCWaves3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCWaves3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCWaves3D_class->name = name;
	JSPROXY_CCWaves3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCWaves3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCWaves3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCWaves3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCWaves3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCWaves3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCWaves3D_class->convert = JS_ConvertStub;
	JSPROXY_CCWaves3D_class->finalize = JSPROXY_CCWaves3D_finalize;
//	JSPROXY_CCWaves3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSPROXY_CCWaves3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSPROXY_CCWaves3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithWavesAmplitudeGridDuration", JSPROXY_CCWaves3D_initWithWaves_amplitude_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSPROXY_CCWaves3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSPROXY_CCWaves3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCWaves3D_actionWithWaves_amplitude_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCWaves3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCWaves3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCWaves3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCWaves3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCWaves3D_class, JSPROXY_CCWaves3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCWaves3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCWaves3D_class, JSPROXY_CCWaves3D_object, NULL);
	JSPROXY_CCWaves3D *proxy = [[JSPROXY_CCWaves3D alloc] initWithJSObject:jsobj class:[CCWaves3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCJumpTo
 */
#pragma mark - CCJumpTo

JSClass* JSPROXY_CCJumpTo_class = NULL;
JSObject* JSPROXY_CCJumpTo_object = NULL;
 // Constructor
JSBool JSPROXY_CCJumpTo_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCJumpTo createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCJumpTo_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCJumpTo)", obj);
}

// Arguments: CCNode*
// Ret value: void (None)
JSBool JSPROXY_CCJumpTo_startWithTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCJumpTo *real = (CCJumpTo*) [proxy realObj];
	[real startWithTarget:(CCNode*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CGPoint, ccTime, NSUInteger
// Ret value: CCJumpTo* (o)
JSBool JSPROXY_CCJumpTo_actionWithDuration_position_height_jumps__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; CGPoint arg1; double arg2; uint32_t arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCJumpTo* ret_val;

	ret_val = [CCJumpTo actionWithDuration:(ccTime)arg0 position:(CGPoint)arg1 height:(ccTime)arg2 jumps:(NSUInteger)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCJumpTo* (o)
JSBool JSPROXY_CCJumpTo_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCJumpTo* ret_val;

	ret_val = [CCJumpTo actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCJumpTo* (o)
JSBool JSPROXY_CCJumpTo_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCJumpTo* ret_val;

	ret_val = [CCJumpTo action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCJumpTo_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCJumpTo_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCJumpTo_class->name = name;
	JSPROXY_CCJumpTo_class->addProperty = JS_PropertyStub;
	JSPROXY_CCJumpTo_class->delProperty = JS_PropertyStub;
	JSPROXY_CCJumpTo_class->getProperty = JS_PropertyStub;
	JSPROXY_CCJumpTo_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCJumpTo_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCJumpTo_class->resolve = JS_ResolveStub;
	JSPROXY_CCJumpTo_class->convert = JS_ConvertStub;
	JSPROXY_CCJumpTo_class->finalize = JSPROXY_CCJumpTo_finalize;
//	JSPROXY_CCJumpTo_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("startWithTarget", JSPROXY_CCJumpTo_startWithTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCJumpTo_actionWithDuration_position_height_jumps__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCJumpTo_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCJumpTo_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCJumpTo_object = JS_InitClass(cx, globalObj, JSPROXY_CCJumpBy_object, JSPROXY_CCJumpTo_class, JSPROXY_CCJumpTo_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCJumpTo

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCJumpTo_class, JSPROXY_CCJumpTo_object, NULL);
	JSPROXY_CCJumpTo *proxy = [[JSPROXY_CCJumpTo alloc] initWithJSObject:jsobj class:[CCJumpTo class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCDrawNode
 */
#pragma mark - CCDrawNode

JSClass* JSPROXY_CCDrawNode_class = NULL;
JSObject* JSPROXY_CCDrawNode_object = NULL;
 // Constructor
JSBool JSPROXY_CCDrawNode_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCDrawNode createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCDrawNode_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCDrawNode)", obj);
}

// Arguments: 
// Ret value: ccBlendFunc ({_ccBlendFunc=II})
JSBool JSPROXY_CCDrawNode_blendFunc(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	ccBlendFunc ret_val;

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	ret_val = [real blendFunc ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_UINT32, 2 );
	ccBlendFunc* buffer = (ccBlendFunc*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCDrawNode_clear(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	[real clear ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint, CGFloat, ccColor4F
// Ret value: void (None)
JSBool JSPROXY_CCDrawNode_drawDot_radius_color_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; double arg1; ccColor4F arg2; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );

	JSObject *tmp_arg2;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg2 );
	arg2 = *(ccColor4F*)JS_GetTypedArrayData( tmp_arg2);
	if( ! ok ) return JS_FALSE;

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	[real drawDot:(CGPoint)arg0 radius:(CGFloat)arg1 color:(ccColor4F)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint, CGPoint, CGFloat, ccColor4F
// Ret value: void (None)
JSBool JSPROXY_CCDrawNode_drawSegmentFrom_to_radius_color_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; CGPoint arg1; double arg2; ccColor4F arg3; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );

	JSObject *tmp_arg3;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg3 );
	arg3 = *(ccColor4F*)JS_GetTypedArrayData( tmp_arg3);
	if( ! ok ) return JS_FALSE;

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	[real drawSegmentFrom:(CGPoint)arg0 to:(CGPoint)arg1 radius:(CGFloat)arg2 color:(ccColor4F)arg3  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccBlendFunc
// Ret value: void (None)
JSBool JSPROXY_CCDrawNode_setBlendFunc_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccBlendFunc arg0; 


	JSObject *tmp_arg0;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg0 );
	arg0 = *(ccBlendFunc*)JS_GetTypedArrayData( tmp_arg0);
	if( ! ok ) return JS_FALSE;

	CCDrawNode *real = (CCDrawNode*) [proxy realObj];
	[real setBlendFunc:(ccBlendFunc)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCDrawNode* (o)
JSBool JSPROXY_CCDrawNode_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCDrawNode* ret_val;

	ret_val = [CCDrawNode node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCDrawNode_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCDrawNode_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCDrawNode_class->name = name;
	JSPROXY_CCDrawNode_class->addProperty = JS_PropertyStub;
	JSPROXY_CCDrawNode_class->delProperty = JS_PropertyStub;
	JSPROXY_CCDrawNode_class->getProperty = JS_PropertyStub;
	JSPROXY_CCDrawNode_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCDrawNode_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCDrawNode_class->resolve = JS_ResolveStub;
	JSPROXY_CCDrawNode_class->convert = JS_ConvertStub;
	JSPROXY_CCDrawNode_class->finalize = JSPROXY_CCDrawNode_finalize;
//	JSPROXY_CCDrawNode_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getBlendFunc", JSPROXY_CCDrawNode_blendFunc, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("clear", JSPROXY_CCDrawNode_clear, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawDot", JSPROXY_CCDrawNode_drawDot_radius_color_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawPoly", JSPROXY_CCDrawNode_drawPolyWithVerts_count_fillColor_borderWidth_borderColor_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("drawSegment", JSPROXY_CCDrawNode_drawSegmentFrom_to_radius_color_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setBlendFunc", JSPROXY_CCDrawNode_setBlendFunc_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCDrawNode_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCDrawNode_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCDrawNode_class, JSPROXY_CCDrawNode_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCDrawNode

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCDrawNode_class, JSPROXY_CCDrawNode_object, NULL);
	JSPROXY_CCDrawNode *proxy = [[JSPROXY_CCDrawNode alloc] initWithJSObject:jsobj class:[CCDrawNode class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCWavesTiles3D
 */
#pragma mark - CCWavesTiles3D

JSClass* JSPROXY_CCWavesTiles3D_class = NULL;
JSObject* JSPROXY_CCWavesTiles3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCWavesTiles3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCWavesTiles3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCWavesTiles3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCWavesTiles3D)", obj);
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: CCWavesTiles3D* (o)
JSBool JSPROXY_CCWavesTiles3D_actionWithWaves_amplitude_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;
	CCWavesTiles3D* ret_val;

	ret_val = [CCWavesTiles3D actionWithWaves:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCWavesTiles3D_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	ret_val = [real amplitude ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCWavesTiles3D_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	ret_val = [real amplitudeRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: int, float, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCWavesTiles3D_initWithWaves_amplitude_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; ccGridSize arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCWavesTiles3D *real = [(CCWavesTiles3D*)[proxy.klass alloc] initWithWaves:(int)arg0 amplitude:(float)arg1 grid:(ccGridSize)arg2 duration:(ccTime)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCWavesTiles3D_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCWavesTiles3D_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCWavesTiles3D *real = (CCWavesTiles3D*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCWavesTiles3D* (o)
JSBool JSPROXY_CCWavesTiles3D_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCWavesTiles3D* ret_val;

	ret_val = [CCWavesTiles3D actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCWavesTiles3D* (o)
JSBool JSPROXY_CCWavesTiles3D_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCWavesTiles3D* ret_val;

	ret_val = [CCWavesTiles3D actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCWavesTiles3D* (o)
JSBool JSPROXY_CCWavesTiles3D_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCWavesTiles3D* ret_val;

	ret_val = [CCWavesTiles3D action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCWavesTiles3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCWavesTiles3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCWavesTiles3D_class->name = name;
	JSPROXY_CCWavesTiles3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCWavesTiles3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCWavesTiles3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCWavesTiles3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCWavesTiles3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCWavesTiles3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCWavesTiles3D_class->convert = JS_ConvertStub;
	JSPROXY_CCWavesTiles3D_class->finalize = JSPROXY_CCWavesTiles3D_finalize;
//	JSPROXY_CCWavesTiles3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSPROXY_CCWavesTiles3D_amplitude, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSPROXY_CCWavesTiles3D_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithWavesAmplitudeGridDuration", JSPROXY_CCWavesTiles3D_initWithWaves_amplitude_grid_duration_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSPROXY_CCWavesTiles3D_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSPROXY_CCWavesTiles3D_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithWavesAmplitudeGridDuration", JSPROXY_CCWavesTiles3D_actionWithWaves_amplitude_grid_duration__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCWavesTiles3D_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCWavesTiles3D_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCWavesTiles3D_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCWavesTiles3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCWavesTiles3D_class, JSPROXY_CCWavesTiles3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCWavesTiles3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCWavesTiles3D_class, JSPROXY_CCWavesTiles3D_object, NULL);
	JSPROXY_CCWavesTiles3D *proxy = [[JSPROXY_CCWavesTiles3D alloc] initWithJSObject:jsobj class:[CCWavesTiles3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTurnOffTiles
 */
#pragma mark - CCTurnOffTiles

JSClass* JSPROXY_CCTurnOffTiles_class = NULL;
JSObject* JSPROXY_CCTurnOffTiles_object = NULL;
 // Constructor
JSBool JSPROXY_CCTurnOffTiles_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTurnOffTiles createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTurnOffTiles_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTurnOffTiles)", obj);
}

// Arguments: int, ccGridSize, ccTime
// Ret value: CCTurnOffTiles* (o)
JSBool JSPROXY_CCTurnOffTiles_actionWithSeed_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; ccGridSize arg1; double arg2; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCTurnOffTiles* ret_val;

	ret_val = [CCTurnOffTiles actionWithSeed:(int)arg0 grid:(ccGridSize)arg1 duration:(ccTime)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCTurnOffTiles_initWithSeed_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; ccGridSize arg1; double arg2; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCTurnOffTiles *real = [(CCTurnOffTiles*)[proxy.klass alloc] initWithSeed:(int)arg0 grid:(ccGridSize)arg1 duration:(ccTime)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCTurnOffTiles* (o)
JSBool JSPROXY_CCTurnOffTiles_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTurnOffTiles* ret_val;

	ret_val = [CCTurnOffTiles actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCTurnOffTiles* (o)
JSBool JSPROXY_CCTurnOffTiles_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTurnOffTiles* ret_val;

	ret_val = [CCTurnOffTiles actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTurnOffTiles* (o)
JSBool JSPROXY_CCTurnOffTiles_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTurnOffTiles* ret_val;

	ret_val = [CCTurnOffTiles action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTurnOffTiles_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTurnOffTiles_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTurnOffTiles_class->name = name;
	JSPROXY_CCTurnOffTiles_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTurnOffTiles_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTurnOffTiles_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTurnOffTiles_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTurnOffTiles_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTurnOffTiles_class->resolve = JS_ResolveStub;
	JSPROXY_CCTurnOffTiles_class->convert = JS_ConvertStub;
	JSPROXY_CCTurnOffTiles_class->finalize = JSPROXY_CCTurnOffTiles_finalize;
//	JSPROXY_CCTurnOffTiles_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithSeedGridDuration", JSPROXY_CCTurnOffTiles_initWithSeed_grid_duration_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithSeedGridDuration", JSPROXY_CCTurnOffTiles_actionWithSeed_grid_duration__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCTurnOffTiles_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCTurnOffTiles_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCTurnOffTiles_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTurnOffTiles_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCTurnOffTiles_class, JSPROXY_CCTurnOffTiles_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTurnOffTiles

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTurnOffTiles_class, JSPROXY_CCTurnOffTiles_object, NULL);
	JSPROXY_CCTurnOffTiles *proxy = [[JSPROXY_CCTurnOffTiles alloc] initWithJSObject:jsobj class:[CCTurnOffTiles class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionJumpZoom
 */
#pragma mark - CCTransitionJumpZoom

JSClass* JSPROXY_CCTransitionJumpZoom_class = NULL;
JSObject* JSPROXY_CCTransitionJumpZoom_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionJumpZoom_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionJumpZoom createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionJumpZoom_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionJumpZoom)", obj);
}

// Arguments: 
// Ret value: None (None)
JSBool JSPROXY_CCTransitionJumpZoom_init(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCTransitionJumpZoom *real = [(CCTransitionJumpZoom*)[proxy.klass alloc] init ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionJumpZoom* (o)
JSBool JSPROXY_CCTransitionJumpZoom_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionJumpZoom* ret_val;

	ret_val = [CCTransitionJumpZoom transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionJumpZoom* (o)
JSBool JSPROXY_CCTransitionJumpZoom_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionJumpZoom* ret_val;

	ret_val = [CCTransitionJumpZoom node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionJumpZoom_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionJumpZoom_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionJumpZoom_class->name = name;
	JSPROXY_CCTransitionJumpZoom_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionJumpZoom_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionJumpZoom_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionJumpZoom_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionJumpZoom_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionJumpZoom_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionJumpZoom_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionJumpZoom_class->finalize = JSPROXY_CCTransitionJumpZoom_finalize;
//	JSPROXY_CCTransitionJumpZoom_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("init", JSPROXY_CCTransitionJumpZoom_init, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionJumpZoom_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionJumpZoom_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionJumpZoom_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionScene_object, JSPROXY_CCTransitionJumpZoom_class, JSPROXY_CCTransitionJumpZoom_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionJumpZoom

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionJumpZoom_class, JSPROXY_CCTransitionJumpZoom_object, NULL);
	JSPROXY_CCTransitionJumpZoom *proxy = [[JSPROXY_CCTransitionJumpZoom alloc] initWithJSObject:jsobj class:[CCTransitionJumpZoom class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSplitCols
 */
#pragma mark - CCSplitCols

JSClass* JSPROXY_CCSplitCols_class = NULL;
JSObject* JSPROXY_CCSplitCols_object = NULL;
 // Constructor
JSBool JSPROXY_CCSplitCols_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSplitCols createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSplitCols_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSplitCols)", obj);
}

// Arguments: int, ccTime
// Ret value: CCSplitCols* (o)
JSBool JSPROXY_CCSplitCols_actionWithCols_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCSplitCols* ret_val;

	ret_val = [CCSplitCols actionWithCols:(int)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: int, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCSplitCols_initWithCols_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSplitCols *real = [(CCSplitCols*)[proxy.klass alloc] initWithCols:(int)arg0 duration:(ccTime)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCSplitCols* (o)
JSBool JSPROXY_CCSplitCols_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCSplitCols* ret_val;

	ret_val = [CCSplitCols actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCSplitCols* (o)
JSBool JSPROXY_CCSplitCols_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSplitCols* ret_val;

	ret_val = [CCSplitCols actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSplitCols* (o)
JSBool JSPROXY_CCSplitCols_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSplitCols* ret_val;

	ret_val = [CCSplitCols action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSplitCols_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSplitCols_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSplitCols_class->name = name;
	JSPROXY_CCSplitCols_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSplitCols_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSplitCols_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSplitCols_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSplitCols_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSplitCols_class->resolve = JS_ResolveStub;
	JSPROXY_CCSplitCols_class->convert = JS_ConvertStub;
	JSPROXY_CCSplitCols_class->finalize = JSPROXY_CCSplitCols_finalize;
//	JSPROXY_CCSplitCols_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("initWithColsDuration", JSPROXY_CCSplitCols_initWithCols_duration_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithColsDuration", JSPROXY_CCSplitCols_actionWithCols_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCSplitCols_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCSplitCols_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCSplitCols_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSplitCols_object = JS_InitClass(cx, globalObj, JSPROXY_CCTiledGrid3DAction_object, JSPROXY_CCSplitCols_class, JSPROXY_CCSplitCols_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSplitCols

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSplitCols_class, JSPROXY_CCSplitCols_object, NULL);
	JSPROXY_CCSplitCols *proxy = [[JSPROXY_CCSplitCols alloc] initWithJSObject:jsobj class:[CCSplitCols class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionFadeUp
 */
#pragma mark - CCTransitionFadeUp

JSClass* JSPROXY_CCTransitionFadeUp_class = NULL;
JSObject* JSPROXY_CCTransitionFadeUp_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionFadeUp_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionFadeUp createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionFadeUp_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionFadeUp)", obj);
}

// Arguments: ccGridSize
// Ret value: CCActionInterval* (o)
JSBool JSPROXY_CCTransitionFadeUp_actionWithSize_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCActionInterval* ret_val;

	CCTransitionFadeUp *real = (CCTransitionFadeUp*) [proxy realObj];
	ret_val = [real actionWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionFadeUp* (o)
JSBool JSPROXY_CCTransitionFadeUp_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionFadeUp* ret_val;

	ret_val = [CCTransitionFadeUp transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionFadeUp* (o)
JSBool JSPROXY_CCTransitionFadeUp_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionFadeUp* ret_val;

	ret_val = [CCTransitionFadeUp node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionFadeUp_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionFadeUp_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionFadeUp_class->name = name;
	JSPROXY_CCTransitionFadeUp_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeUp_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeUp_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionFadeUp_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionFadeUp_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionFadeUp_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionFadeUp_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionFadeUp_class->finalize = JSPROXY_CCTransitionFadeUp_finalize;
//	JSPROXY_CCTransitionFadeUp_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("actionWithSize", JSPROXY_CCTransitionFadeUp_actionWithSize_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionFadeUp_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionFadeUp_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionFadeUp_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionFadeTR_object, JSPROXY_CCTransitionFadeUp_class, JSPROXY_CCTransitionFadeUp_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionFadeUp

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionFadeUp_class, JSPROXY_CCTransitionFadeUp_object, NULL);
	JSPROXY_CCTransitionFadeUp *proxy = [[JSPROXY_CCTransitionFadeUp alloc] initWithJSObject:jsobj class:[CCTransitionFadeUp class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCRenderTexture
 */
#pragma mark - CCRenderTexture

JSClass* JSPROXY_CCRenderTexture_class = NULL;
JSObject* JSPROXY_CCRenderTexture_object = NULL;
 // Constructor
JSBool JSPROXY_CCRenderTexture_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCRenderTexture createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCRenderTexture_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCRenderTexture)", obj);
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_begin(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real begin ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float, float
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_beginWithClear_g_b_a_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real beginWithClear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float, float, float
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_beginWithClear_g_b_a_depth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real beginWithClear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3 depth:(float)arg4  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float, float, float, int
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_beginWithClear_g_b_a_depth_stencil_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 6, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; double arg4; int32_t arg5; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg5 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real beginWithClear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3 depth:(float)arg4 stencil:(int)arg5  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float, float, float, float
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_clear_g_b_a_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; double arg1; double arg2; double arg3; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real clear:(float)arg0 g:(float)arg1 b:(float)arg2 a:(float)arg3  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_clearDepth_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real clearDepth:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: int
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_clearStencil_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real clearStencil:(int)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_end(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real end ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: int, int, CCTexture2DPixelFormat
// Ret value: None (None)
JSBool JSPROXY_CCRenderTexture_initWithWidth_height_pixelFormat_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = [(CCRenderTexture*)[proxy.klass alloc] initWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: int, int, CCTexture2DPixelFormat, GLuint
// Ret value: None (None)
JSBool JSPROXY_CCRenderTexture_initWithWidth_height_pixelFormat_depthStencilFormat_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; uint32_t arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = [(CCRenderTexture*)[proxy.klass alloc] initWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2 depthStencilFormat:(GLuint)arg3  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: int, int, CCTexture2DPixelFormat, GLuint
// Ret value: CCRenderTexture* (o)
JSBool JSPROXY_CCRenderTexture_renderTextureWithWidth_height_pixelFormat_depthStencilFormat__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc >= 2 && argc <= 4 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; uint32_t arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	if (argc >= 3) {
		ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg2 );
	}
	if (argc >= 4) {
		ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg3 );
	}
	if( ! ok ) return JS_FALSE;
	CCRenderTexture* ret_val;

	if( argc == 2 ) {
		ret_val = [CCRenderTexture renderTextureWithWidth:(int)arg0 height:(int)arg1  ];
	}
	else if( argc == 3 ) {
		ret_val = [CCRenderTexture renderTextureWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2  ];
	}
	else if( argc == 4 ) {
		ret_val = [CCRenderTexture renderTextureWithWidth:(int)arg0 height:(int)arg1 pixelFormat:(CCTexture2DPixelFormat)arg2 depthStencilFormat:(GLuint)arg3  ];
	}
	else
		return JS_FALSE;


	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*, tCCImageFormat
// Ret value: BOOL (b)
JSBool JSPROXY_CCRenderTexture_saveToFile_format_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; int32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;
	BOOL ret_val;

	if( argc == 1 ) {
		CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real saveToFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real saveToFile:(NSString*)arg0 format:(tCCImageFormat)arg1  ];
	}
	else
		return JS_FALSE;

	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CCSprite*
// Ret value: void (None)
JSBool JSPROXY_CCRenderTexture_setSprite_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	[real setSprite:(CCSprite*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSprite* (o)
JSBool JSPROXY_CCRenderTexture_sprite(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSprite* ret_val;

	CCRenderTexture *real = (CCRenderTexture*) [proxy realObj];
	ret_val = [real sprite ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCRenderTexture* (o)
JSBool JSPROXY_CCRenderTexture_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCRenderTexture* ret_val;

	ret_val = [CCRenderTexture node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCRenderTexture_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCRenderTexture_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCRenderTexture_class->name = name;
	JSPROXY_CCRenderTexture_class->addProperty = JS_PropertyStub;
	JSPROXY_CCRenderTexture_class->delProperty = JS_PropertyStub;
	JSPROXY_CCRenderTexture_class->getProperty = JS_PropertyStub;
	JSPROXY_CCRenderTexture_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCRenderTexture_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCRenderTexture_class->resolve = JS_ResolveStub;
	JSPROXY_CCRenderTexture_class->convert = JS_ConvertStub;
	JSPROXY_CCRenderTexture_class->finalize = JSPROXY_CCRenderTexture_finalize;
//	JSPROXY_CCRenderTexture_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("begin", JSPROXY_CCRenderTexture_begin, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("beginWithClearGBA", JSPROXY_CCRenderTexture_beginWithClear_g_b_a_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("beginWithClearGBADepth", JSPROXY_CCRenderTexture_beginWithClear_g_b_a_depth_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("beginWithClearGBADepthStencil", JSPROXY_CCRenderTexture_beginWithClear_g_b_a_depth_stencil_, 6, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("clear", JSPROXY_CCRenderTexture_clear_g_b_a_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("clearDepth", JSPROXY_CCRenderTexture_clearDepth_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("clearStencil", JSPROXY_CCRenderTexture_clearStencil_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("end", JSPROXY_CCRenderTexture_end, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithWidthHeightPixelFormat", JSPROXY_CCRenderTexture_initWithWidth_height_pixelFormat_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithWidthHeightPixelFormatDepthStencilFormat", JSPROXY_CCRenderTexture_initWithWidth_height_pixelFormat_depthStencilFormat_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("saveToFile", JSPROXY_CCRenderTexture_saveToFile_format_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setSprite", JSPROXY_CCRenderTexture_setSprite_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getSprite", JSPROXY_CCRenderTexture_sprite, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCRenderTexture_renderTextureWithWidth_height_pixelFormat_depthStencilFormat__static, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCRenderTexture_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCRenderTexture_object = JS_InitClass(cx, globalObj, JSPROXY_CCNode_object, JSPROXY_CCRenderTexture_class, JSPROXY_CCRenderTexture_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCRenderTexture

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCRenderTexture_class, JSPROXY_CCRenderTexture_object, NULL);
	JSPROXY_CCRenderTexture *proxy = [[JSPROXY_CCRenderTexture alloc] initWithJSObject:jsobj class:[CCRenderTexture class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTwirl
 */
#pragma mark - CCTwirl

JSClass* JSPROXY_CCTwirl_class = NULL;
JSObject* JSPROXY_CCTwirl_object = NULL;
 // Constructor
JSBool JSPROXY_CCTwirl_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTwirl createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTwirl_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTwirl)", obj);
}

// Arguments: CGPoint, int, float, ccGridSize, ccTime
// Ret value: CCTwirl* (o)
JSBool JSPROXY_CCTwirl_actionWithPosition_twirls_amplitude_grid_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; int32_t arg1; double arg2; ccGridSize arg3; double arg4; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;
	CCTwirl* ret_val;

	ret_val = [CCTwirl actionWithPosition:(CGPoint)arg0 twirls:(int)arg1 amplitude:(float)arg2 grid:(ccGridSize)arg3 duration:(ccTime)arg4  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCTwirl_amplitude(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	ret_val = [real amplitude ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: float (d)
JSBool JSPROXY_CCTwirl_amplitudeRate(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	float ret_val;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	ret_val = [real amplitudeRate ];
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: CGPoint, int, float, ccGridSize, ccTime
// Ret value: None (None)
JSBool JSPROXY_CCTwirl_initWithPosition_twirls_amplitude_grid_duration_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; int32_t arg1; double arg2; ccGridSize arg3; double arg4; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;

	CCTwirl *real = [(CCTwirl*)[proxy.klass alloc] initWithPosition:(CGPoint)arg0 twirls:(int)arg1 amplitude:(float)arg2 grid:(ccGridSize)arg3 duration:(ccTime)arg4  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CGPoint ({CGPoint=ff})
JSBool JSPROXY_CCTwirl_position(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CGPoint ret_val;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	ret_val = [real position ];

	jsval ret_jsval = CGPoint_to_jsval( cx, (CGPoint)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCTwirl_setAmplitude_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	[real setAmplitude:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: float
// Ret value: void (None)
JSBool JSPROXY_CCTwirl_setAmplitudeRate_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	[real setAmplitudeRate:(float)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CGPoint
// Ret value: void (None)
JSBool JSPROXY_CCTwirl_setPosition_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	CGPoint arg0; 

	ok &= jsval_to_CGPoint( cx, *argvp++, (CGPoint*) &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTwirl *real = (CCTwirl*) [proxy realObj];
	[real setPosition:(CGPoint)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize, ccTime
// Ret value: CCTwirl* (o)
JSBool JSPROXY_CCTwirl_actionWithSize_duration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; double arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;
	CCTwirl* ret_val;

	ret_val = [CCTwirl actionWithSize:(ccGridSize)arg0 duration:(ccTime)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCTwirl* (o)
JSBool JSPROXY_CCTwirl_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTwirl* ret_val;

	ret_val = [CCTwirl actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTwirl* (o)
JSBool JSPROXY_CCTwirl_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTwirl* ret_val;

	ret_val = [CCTwirl action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTwirl_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTwirl_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTwirl_class->name = name;
	JSPROXY_CCTwirl_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTwirl_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTwirl_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTwirl_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTwirl_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTwirl_class->resolve = JS_ResolveStub;
	JSPROXY_CCTwirl_class->convert = JS_ConvertStub;
	JSPROXY_CCTwirl_class->finalize = JSPROXY_CCTwirl_finalize;
//	JSPROXY_CCTwirl_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAmplitude", JSPROXY_CCTwirl_amplitude, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getAmplitudeRate", JSPROXY_CCTwirl_amplitudeRate, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithPositionTwirlsAmplitudeGridDuration", JSPROXY_CCTwirl_initWithPosition_twirls_amplitude_grid_duration_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getPosition", JSPROXY_CCTwirl_position, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitude", JSPROXY_CCTwirl_setAmplitude_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setAmplitudeRate", JSPROXY_CCTwirl_setAmplitudeRate_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setPosition", JSPROXY_CCTwirl_setPosition_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("actionWithPositionTwirlsAmplitudeGridDuration", JSPROXY_CCTwirl_actionWithPosition_twirls_amplitude_grid_duration__static, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithSizeDuration", JSPROXY_CCTwirl_actionWithSize_duration__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCTwirl_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCTwirl_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTwirl_object = JS_InitClass(cx, globalObj, JSPROXY_CCGrid3DAction_object, JSPROXY_CCTwirl_class, JSPROXY_CCTwirl_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTwirl

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTwirl_class, JSPROXY_CCTwirl_object, NULL);
	JSPROXY_CCTwirl *proxy = [[JSPROXY_CCTwirl alloc] initWithJSObject:jsobj class:[CCTwirl class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTexturePVR
 */
#pragma mark - CCTexturePVR

JSClass* JSPROXY_CCTexturePVR_class = NULL;
JSObject* JSPROXY_CCTexturePVR_object = NULL;
 // Constructor
JSBool JSPROXY_CCTexturePVR_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTexturePVR createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTexturePVR_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTexturePVR)", obj);
}

// Arguments: 
// Ret value: CCTexture2DPixelFormat (i)
JSBool JSPROXY_CCTexturePVR_format(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTexture2DPixelFormat ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real format ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCTexturePVR_hasAlpha(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real hasAlpha ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: uint32_t (u)
JSBool JSPROXY_CCTexturePVR_height(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	uint32_t ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real height ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: None (None)
JSBool JSPROXY_CCTexturePVR_initWithContentsOfFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexturePVR *real = [(CCTexturePVR*)[proxy.klass alloc] initWithContentsOfFile:(NSString*)arg0  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLuint (u)
JSBool JSPROXY_CCTexturePVR_name(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLuint ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real name ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCTexturePVR_numberOfMipmaps(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSUInteger ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real numberOfMipmaps ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCTexturePVR* (o)
JSBool JSPROXY_CCTexturePVR_pvrTextureWithContentsOfFile__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCTexturePVR* ret_val;

	ret_val = [CCTexturePVR pvrTextureWithContentsOfFile:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCTexturePVR_retainName(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real retainName ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: BOOL
// Ret value: void (None)
JSBool JSPROXY_CCTexturePVR_setRetainName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	JSBool arg0; 

	ok &= JS_ValueToBoolean( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	[real setRetainName:(BOOL)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: uint32_t (u)
JSBool JSPROXY_CCTexturePVR_width(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	uint32_t ret_val;

	CCTexturePVR *real = (CCTexturePVR*) [proxy realObj];
	ret_val = [real width ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSPROXY_CCTexturePVR_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTexturePVR_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTexturePVR_class->name = name;
	JSPROXY_CCTexturePVR_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTexturePVR_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTexturePVR_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTexturePVR_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTexturePVR_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTexturePVR_class->resolve = JS_ResolveStub;
	JSPROXY_CCTexturePVR_class->convert = JS_ConvertStub;
	JSPROXY_CCTexturePVR_class->finalize = JSPROXY_CCTexturePVR_finalize;
//	JSPROXY_CCTexturePVR_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getFormat", JSPROXY_CCTexturePVR_format, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getHasAlpha", JSPROXY_CCTexturePVR_hasAlpha, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getHeight", JSPROXY_CCTexturePVR_height, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithContentsOfFile", JSPROXY_CCTexturePVR_initWithContentsOfFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getName", JSPROXY_CCTexturePVR_name, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getNumberOfMipmaps", JSPROXY_CCTexturePVR_numberOfMipmaps, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getRetainName", JSPROXY_CCTexturePVR_retainName, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setRetainName", JSPROXY_CCTexturePVR_setRetainName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getWidth", JSPROXY_CCTexturePVR_width, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("pvrTextureWithContentsOfFile", JSPROXY_CCTexturePVR_pvrTextureWithContentsOfFile__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTexturePVR_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCTexturePVR_class, JSPROXY_CCTexturePVR_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTexturePVR

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTexturePVR_class, JSPROXY_CCTexturePVR_object, NULL);
	JSPROXY_CCTexturePVR *proxy = [[JSPROXY_CCTexturePVR alloc] initWithJSObject:jsobj class:[CCTexturePVR class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGLProgram
 */
#pragma mark - CCGLProgram

JSClass* JSPROXY_CCGLProgram_class = NULL;
JSObject* JSPROXY_CCGLProgram_object = NULL;
 // Constructor
JSBool JSPROXY_CCGLProgram_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCGLProgram createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCGLProgram_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCGLProgram)", obj);
}

// Arguments: NSString*, GLuint
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_addAttribute_index_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; uint32_t arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAUint32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real addAttribute:(NSString*)arg0 index:(GLuint)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCGLProgram_fragmentShaderLog(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real fragmentShaderLog ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: None (None)
JSBool JSPROXY_CCGLProgram_initWithVertexShaderFilename_fragmentShaderFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && ![proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCGLProgram *real = [(CCGLProgram*)[proxy.klass alloc] initWithVertexShaderFilename:(NSString*)arg0 fragmentShaderFilename:(NSString*)arg1  ];
	[proxy setRealObj: real];
	[real autorelease];

	objc_setAssociatedObject(real, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
	[proxy release];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: BOOL (b)
JSBool JSPROXY_CCGLProgram_link(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	BOOL ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real link ];
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLint (i)
JSBool JSPROXY_CCGLProgram_program(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	GLint ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real program ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCGLProgram_programLog(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real programLog ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

// Arguments: GLint, GLfloat
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_setUniformLocation_withF1_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLfloat, GLfloat
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_setUniformLocation_withF1_f2_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; double arg2; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1 f2:(GLfloat)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLfloat, GLfloat, GLfloat
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_setUniformLocation_withF1_f2_f3_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 4, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; double arg2; double arg3; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	if( ! ok ) return JS_FALSE;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1 f2:(GLfloat)arg2 f3:(GLfloat)arg3  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLfloat, GLfloat, GLfloat, GLfloat
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_setUniformLocation_withF1_f2_f3_f4_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 5, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; double arg1; double arg2; double arg3; double arg4; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	if( ! ok ) return JS_FALSE;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withF1:(GLfloat)arg1 f2:(GLfloat)arg2 f3:(GLfloat)arg3 f4:(GLfloat)arg4  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_setUniformLocation_withI1_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformLocation:(GLint)arg0 withI1:(GLint)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_setUniformsForBuiltins(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real setUniformsForBuiltins ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_updateUniforms(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real updateUniforms ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCGLProgram_use(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	[real use ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSString* (S)
JSBool JSPROXY_CCGLProgram_vertexShaderLog(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSString* ret_val;

	CCGLProgram *real = (CCGLProgram*) [proxy realObj];
	ret_val = [real vertexShaderLog ];

	JSString *ret_obj = JS_NewStringCopyZ(cx, [ret_val UTF8String]);
	JS_SET_RVAL(cx, vp, STRING_TO_JSVAL(ret_obj) );

	return JS_TRUE;
}

void JSPROXY_CCGLProgram_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCGLProgram_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCGLProgram_class->name = name;
	JSPROXY_CCGLProgram_class->addProperty = JS_PropertyStub;
	JSPROXY_CCGLProgram_class->delProperty = JS_PropertyStub;
	JSPROXY_CCGLProgram_class->getProperty = JS_PropertyStub;
	JSPROXY_CCGLProgram_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCGLProgram_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCGLProgram_class->resolve = JS_ResolveStub;
	JSPROXY_CCGLProgram_class->convert = JS_ConvertStub;
	JSPROXY_CCGLProgram_class->finalize = JSPROXY_CCGLProgram_finalize;
//	JSPROXY_CCGLProgram_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addAttributeIndex", JSPROXY_CCGLProgram_addAttribute_index_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("fragmentShaderLog", JSPROXY_CCGLProgram_fragmentShaderLog, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("initWithVertexShaderFilenameFragmentShaderFilename", JSPROXY_CCGLProgram_initWithVertexShaderFilename_fragmentShaderFilename_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("link", JSPROXY_CCGLProgram_link, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getProgram", JSPROXY_CCGLProgram_program, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("programLog", JSPROXY_CCGLProgram_programLog, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUniformLocationWithF1", JSPROXY_CCGLProgram_setUniformLocation_withF1_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUniformLocationWithF1F2", JSPROXY_CCGLProgram_setUniformLocation_withF1_f2_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUniformLocationWithF1F2F3", JSPROXY_CCGLProgram_setUniformLocation_withF1_f2_f3_, 4, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUniformLocationWithF1F2F3F4", JSPROXY_CCGLProgram_setUniformLocation_withF1_f2_f3_f4_, 5, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUniformLocationWithI1", JSPROXY_CCGLProgram_setUniformLocation_withI1_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setUniformsForBuiltins", JSPROXY_CCGLProgram_setUniformsForBuiltins, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("updateUniforms", JSPROXY_CCGLProgram_updateUniforms, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("use", JSPROXY_CCGLProgram_use, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("vertexShaderLog", JSPROXY_CCGLProgram_vertexShaderLog, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCGLProgram_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCGLProgram_class, JSPROXY_CCGLProgram_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCGLProgram

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCGLProgram_class, JSPROXY_CCGLProgram_object, NULL);
	JSPROXY_CCGLProgram *proxy = [[JSPROXY_CCGLProgram alloc] initWithJSObject:jsobj class:[CCGLProgram class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCGrid3D
 */
#pragma mark - CCGrid3D

JSClass* JSPROXY_CCGrid3D_class = NULL;
JSObject* JSPROXY_CCGrid3D_object = NULL;
 // Constructor
JSBool JSPROXY_CCGrid3D_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCGrid3D createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCGrid3D_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCGrid3D)", obj);
}

// Arguments: ccGridSize
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSPROXY_CCGrid3D_originalVertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	ccVertex3F ret_val;

	CCGrid3D *real = (CCGrid3D*) [proxy realObj];
	ret_val = [real originalVertex:(ccGridSize)arg0  ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	ccVertex3F* buffer = (ccVertex3F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: ccGridSize, ccVertex3F
// Ret value: void (None)
JSBool JSPROXY_CCGrid3D_setVertex_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; ccVertex3F arg1; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );

	JSObject *tmp_arg1;
	ok &= JS_ValueToObject( cx, *argvp++, &tmp_arg1 );
	arg1 = *(ccVertex3F*)JS_GetTypedArrayData( tmp_arg1);
	if( ! ok ) return JS_FALSE;

	CCGrid3D *real = (CCGrid3D*) [proxy realObj];
	[real setVertex:(ccGridSize)arg0 vertex:(ccVertex3F)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: ccGridSize
// Ret value: ccVertex3F ({_ccVertex3F=fff})
JSBool JSPROXY_CCGrid3D_vertex_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	ccVertex3F ret_val;

	CCGrid3D *real = (CCGrid3D*) [proxy realObj];
	ret_val = [real vertex:(ccGridSize)arg0  ];

	JSObject *typedArray = js_CreateTypedArray(cx, js::TypedArray::TYPE_FLOAT32, 3 );
	ccVertex3F* buffer = (ccVertex3F*)JS_GetTypedArrayData(typedArray);
	*buffer = ret_val;
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(typedArray));
	
	return JS_TRUE;
}

// Arguments: ccGridSize
// Ret value: CCGrid3D* (o)
JSBool JSPROXY_CCGrid3D_gridWithSize__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	if( ! ok ) return JS_FALSE;
	CCGrid3D* ret_val;

	ret_val = [CCGrid3D gridWithSize:(ccGridSize)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccGridSize, CCTexture2D*, BOOL
// Ret value: CCGrid3D* (o)
JSBool JSPROXY_CCGrid3D_gridWithSize_texture_flippedTexture__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	ccGridSize arg0; id arg1; JSBool arg2; 

	ok &= jsval_to_ccGridSize( cx, *argvp++, (ccGridSize*) &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;
	CCGrid3D* ret_val;

	ret_val = [CCGrid3D gridWithSize:(ccGridSize)arg0 texture:(CCTexture2D*)arg1 flippedTexture:(BOOL)arg2  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCGrid3D_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCGrid3D_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCGrid3D_class->name = name;
	JSPROXY_CCGrid3D_class->addProperty = JS_PropertyStub;
	JSPROXY_CCGrid3D_class->delProperty = JS_PropertyStub;
	JSPROXY_CCGrid3D_class->getProperty = JS_PropertyStub;
	JSPROXY_CCGrid3D_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCGrid3D_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCGrid3D_class->resolve = JS_ResolveStub;
	JSPROXY_CCGrid3D_class->convert = JS_ConvertStub;
	JSPROXY_CCGrid3D_class->finalize = JSPROXY_CCGrid3D_finalize;
//	JSPROXY_CCGrid3D_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("originalVertex", JSPROXY_CCGrid3D_originalVertex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("setVertexVertex", JSPROXY_CCGrid3D_setVertex_vertex_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("vertex", JSPROXY_CCGrid3D_vertex_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("gridWithSize", JSPROXY_CCGrid3D_gridWithSize__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("gridWithSizeTextureFlippedTexture", JSPROXY_CCGrid3D_gridWithSize_texture_flippedTexture__static, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCGrid3D_object = JS_InitClass(cx, globalObj, JSPROXY_CCGridBase_object, JSPROXY_CCGrid3D_class, JSPROXY_CCGrid3D_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCGrid3D

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCGrid3D_class, JSPROXY_CCGrid3D_object, NULL);
	JSPROXY_CCGrid3D *proxy = [[JSPROXY_CCGrid3D alloc] initWithJSObject:jsobj class:[CCGrid3D class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCActionManager
 */
#pragma mark - CCActionManager

JSClass* JSPROXY_CCActionManager_class = NULL;
JSObject* JSPROXY_CCActionManager_object = NULL;
 // Constructor
JSBool JSPROXY_CCActionManager_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCActionManager createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCActionManager_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCActionManager)", obj);
}

// Arguments: CCAction*, NSObject*, BOOL
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_addAction_target_paused_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 3, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; id arg1; JSBool arg2; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	ok &= JS_ValueToBoolean( cx, *argvp++, &arg2 );
	if( ! ok ) return JS_FALSE;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real addAction:(CCAction*)arg0 target:(NSObject*)arg1 paused:(BOOL)arg2  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger, NSObject*
// Ret value: CCAction* (o)
JSBool JSPROXY_CCActionManager_getActionByTag_target_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; id arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCAction* ret_val;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	ret_val = [real getActionByTag:(NSInteger)arg0 target:(NSObject*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: NSUInteger (u)
JSBool JSPROXY_CCActionManager_numberOfRunningActionsInTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	NSUInteger ret_val;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	ret_val = [real numberOfRunningActionsInTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: NSSet* (set)
JSBool JSPROXY_CCActionManager_pauseAllRunningActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	NSSet* ret_val;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	ret_val = [real pauseAllRunningActions ];

	jsval ret_jsval = NSSet_to_jsval( cx, (NSSet*) ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval );

	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_pauseTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real pauseTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCAction*
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_removeAction_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeAction:(CCAction*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSInteger, NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_removeActionByTag_target_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; id arg1; 

	ok &= JS_ValueToECMAInt32( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeActionByTag:(NSInteger)arg0 target:(NSObject*)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_removeAllActions(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeAllActions ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_removeAllActionsFromTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real removeAllActionsFromTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSObject*
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_resumeTarget_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real resumeTarget:(NSObject*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSSet*
// Ret value: void (None)
JSBool JSPROXY_CCActionManager_resumeTargets_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSSet* arg0; 

	ok &= jsval_to_nsset( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCActionManager *real = (CCActionManager*) [proxy realObj];
	[real resumeTargets:(NSSet*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSPROXY_CCActionManager_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCActionManager_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCActionManager_class->name = name;
	JSPROXY_CCActionManager_class->addProperty = JS_PropertyStub;
	JSPROXY_CCActionManager_class->delProperty = JS_PropertyStub;
	JSPROXY_CCActionManager_class->getProperty = JS_PropertyStub;
	JSPROXY_CCActionManager_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCActionManager_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCActionManager_class->resolve = JS_ResolveStub;
	JSPROXY_CCActionManager_class->convert = JS_ConvertStub;
	JSPROXY_CCActionManager_class->finalize = JSPROXY_CCActionManager_finalize;
//	JSPROXY_CCActionManager_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addAction", JSPROXY_CCActionManager_addAction_target_paused_, 3, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getActionByTag", JSPROXY_CCActionManager_getActionByTag_target_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("numberOfRunningActionsInTarget", JSPROXY_CCActionManager_numberOfRunningActionsInTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("pauseAllRunningActions", JSPROXY_CCActionManager_pauseAllRunningActions, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("pauseTarget", JSPROXY_CCActionManager_pauseTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeAction", JSPROXY_CCActionManager_removeAction_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeActionByTag", JSPROXY_CCActionManager_removeActionByTag_target_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeAllActions", JSPROXY_CCActionManager_removeAllActions, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeAllActionsFromTarget", JSPROXY_CCActionManager_removeAllActionsFromTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("resumeTarget", JSPROXY_CCActionManager_resumeTarget_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("resumeTargets", JSPROXY_CCActionManager_resumeTargets_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSPROXY_CCActionManager_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCActionManager_class, JSPROXY_CCActionManager_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCActionManager

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCActionManager_class, JSPROXY_CCActionManager_object, NULL);
	JSPROXY_CCActionManager *proxy = [[JSPROXY_CCActionManager alloc] initWithJSObject:jsobj class:[CCActionManager class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCSpriteFrameCache
 */
#pragma mark - CCSpriteFrameCache

JSClass* JSPROXY_CCSpriteFrameCache_class = NULL;
JSObject* JSPROXY_CCSpriteFrameCache_object = NULL;
 // Constructor
JSBool JSPROXY_CCSpriteFrameCache_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCSpriteFrameCache createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCSpriteFrameCache_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCSpriteFrameCache)", obj);
}

// Arguments: CCSpriteFrame*, NSString*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_addSpriteFrame_name_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; NSString* arg1; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFrame:(CCSpriteFrame*)arg0 name:(NSString*)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_addSpriteFramesWithFile_texture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; id arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFramesWithFile:(NSString*)arg0 texture:(CCTexture2D*)arg1  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*, NSString*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_addSpriteFramesWithFile_textureFilename_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc >= 1 && argc <= 2 , "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; NSString* arg1; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if (argc >= 2) {
		ok &= jsval_to_nsstring( cx, *argvp++, &arg1 );
	}
	if( ! ok ) return JS_FALSE;

	if( argc == 1 ) {
		CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFramesWithFile:(NSString*)arg0  ];
	}
	else if( argc == 2 ) {
		CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real addSpriteFramesWithFile:(NSString*)arg0 textureFilename:(NSString*)arg1  ];
	}
	else
		return JS_FALSE;

	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_purgeSharedSpriteFrameCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	[CCSpriteFrameCache purgeSharedSpriteFrameCache ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_removeSpriteFrameByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFrameByName:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_removeSpriteFrames(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFrames ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_removeSpriteFramesFromFile_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFramesFromFile:(NSString*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCTexture2D*
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_removeSpriteFramesFromTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeSpriteFramesFromTexture:(CCTexture2D*)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void (None)
JSBool JSPROXY_CCSpriteFrameCache_removeUnusedSpriteFrames(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	[real removeUnusedSpriteFrames ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: CCSpriteFrameCache* (o)
JSBool JSPROXY_CCSpriteFrameCache_sharedSpriteFrameCache_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCSpriteFrameCache* ret_val;

	ret_val = [CCSpriteFrameCache sharedSpriteFrameCache ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: NSString*
// Ret value: CCSpriteFrame* (o)
JSBool JSPROXY_CCSpriteFrameCache_spriteFrameByName_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	NSString* arg0; 

	ok &= jsval_to_nsstring( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCSpriteFrame* ret_val;

	CCSpriteFrameCache *real = (CCSpriteFrameCache*) [proxy realObj];
	ret_val = [real spriteFrameByName:(NSString*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCSpriteFrameCache_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCSpriteFrameCache_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCSpriteFrameCache_class->name = name;
	JSPROXY_CCSpriteFrameCache_class->addProperty = JS_PropertyStub;
	JSPROXY_CCSpriteFrameCache_class->delProperty = JS_PropertyStub;
	JSPROXY_CCSpriteFrameCache_class->getProperty = JS_PropertyStub;
	JSPROXY_CCSpriteFrameCache_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCSpriteFrameCache_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCSpriteFrameCache_class->resolve = JS_ResolveStub;
	JSPROXY_CCSpriteFrameCache_class->convert = JS_ConvertStub;
	JSPROXY_CCSpriteFrameCache_class->finalize = JSPROXY_CCSpriteFrameCache_finalize;
//	JSPROXY_CCSpriteFrameCache_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("addSpriteFrameName", JSPROXY_CCSpriteFrameCache_addSpriteFrame_name_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("addSpriteFramesWithFileTexture", JSPROXY_CCSpriteFrameCache_addSpriteFramesWithFile_texture_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("addSpriteFrames", JSPROXY_CCSpriteFrameCache_addSpriteFramesWithFile_textureFilename_, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFrameByName", JSPROXY_CCSpriteFrameCache_removeSpriteFrameByName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFrames", JSPROXY_CCSpriteFrameCache_removeSpriteFrames, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFramesFromFile", JSPROXY_CCSpriteFrameCache_removeSpriteFramesFromFile_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeSpriteFramesFromTexture", JSPROXY_CCSpriteFrameCache_removeSpriteFramesFromTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("removeUnusedSpriteFrames", JSPROXY_CCSpriteFrameCache_removeUnusedSpriteFrames, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("spriteFrameByName", JSPROXY_CCSpriteFrameCache_spriteFrameByName_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("purgeSharedSpriteFrameCache", JSPROXY_CCSpriteFrameCache_purgeSharedSpriteFrameCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("getInstance", JSPROXY_CCSpriteFrameCache_sharedSpriteFrameCache_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCSpriteFrameCache_object = JS_InitClass(cx, globalObj, JSPROXY_NSObject_object, JSPROXY_CCSpriteFrameCache_class, JSPROXY_CCSpriteFrameCache_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCSpriteFrameCache

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCSpriteFrameCache_class, JSPROXY_CCSpriteFrameCache_object, NULL);
	JSPROXY_CCSpriteFrameCache *proxy = [[JSPROXY_CCSpriteFrameCache alloc] initWithJSObject:jsobj class:[CCSpriteFrameCache class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCEaseSineOut
 */
#pragma mark - CCEaseSineOut

JSClass* JSPROXY_CCEaseSineOut_class = NULL;
JSObject* JSPROXY_CCEaseSineOut_object = NULL;
 // Constructor
JSBool JSPROXY_CCEaseSineOut_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCEaseSineOut createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCEaseSineOut_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCEaseSineOut)", obj);
}

// Arguments: ccTime
// Ret value: void (None)
JSBool JSPROXY_CCEaseSineOut_update_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;

	CCEaseSineOut *real = (CCEaseSineOut*) [proxy realObj];
	[real update:(ccTime)arg0  ];
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: CCActionInterval*
// Ret value: CCEaseSineOut* (o)
JSBool JSPROXY_CCEaseSineOut_actionWithAction__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCEaseSineOut* ret_val;

	ret_val = [CCEaseSineOut actionWithAction:(CCActionInterval*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime
// Ret value: CCEaseSineOut* (o)
JSBool JSPROXY_CCEaseSineOut_actionWithDuration__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	if( ! ok ) return JS_FALSE;
	CCEaseSineOut* ret_val;

	ret_val = [CCEaseSineOut actionWithDuration:(ccTime)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCEaseSineOut* (o)
JSBool JSPROXY_CCEaseSineOut_action_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCEaseSineOut* ret_val;

	ret_val = [CCEaseSineOut action ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCEaseSineOut_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCEaseSineOut_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCEaseSineOut_class->name = name;
	JSPROXY_CCEaseSineOut_class->addProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineOut_class->delProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineOut_class->getProperty = JS_PropertyStub;
	JSPROXY_CCEaseSineOut_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCEaseSineOut_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCEaseSineOut_class->resolve = JS_ResolveStub;
	JSPROXY_CCEaseSineOut_class->convert = JS_ConvertStub;
	JSPROXY_CCEaseSineOut_class->finalize = JSPROXY_CCEaseSineOut_finalize;
//	JSPROXY_CCEaseSineOut_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("update", JSPROXY_CCEaseSineOut_update_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCEaseSineOut_actionWithAction__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("actionWithDuration", JSPROXY_CCEaseSineOut_actionWithDuration__static, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("action", JSPROXY_CCEaseSineOut_action_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCEaseSineOut_object = JS_InitClass(cx, globalObj, JSPROXY_CCActionEase_object, JSPROXY_CCEaseSineOut_class, JSPROXY_CCEaseSineOut_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCEaseSineOut

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCEaseSineOut_class, JSPROXY_CCEaseSineOut_object, NULL);
	JSPROXY_CCEaseSineOut *proxy = [[JSPROXY_CCEaseSineOut alloc] initWithJSObject:jsobj class:[CCEaseSineOut class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end

/*
 * CCTransitionProgressOutIn
 */
#pragma mark - CCTransitionProgressOutIn

JSClass* JSPROXY_CCTransitionProgressOutIn_class = NULL;
JSObject* JSPROXY_CCTransitionProgressOutIn_object = NULL;
 // Constructor
JSBool JSPROXY_CCTransitionProgressOutIn_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSObject *jsobj = [JSPROXY_CCTransitionProgressOutIn createJSObjectWithRealObject:nil context:cx];
    JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

    return JS_TRUE;
}

// Destructor
void JSPROXY_CCTransitionProgressOutIn_finalize(JSContext *cx, JSObject *obj)
{
	CCLOGINFO(@"spidermonkey: finalizing JS object %p (CCTransitionProgressOutIn)", obj);
}

// Arguments: CCRenderTexture*
// Ret value: CCProgressTimer* (o)
JSBool JSPROXY_CCTransitionProgressOutIn_progressTimerNodeWithRenderTexture_(JSContext *cx, uint32_t argc, jsval *vp) {

	JSObject* obj = (JSObject *)JS_THIS_OBJECT(cx, vp);
	JSPROXY_NSObject *proxy = get_proxy_for_jsobject(obj);

	NSCAssert( proxy && [proxy realObj], @"Invalid Proxy object");
	JSB_PRECONDITION( argc == 1, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	id arg0; 

	ok &= jsval_to_nsobject( cx, *argvp++, &arg0);
	if( ! ok ) return JS_FALSE;
	CCProgressTimer* ret_val;

	CCTransitionProgressOutIn *real = (CCTransitionProgressOutIn*) [proxy realObj];
	ret_val = [real progressTimerNodeWithRenderTexture:(CCRenderTexture*)arg0  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: ccTime, CCScene*
// Ret value: CCTransitionProgressOutIn* (o)
JSBool JSPROXY_CCTransitionProgressOutIn_transitionWithDuration_scene__static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 2, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg0; id arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg0 );
	ok &= jsval_to_nsobject( cx, *argvp++, &arg1);
	if( ! ok ) return JS_FALSE;
	CCTransitionProgressOutIn* ret_val;

	ret_val = [CCTransitionProgressOutIn transitionWithDuration:(ccTime)arg0 scene:(CCScene*)arg1  ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: 
// Ret value: CCTransitionProgressOutIn* (o)
JSBool JSPROXY_CCTransitionProgressOutIn_node_static(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION( argc == 0, "Invalid number of arguments" );
	CCTransitionProgressOutIn* ret_val;

	ret_val = [CCTransitionProgressOutIn node ];

	JSObject *jsobj = get_or_create_jsobject_from_realobj( cx, ret_val );
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

void JSPROXY_CCTransitionProgressOutIn_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSPROXY_CCTransitionProgressOutIn_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSPROXY_CCTransitionProgressOutIn_class->name = name;
	JSPROXY_CCTransitionProgressOutIn_class->addProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressOutIn_class->delProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressOutIn_class->getProperty = JS_PropertyStub;
	JSPROXY_CCTransitionProgressOutIn_class->setProperty = JS_StrictPropertyStub;
	JSPROXY_CCTransitionProgressOutIn_class->enumerate = JS_EnumerateStub;
	JSPROXY_CCTransitionProgressOutIn_class->resolve = JS_ResolveStub;
	JSPROXY_CCTransitionProgressOutIn_class->convert = JS_ConvertStub;
	JSPROXY_CCTransitionProgressOutIn_class->finalize = JSPROXY_CCTransitionProgressOutIn_finalize;
//	JSPROXY_CCTransitionProgressOutIn_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("progressTimerNodeWithRenderTexture", JSPROXY_CCTransitionProgressOutIn_progressTimerNodeWithRenderTexture_, 1, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FN("create", JSPROXY_CCTransitionProgressOutIn_transitionWithDuration_scene__static, 2, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FN("node", JSPROXY_CCTransitionProgressOutIn_node_static, 0, JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE),
		JS_FS_END
	};

	JSPROXY_CCTransitionProgressOutIn_object = JS_InitClass(cx, globalObj, JSPROXY_CCTransitionProgress_object, JSPROXY_CCTransitionProgressOutIn_class, JSPROXY_CCTransitionProgressOutIn_constructor,0,properties,funcs,NULL,st_funcs);
}

@implementation JSPROXY_CCTransitionProgressOutIn

+(JSObject*) createJSObjectWithRealObject:(id)realObj context:(JSContext*)cx
{
	JSObject *jsobj = JS_NewObject(cx, JSPROXY_CCTransitionProgressOutIn_class, JSPROXY_CCTransitionProgressOutIn_object, NULL);
	JSPROXY_CCTransitionProgressOutIn *proxy = [[JSPROXY_CCTransitionProgressOutIn alloc] initWithJSObject:jsobj class:[CCTransitionProgressOutIn class]];
	[proxy setRealObj:realObj];

	if( realObj ) {
		objc_setAssociatedObject(realObj, &JSPROXY_association_proxy_key, proxy, OBJC_ASSOCIATION_RETAIN);
		[proxy release];
	}

	[self swizzleMethods];

	return jsobj;
}

@end
